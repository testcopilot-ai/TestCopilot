Dataset_ID,Functional_Requirement,Method_Signature,Correct_Code
1462,"There are a total of `numCourses` courses you have to take, labeled from `0`
to `numCourses - 1`. You are given an array `prerequisites` where
`prerequisites[i] = [ai, bi]` indicates that you must take course `ai` first
if you want to take course `bi`.

* For example, the pair `[0, 1]` indicates that you have to take course `0` before you can take course `1`.

Prerequisites can also be indirect. If course `a` is a prerequisite of course
`b`, and course `b` is a prerequisite of course `c`, then course `a` is a
prerequisite of course `c`.

You are also given an array `queries` where `queries[j] = [uj, vj]`. For the
`jth` query, you should answer whether course `uj` is a prerequisite of course
`vj` or not.

Return a boolean array `answer`, where `answer[j]` is the answer to the `jth`
query.

","def checkIfPrerequisite(self, numCourses: int, prerequisites: List[List[int]], queries: List[List[int]]) -> List[bool]:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def checkIfPrerequisite(self, numCourses: int, prerequisites: List[List[int]], queries: List[List[int]]) -> List[bool]:
    graph = [[] for _ in range(numCourses)]
    isPrerequisite = [[False] * numCourses for _ in range(numCourses)]

    for u, v in prerequisites:
      graph[u].append(v)

    for i in range(numCourses):
      self._dfs(graph, i, isPrerequisite[i])

    return [isPrerequisite[u][v] for u, v in queries]

  def _dfs(self, graph: List[List[int]], u: int, used: List[bool]) -> None:
    for v in graph[u]:
      if used[v]:
        continue
      used[v] = True
      self._dfs(graph, v, used)
"
2662,"You are given an array `start` where `start = [startX, startY]` represents
your initial position `(startX, startY)` in a 2D space. You are also given the
array `target` where `target = [targetX, targetY]` represents your target
position `(targetX, targetY)`.

The cost of going from a position `(x1, y1)` to any other position in the
space `(x2, y2)` is `|x2 - x1| + |y2 - y1|`.

There are also some special roads. You are given a 2D array `specialRoads`
where `specialRoads[i] = [x1i, y1i, x2i, y2i, costi]` indicates that the `ith`
special road can take you from `(x1i, y1i)` to `(x2i, y2i)` with a cost equal
to `costi`. You can use each special road any number of times.

Return the minimum cost required to go from `(startX, startY)` to `(targetX,
targetY)`.

","def minimumCost(self, start: List[int], target: List[int], specialRoads: List[List[int]]) -> int:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def minimumCost(self, start: List[int], target: List[int], specialRoads: List[List[int]]) -> int:
    return self.dijkstra(specialRoads, *start, *target)

  def dijkstra(self, specialRoads: List[List[int]], srcX: int, srcY: int, dstX: int, dstY: int) -> int:
    n = len(specialRoads)
    dist = [math.inf] * n
    minHeap = []

    for u, (x1, y1, _, _, cost) in enumerate(specialRoads):
      d = abs(x1 - srcX) + abs(y1 - srcY) + cost
      dist[u] = d
      heapq.heappush(minHeap, (dist[u], u))

    while minHeap:
      d, u = heapq.heappop(minHeap)
      if d > dist[u]:
        continue
      _, _, ux2, uy2, _ = specialRoads[u]
      for v in range(n):
        if v == u:
          continue
        vx1, vy1, _, _, vcost = specialRoads[v]
        newDist = d + abs(vx1 - ux2) + abs(vy1 - uy2) + vcost
        if newDist < dist[v]:
          dist[v] = newDist
          heapq.heappush(minHeap, (dist[v], v))

    ans = abs(dstX - srcX) + abs(dstY - srcY)
    for u in range(n):
      _, _, x2, y2, _ = specialRoads[u]
      ans = min(ans, dist[u] + abs(dstX - x2) + abs(dstY - y2))

    return ans
"
289,"According to Wikipedia's article: ""The Game of Life, also known simply as
Life, is a cellular automaton devised by the British mathematician John Horton
Conway in 1970.""

The board is made up of an `m x n` grid of cells, where each cell has an
initial state: live (represented by a `1`) or dead (represented by a `0`).
Each cell interacts with its eight neighbors (horizontal, vertical, diagonal)
using the following four rules (taken from the above Wikipedia article):

1. Any live cell with fewer than two live neighbors dies as if caused by under-population.
2. Any live cell with two or three live neighbors lives on to the next generation.
3. Any live cell with more than three live neighbors dies, as if by over-population.
4. Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.

The next state is created by applying the above rules simultaneously to every
cell in the current state, where births and deaths occur simultaneously. Given
the current state of the `m x n` grid `board`, return the next state.

","def gameOfLife(self, board: List[List[int]]) -> None:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def gameOfLife(self, board: List[List[int]]) -> None:
    m = len(board)
    n = len(board[0])

    for i in range(m):
      for j in range(n):
        ones = 0
        for x in range(max(0, i - 1), min(m, i + 2)):
          for y in range(max(0, j - 1), min(n, j + 2)):
            ones += board[x][y] & 1

        if board[i][j] == 1 and (ones == 3 or ones == 4):
          board[i][j] |= 0b10

        if board[i][j] == 0 and ones == 3:
          board[i][j] |= 0b10

    for i in range(m):
      for j in range(n):
        board[i][j] >>= 1
"
1253,"Given the following details of a matrix with `n` columns and `2` rows :

* The matrix is a binary matrix, which means each element in the matrix can be `0` or `1`.
* The sum of elements of the 0-th(upper) row is given as `upper`.
* The sum of elements of the 1-st(lower) row is given as `lower`.
* The sum of elements in the i-th column(0-indexed) is `colsum[i]`, where `colsum` is given as an integer array with length `n`.

Your task is to reconstruct the matrix with `upper`, `lower` and `colsum`.

Return it as a 2-D integer array.

If there are more than one valid solution, any of them will be accepted.

If no valid solution exists, return an empty 2-D array.

","def reconstructMatrix(self, upper: int, lower: int, colsum: List[int]) -> List[List[int]]:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def reconstructMatrix(self, upper: int, lower: int, colsum: List[int]) -> List[List[int]]:
    if upper + lower != sum(colsum):
      return []
    if min(upper, lower) < colsum.count(2):
      return []

    ans = [[0] * len(colsum) for _ in range(2)]

    for j, c in enumerate(colsum):
      if c == 2:
        ans[0][j] = 1
        ans[1][j] = 1
        upper -= 1
        lower -= 1

    for j, c in enumerate(colsum):
      if c == 1 and upper > 0:
        ans[0][j] = 1
        c -= 1
        upper -= 1
      if c == 1 and lower > 0:
        ans[1][j] = 1
        lower -= 1

    return ans
"
54,"Given an `m x n` `matrix`, return all elements of the `matrix` in spiral
order.

","def spiralOrder(self, matrix: List[List[int]]) -> List[int]:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def spiralOrder(self, matrix: List[List[int]]) -> List[int]:
    if not matrix:
      return []

    m = len(matrix)
    n = len(matrix[0])
    ans = []
    r1 = 0
    c1 = 0
    r2 = m - 1
    c2 = n - 1

    while len(ans) < m * n:
      j = c1
      while j <= c2 and len(ans) < m * n:
        ans.append(matrix[r1][j])
        j += 1
      i = r1 + 1
      while i <= r2 - 1 and len(ans) < m * n:
        ans.append(matrix[i][c2])
        i += 1
      j = c2
      while j >= c1 and len(ans) < m * n:
        ans.append(matrix[r2][j])
        j -= 1
      i = r2 - 1
      while i >= r1 + 1 and len(ans) < m * n:
        ans.append(matrix[i][c1])
        i -= 1
      r1 += 1
      c1 += 1
      r2 -= 1
      c2 -= 1

    return ans
"
130,"Given an `m x n` matrix `board` containing `'X'` and `'O'`, capture all
regions that are 4-directionally surrounded by `'X'`.

A region is captured by flipping all `'O'`s into `'X'`s in that surrounded
region.

","def solve(self, board: List[List[str]]) -> None:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def solve(self, board: List[List[str]]) -> None:
    if not board:
      return

    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))
    m = len(board)
    n = len(board[0])
    q = collections.deque()

    for i in range(m):
      for j in range(n):
        if i * j == 0 or i == m - 1 or j == n - 1:
          if board[i][j] == 'O':
            q.append((i, j))
            board[i][j] = '*'

    while q:
      i, j = q.popleft()
      for dx, dy in dirs:
        x = i + dx
        y = j + dy
        if x < 0 or x == m or y < 0 or y == n:
          continue
        if board[x][y] != 'O':
          continue
        q.append((x, y))
        board[x][y] = '*'

    for row in board:
      for i, c in enumerate(row):
        if c == '*':
          row[i] = 'O'
        else:
          row[i] = 'X'
"
787,"There are `n` cities connected by some number of flights. You are given an
array `flights` where `flights[i] = [fromi, toi, pricei]` indicates that there
is a flight from city `fromi` to city `toi` with cost `pricei`.

You are also given three integers `src`, `dst`, and `k`, return the cheapest
price from `src` to `dst` with at most `k` stops. If there is no such route,
return `-1`.

","def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:
    graph = [[] for _ in range(n)]

    for u, v, w in flights:
      graph[u].append((v, w))

    return self._dijkstra(graph, src, dst, k)

  def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, dst: int, k: int) -> int:
    dist=[]
    for i in range(len(graph)):
      dist.append([math.inf for _ in range(k + 2)])

    dist[src][k + 1] = 0
    minHeap = [(dist[src][k + 1], src, k + 1)]

    while minHeap:
      d, u, stops = heapq.heappop(minHeap)
      if u == dst:
        return d
      if stops == 0 or d > dist[u][stops]:
        continue
      for v, w in graph[u]:
        if d + w < dist[v][stops - 1]:
          dist[v][stops - 1] = d + w
          heapq.heappush(minHeap, (dist[v][stops - 1], v, stops - 1))

    return -1
"
1162,"Given an `n x n` `grid` containing only values `0` and `1`, where `0`
represents water and `1` represents land, find a water cell such that its
distance to the nearest land cell is maximized, and return the distance. If no
land or water exists in the grid, return `-1`.

The distance used in this problem is the Manhattan distance: the distance
between two cells `(x0, y0)` and `(x1, y1)` is `|x0 - x1| + |y0 - y1|`.

","def maxDistance(self, grid: List[List[int]]) -> int:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def maxDistance(self, grid: List[List[int]]) -> int:
    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))
    m = len(grid)
    n = len(grid[0])
    q = collections.deque()
    water = 0

    for i in range(m):
      for j in range(n):
        if grid[i][j] == 0:
          water += 1
        else:
          q.append((i, j))

    if water == 0 or water == m * n:
      return -1

    ans = 0
    d = 0

    while q:
      for _ in range(len(q)):
        i, j = q.popleft()
        ans = d
        for dx, dy in dirs:
          x = i + dx
          y = j + dy
          if x < 0 or x == m or y < 0 or y == n:
            continue
          if grid[x][y] > 0:
            continue
          q.append((x, y))
          grid[x][y] = 2
      d += 1

    return ans
"
1377,"Given an undirected tree consisting of `n` vertices numbered from `1` to `n`.
A frog starts jumping from vertex 1. In one second, the frog jumps from its
current vertex to another unvisited vertex if they are directly connected. The
frog can not jump back to a visited vertex. In case the frog can jump to
several vertices, it jumps randomly to one of them with the same probability.
Otherwise, when the frog can not jump to any unvisited vertex, it jumps
forever on the same vertex.

The edges of the undirected tree are given in the array `edges`, where
`edges[i] = [ai, bi]` means that exists an edge connecting the vertices `ai`
and `bi`.

Return the probability that after `t` seconds the frog is on the vertex
`target`. Answers within `10-5` of the actual answer will be accepted.

","def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:
    tree = [[] for _ in range(n + 1)]
    q = collections.deque([1])
    seen = [False] * (n + 1)
    prob = [0] * (n + 1)

    prob[1] = 1
    seen[1] = True

    for u, v in edges:
      tree[u].append(v)
      tree[v].append(u)

    for _ in range(t):
      for _ in range(len(q)):
        a = q.popleft()
        nChildren = sum(not seen[b] for b in tree[a])
        for b in tree[a]:
          if seen[b]:
            continue
          seen[b] = True
          prob[b] = prob[a] / nChildren
          q.append(b)
        if nChildren > 0:
          prob[a] = 0

    return prob[target]
"
73,"Given an `m x n` integer matrix `matrix`, if an element is `0`, set its entire
row and column to `0`'s.

You must do it in place.

","def setZeroes(self, matrix: List[List[int]]) -> None:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def setZeroes(self, matrix: List[List[int]]) -> None:
    m = len(matrix)
    n = len(matrix[0])
    shouldFillFirstRow = 0 in matrix[0]
    shouldFillFirstCol = 0 in list(zip(*matrix))[0]

    for i in range(1, m):
      for j in range(1, n):
        if matrix[i][j] == 0:
          matrix[i][0] = 0
          matrix[0][j] = 0

    for i in range(1, m):
      for j in range(1, n):
        if matrix[i][0] == 0 or matrix[0][j] == 0:
          matrix[i][j] = 0

    if shouldFillFirstRow:
      matrix[0] = [0] * n

    if shouldFillFirstCol:
      for row in matrix:
        row[0] = 0
"
10,"Given an input string `s` and a pattern `p`, implement regular expression
matching with support for `'.'` and `'*'` where:

* `'.'` Matches any single character.​​​​
* `'*'` Matches zero or more of the preceding element.

The matching should cover the entire input string (not partial).

","def isMatch(self, s: str, p: str) -> bool:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def isMatch(self, s: str, p: str) -> bool:
    m = len(s)
    n = len(p)
    dp = [[False] * (n + 1) for _ in range(m + 1)]
    dp[0][0] = True

    def isMatch(i: int, j: int) -> bool:
      return j >= 0 and p[j] == '.' or s[i] == p[j]

    for j, c in enumerate(p):
      if c == '*' and dp[0][j - 1]:
        dp[0][j + 1] = True

    for i in range(m):
      for j in range(n):
        if p[j] == '*':
          noRepeat = dp[i + 1][j - 1]
          doRepeat = isMatch(i, j - 1) and dp[i][j + 1]
          dp[i + 1][j + 1] = noRepeat or doRepeat
        elif isMatch(i, j):
          dp[i + 1][j + 1] = dp[i][j]

    return dp[m][n]
"
2462,"You are given a 0-indexed integer array `costs` where `costs[i]` is the cost
of hiring the `ith` worker.

You are also given two integers `k` and `candidates`. We want to hire exactly
`k` workers according to the following rules:

* You will run `k` sessions and hire exactly one worker in each session.
* In each hiring session, choose the worker with the lowest cost from either the first `candidates` workers or the last `candidates` workers. Break the tie by the smallest index. 
* For example, if `costs = [3,2,7,7,1,2]` and `candidates = 2`, then in the first hiring session, we will choose the `4th` worker because they have the lowest cost `[3,2,7,7,1,2]`.
* In the second hiring session, we will choose `1st` worker because they have the same lowest cost as `4th` worker but they have the smallest index `[3,2,7,7,2]`. Please note that the indexing may be changed in the process.
* If there are fewer than candidates workers remaining, choose the worker with the lowest cost among them. Break the tie by the smallest index.
* A worker can only be chosen once.

Return the total cost to hire exactly `k` workers.

","def totalCost(self, costs: List[int], k: int, candidates: int) -> int:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def totalCost(self, costs: List[int], k: int, candidates: int) -> int:
    ans = 0
    i = 0
    j = len(costs) - 1
    minHeapL = []
    minHeapR = []

    for _ in range(k):
      while len(minHeapL) < candidates and i <= j:
        heapq.heappush(minHeapL, costs[i])
        i += 1
      while len(minHeapR) < candidates and i <= j:
        heapq.heappush(minHeapR, costs[j])
        j -= 1
      if not minHeapL:
        ans += heapq.heappop(minHeapR)
      elif not minHeapR:
        ans += heapq.heappop(minHeapL)
      elif minHeapL[0] <= minHeapR[0]:
        ans += heapq.heappop(minHeapL)
      else:
        ans += heapq.heappop(minHeapR)

    return ans
"
2653,"Given an integer array `nums` containing `n` integers, find the beauty of each
subarray of size `k`.

The beauty of a subarray is the `xth` smallest integer in the subarray if it
is negative, or `0` if there are fewer than `x` negative integers.

Return an integer array containing `n - k + 1` integers, which denote the
beauty of the subarrays in order from the first index in the array.

* A subarray is a contiguous non-empty sequence of elements within an array.

","def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:
    ans = []
    count = [0] * 50

    for i, num in enumerate(nums):
      if num < 0:
        count[num + 50] += 1
      if i - k >= 0 and nums[i - k] < 0:
        count[nums[i - k] + 50] -= 1
      if i + 1 >= k:
        ans.append(self._getXthSmallestNum(count, x))

    return ans

  def _getXthSmallestNum(self, count: List[int], x: int) -> int:
    prefix = 0
    for i in range(50):
      prefix += count[i]
      if prefix >= x:
        return i - 50
    return 0
"
854,"Strings `s1` and `s2` are `k`-similar (for some non-negative integer `k`) if
we can swap the positions of two letters in `s1` exactly `k` times so that the
resulting string equals `s2`.

Given two anagrams `s1` and `s2`, return the smallest `k` for which `s1` and
`s2` are `k`-similar.

","def kSimilarity(self, s1: str, s2: str) -> int:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def kSimilarity(self, s1: str, s2: str) -> int:
    ans = 0
    q = collections.deque([s1])
    seen = {s1}

    while q:
      for _ in range(len(q)):
        curr = q.popleft()
        if curr == s2:
          return ans
        for child in self._getChildren(curr, s2):
          if child in seen:
            continue
          q.append(child)
          seen.add(child)
      ans += 1

    return -1

  def _getChildren(self, curr: str, target: str) -> List[str]:
    children = []
    s = list(curr)
    i = 0
    while curr[i] == target[i]:
      i += 1

    for j in range(i + 1, len(s)):
      if s[j] == target[i]:
        s[i], s[j] = s[j], s[i]
        children.append(''.join(s))
        s[i], s[j] = s[j], s[i]

    return children
"
688,"On an `n x n` chessboard, a knight starts at the cell `(row, column)` and
attempts to make exactly `k` moves. The rows and columns are 0-indexed, so the
top-left cell is `(0, 0)`, and the bottom-right cell is `(n - 1, n - 1)`.

A chess knight has eight possible moves it can make, as illustrated below.
Each move is two cells in a cardinal direction, then one cell in an orthogonal
direction.

Each time the knight is to move, it chooses one of eight possible moves
uniformly at random (even if the piece would go off the chessboard) and moves
there.

The knight continues moving until it has made exactly `k` moves or has moved
off the chessboard.

Return the probability that the knight remains on the board after it has
stopped moving.

","def knightProbability(self, n: int, k: int, row: int, column: int) -> float:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def knightProbability(self, n: int, k: int, row: int, column: int) -> float:
    dirs = ((1, 2), (2, 1), (2, -1), (1, -2), (-1, -2), (-2, -1), (-2, 1), (-1, 2))
    dp = [[0] * n for _ in range(n)]
    dp[row][column] = 1.0

    for _ in range(k):
      newDp = [[0] * n for _ in range(n)]
      for i in range(n):
        for j in range(n):
          for dx, dy in dirs:
            x = i + dx
            y = j + dy
            if 0 <= x < n and 0 <= y < n:
              newDp[i][j] += dp[x][y]
      dp = newDp

    return sum(map(sum, dp)) / 8**k
"
547,"There are `n` cities. Some of them are connected, while some are not. If city
`a` is connected directly with city `b`, and city `b` is connected directly
with city `c`, then city `a` is connected indirectly with city `c`.

A province is a group of directly or indirectly connected cities and no other
cities outside of the group.

You are given an `n x n` matrix `isConnected` where `isConnected[i][j] = 1` if
the `ith` city and the `jth` city are directly connected, and
`isConnected[i][j] = 0` otherwise.

Return the total number of provinces.

","def __init__(self, n: int):","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class UnionFind:
  def __init__(self, n: int):
    self.count = n
    self.id = list(range(n))
    self.rank = [0] * n

  def unionByRank(self, u: int, v: int) -> None:
    i = self._find(u)
    j = self._find(v)
    if i == j:
      return
    if self.rank[i] < self.rank[j]:
      self.id[i] = j
    elif self.rank[i] > self.rank[j]:
      self.id[j] = i
    else:
      self.id[i] = j
      self.rank[j] += 1
    self.count -= 1

  def _find(self, u: int) -> int:
    if self.id[u] != u:
      self.id[u] = self._find(self.id[u])
    return self.id[u]


class Solution:
  def findCircleNum(self, isConnected: List[List[int]]) -> int:
    n = len(isConnected)
    uf = UnionFind(n)

    for i in range(n):
      for j in range(i, n):
        if isConnected[i][j] == 1:
          uf.unionByRank(i, j)

    return uf.count
"
1202,"You are given a string `s`, and an array of pairs of indices in the string
`pairs` where `pairs[i] = [a, b]` indicates 2 indices(0-indexed) of the
string.

You can swap the characters at any pair of indices in the given `pairs` any
number of times.

Return the lexicographically smallest string that `s` can be changed to after
using the swaps.

","def __init__(self, n: int):","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class UnionFind:
  def __init__(self, n: int):
    self.id = list(range(n))
    self.rank = [0] * n

  def unionByRank(self, u: int, v: int) -> None:
    i = self.find(u)
    j = self.find(v)
    if i == j:
      return
    if self.rank[i] < self.rank[j]:
      self.id[i] = j
    elif self.rank[i] > self.rank[j]:
      self.id[j] = i
    else:
      self.id[i] = j
      self.rank[j] += 1

  def find(self, u: int) -> int:
    if self.id[u] != u:
      self.id[u] = self.find(self.id[u])
    return self.id[u]


class Solution:
  def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:
    ans = ''
    uf = UnionFind(len(s))
    map = collections.defaultdict(list)

    for a, b in pairs:
      uf.unionByRank(a, b)

    for i, c in enumerate(s):
      map[uf.find(i)].append(c)

    for key in map.keys():
      map[key].sort(reverse=True)

    for i in range(len(s)):
      ans += map[uf.find(i)].pop()

    return ans
"
963,"You are given an array of points in the X-Y plane `points` where `points[i] =
[xi, yi]`.

Return the minimum area of any rectangle formed from these points, with sides
not necessarily parallel to the X and Y axes. If there is not any such
rectangle, return `0`.

Answers within `10-5` of the actual answer will be accepted.

","def minAreaFreeRect(self, points: List[List[int]]) -> float:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator
from math import sqrt

class Solution:
  def minAreaFreeRect(self, points: List[List[int]]) -> float:
    ans = math.inf
    centerToPoints = collections.defaultdict(list)

    for ax, ay in points:
      for bx, by in points:
        center = ((ax + bx) / 2, (ay + by) / 2)
        centerToPoints[center].append((ax, ay, bx, by))

    def dist(px: int, py: int, qx: int, qy: int) -> float:
      return (px - qx)**2 + (py - qy)**2

    for points in centerToPoints.values():
      for ax, ay, _, _ in points:
        for cx, cy, dx, dy in points:
          if (cx - ax) * (dx - ax) + (cy - ay) * (dy - ay) == 0:
            squaredArea = dist(ax, ay, cx, cy) * dist(ax, ay, dx, dy)
            if squaredArea > 0:
              ans = min(ans, squaredArea)

    return 0 if ans == math.inf else sqrt(ans)
"
2245,"You are given a 2D integer array `grid` of size `m x n`, where each cell
contains a positive integer.

A cornered path is defined as a set of adjacent cells with at most one turn.
More specifically, the path should exclusively move either horizontally or
vertically up to the turn (if there is one), without returning to a previously
visited cell. After the turn, the path will then move exclusively in the
alternate direction: move vertically if it moved horizontally, and vice versa,
also without returning to a previously visited cell.

The product of a path is defined as the product of all the values in the path.

Return the maximum number of trailing zeros in the product of a cornered path
found in `grid`.

Note:

* Horizontal movement means moving in either the left or right direction.
* Vertical movement means moving in either the up or down direction.

","def maxTrailingZeros(self, grid: List[List[int]]) -> int:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def maxTrailingZeros(self, grid: List[List[int]]) -> int:
    m = len(grid)
    n = len(grid[0])
    leftPrefix2 = [[0] * n for _ in range(m)]
    leftPrefix5 = [[0] * n for _ in range(m)]
    topPrefix2 = [[0] * n for _ in range(m)]
    topPrefix5 = [[0] * n for _ in range(m)]

    def getCount(num: int, factor: int) -> int:
      count = 0
      while num % factor == 0:
        num //= factor
        count += 1
      return count

    for i in range(m):
      for j in range(n):
        leftPrefix2[i][j] = getCount(grid[i][j], 2)
        leftPrefix5[i][j] = getCount(grid[i][j], 5)
        if j:
          leftPrefix2[i][j] += leftPrefix2[i][j - 1]
          leftPrefix5[i][j] += leftPrefix5[i][j - 1]

    for j in range(n):
      for i in range(m):
        topPrefix2[i][j] = getCount(grid[i][j], 2)
        topPrefix5[i][j] = getCount(grid[i][j], 5)
        if i:
          topPrefix2[i][j] += topPrefix2[i - 1][j]
          topPrefix5[i][j] += topPrefix5[i - 1][j]

    ans = 0
    for i in range(m):
      for j in range(n):
        curr2 = getCount(grid[i][j], 2)
        curr5 = getCount(grid[i][j], 5)
        l2 = leftPrefix2[i][j]
        l5 = leftPrefix5[i][j]
        r2 = leftPrefix2[i][n - 1] - (0 if j == 0 else leftPrefix2[i][j - 1])
        r5 = leftPrefix5[i][n - 1] - (0 if j == 0 else leftPrefix5[i][j - 1])
        t2 = topPrefix2[i][j]
        t5 = topPrefix5[i][j]
        d2 = topPrefix2[m - 1][j] - (0 if i == 0 else topPrefix2[i - 1][j])
        d5 = topPrefix5[m - 1][j] - (0 if i == 0 else topPrefix5[i - 1][j])
        ans = max(ans, min(l2 + t2 - curr2, l5 + t5 - curr5), min(r2 + t2 - curr2, r5 + t5 - curr5), min(l2 + d2 - curr2, l5 + d5 - curr5), min(r2 + d2 - curr2, r5 + d5 - curr5))

    return ans
"
2157,"You are given a 0-indexed array of strings `words`. Each string consists of
lowercase English letters only. No letter occurs more than once in any string
of `words`.

Two strings `s1` and `s2` are said to be connected if the set of letters of
`s2` can be obtained from the set of letters of `s1` by any one of the
following operations:

* Adding exactly one letter to the set of the letters of `s1`.
* Deleting exactly one letter from the set of the letters of `s1`.
* Replacing exactly one letter from the set of the letters of `s1` with any letter, including itself.

The array `words` can be divided into one or more non-intersecting groups. A
string belongs to a group if any one of the following is true:

* It is connected to at least one other string of the group.
* It is the only string present in the group.

Note that the strings in `words` should be grouped in such a manner that a
string belonging to a group cannot be connected to a string present in any
other group. It can be proved that such an arrangement is always unique.

Return an array `ans` of size `2` where:

* `ans[0]` is the maximum number of groups `words` can be divided into, and
* `ans[1]` is the size of the largest group.

","def __init__(self, n: int):","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class UnionFind:
  def __init__(self, n: int):
    self.count = n
    self.id = list(range(n))
    self.sz = [1] * n

  def unionBySize(self, u: int, v: int) -> None:
    i = self._find(u)
    j = self._find(v)
    if i == j:
      return
    if self.sz[i] < self.sz[j]:
      self.sz[j] += self.sz[i]
      self.id[i] = j
    else:
      self.sz[i] += self.sz[j]
      self.id[j] = i
    self.count -= 1

  def _find(self, u: int) -> int:
    if self.id[u] != u:
      self.id[u] = self._find(self.id[u])
    return self.id[u]


class Solution:
  def groupStrings(self, words: List[str]) -> List[int]:
    uf = UnionFind(len(words))

    def getMask(s: str) -> int:
      mask = 0
      for c in s:
        mask |= 1 << ord(c) - ord('a')
      return mask

    def getAddedMasks(mask: int):
      for i in range(26):
        if not (mask >> i & 1):
          yield mask | 1 << i

    def getDeletedMasks(mask: int):
      for i in range(26):
        if mask >> i & 1:
          yield mask ^ 1 << i

    maskToIndex = {getMask(word): i for i, word in enumerate(words)}
    deletedMaskToIndex = {}

    for i, word in enumerate(words):
      mask = getMask(word)
      for m in getAddedMasks(mask):
        if m in maskToIndex:
          uf.unionBySize(i, maskToIndex[m])
      for m in getDeletedMasks(mask):
        if m in maskToIndex:
          uf.unionBySize(i, maskToIndex[m])
        if m in deletedMaskToIndex:
          uf.unionBySize(i, deletedMaskToIndex[m])
        else:
          deletedMaskToIndex[m] = i

    return [uf.count, max(uf.sz)]
"
2456,"You are given two string arrays `creators` and `ids`, and an integer array
`views`, all of length `n`. The `ith` video on a platform was created by
`creator[i]`, has an id of `ids[i]`, and has `views[i]` views.

The popularity of a creator is the sum of the number of views on all of the
creator's videos. Find the creator with the highest popularity and the id of
their most viewed video.

* If multiple creators have the highest popularity, find all of them.
* If multiple videos have the highest view count for a creator, find the lexicographically smallest id.

Return a 2D array of strings `answer` where `answer[i] = [creatori, idi]`
means that `creatori` has the highest popularity and `idi` is the id of their
most popular video. The answer can be returned in any order.

","def __init__(self, popularity: int, videoId: str, maxView: int):","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Creator:
  def __init__(self, popularity: int, videoId: str, maxView: int):
    self.popularity = popularity
    self.videoId = videoId
    self.maxView = maxView


class Solution:
  def mostPopularCreator(self, creators: List[str], ids: List[str], views: List[int]) -> List[List[str]]:
    ans = []
    maxPopularity = 0
    nameToCreator = {}

    for name, id, view in zip(creators, ids, views):
      if name not in nameToCreator:
        nameToCreator[name] = Creator(view, id, view)
        maxPopularity = max(maxPopularity, view)
        continue
      creator = nameToCreator[name]
      creator.popularity += view
      maxPopularity = max(maxPopularity, creator.popularity)
      if creator.maxView < view or creator.maxView == view and creator.videoId > id:
        creator.videoId = id
        creator.maxView = view

    for name, creator in nameToCreator.items():
      if creator.popularity == maxPopularity:
        ans.append([name, creator.videoId])

    return ans
"
2182,"You are given a string `s` and an integer `repeatLimit`. Construct a new
string `repeatLimitedString` using the characters of `s` such that no letter
appears more than `repeatLimit` times in a row. You do not have to use all
characters from `s`.

Return the lexicographically largest `repeatLimitedString` possible.

A string `a` is lexicographically larger than a string `b` if in the first
position where `a` and `b` differ, string `a` has a letter that appears later
in the alphabet than the corresponding letter in `b`. If the first
`min(a.length, b.length)` characters do not differ, then the longer string is
the lexicographically larger one.

","def repeatLimitedString(self, s: str, repeatLimit: int) -> str:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def repeatLimitedString(self, s: str, repeatLimit: int) -> str:
    ans = ''
    count = collections.Counter(s)

    while True:
      addOne = ans and self._shouldAddOne(ans, count)
      c = self._getLargestChar(ans, count)
      if c == ' ':
        break
      repeats = 1 if addOne else min(count[c], repeatLimit)
      ans += c * repeats
      count[c] -= repeats

    return ans

  def _shouldAddOne(self, ans: str, count: collections.Counter) -> bool:
    for c in reversed(string.ascii_lowercase):
      if count[c]:
        return ans[-1] == c
    return False

  def _getLargestChar(self, ans: str, count: collections.Counter) -> int:
    for c in reversed(string.ascii_lowercase):
      if count[c] and (not ans or ans[-1] != c):
        return c
    return ' '
"
2203,"You are given an integer `n` denoting the number of nodes of a weighted
directed graph. The nodes are numbered from `0` to `n - 1`.

You are also given a 2D integer array `edges` where `edges[i] = [fromi, toi,
weighti]` denotes that there exists a directed edge from `fromi` to `toi` with
weight `weighti`.

Lastly, you are given three distinct integers `src1`, `src2`, and `dest`
denoting three distinct nodes of the graph.

Return the minimum weight of a subgraph of the graph such that it is possible
to reach `dest` from both `src1` and `src2` via a set of edges of this
subgraph. In case such a subgraph does not exist, return `-1`.

A subgraph is a graph whose vertices and edges are subsets of the original
graph. The weight of a subgraph is the sum of weights of its constituent
edges.

","def minimumWeight(self, n: int, edges: List[List[int]], src1: int, src2: int, dest: int) -> int:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def minimumWeight(self, n: int, edges: List[List[int]], src1: int, src2: int, dest: int) -> int:
    graph = [[] for _ in range(n)]
    reversedGraph = [[] for _ in range(n)]

    for u, v, w in edges:
      graph[u].append((v, w))
      reversedGraph[v].append((u, w))

    fromSrc1 = self._dijkstra(graph, src1)
    fromSrc2 = self._dijkstra(graph, src2)
    fromDest = self._dijkstra(reversedGraph, dest)
    minWeight = min(a + b + c for a, b, c in zip(fromSrc1, fromSrc2, fromDest))
    if minWeight == math.inf:
      return -1
    else:
      return minWeight

  def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int) -> List[int]:
    dist = [math.inf] * len(graph)

    dist[src] = 0
    minHeap = [(dist[src], src)]

    while minHeap:
      d, u = heapq.heappop(minHeap)
      if d > dist[u]:
        continue
      for v, w in graph[u]:
        if d + w < dist[v]:
          dist[v] = d + w
          heapq.heappush(minHeap, (dist[v], v))

    return dist
"
2242,"There is an undirected graph with `n` nodes, numbered from `0` to `n - 1`.

You are given a 0-indexed integer array `scores` of length `n` where
`scores[i]` denotes the score of node `i`. You are also given a 2D integer
array `edges` where `edges[i] = [ai, bi]` denotes that there exists an
undirected edge connecting nodes `ai` and `bi`.

A node sequence is valid if it meets the following conditions:

* There is an edge connecting every pair of adjacent nodes in the sequence.
* No node appears more than once in the sequence.

The score of a node sequence is defined as the sum of the scores of the nodes
in the sequence.

Return the maximum score of a valid node sequence with a length of `4`. If no
such sequence exists, return `-1`.

","def maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:
    n = len(scores)
    ans = -1
    graph = [[] for _ in range(n)]

    for u, v in edges:
      graph[u].append((scores[v], v))
      graph[v].append((scores[u], u))

    for i in range(n):
      graph[i] = heapq.nlargest(3, graph[i])

    for u, v in edges:
      for scoreA, a in graph[u]:
        for scoreB, b in graph[v]:
          if a != b and a != v and b != u:
            ans = max(ans, scoreA + scores[u] + scores[v] + scoreB)

    return ans
"
2437,"You are given a string of length `5` called `time`, representing the current
time on a digital clock in the format `""hh:mm""`. The earliest possible time is
`""00:00""` and the latest possible time is `""23:59""`.

In the string `time`, the digits represented by the `?` symbol are unknown,
and must be replaced with a digit from `0` to `9`.

Return an integer `answer`, the number of valid clock times that can be
created by replacing every `?` with a digit from `0` to `9`.

","def countTime(self, time: str) -> int:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def countTime(self, time: str) -> int:
    ans = 1
    if time[3] == '?':
      ans *= 6
    if time[4] == '?':
      ans *= 10

    if time[0] == '?' and time[1] == '?':
      return ans * 24
    if time[0] == '?':
      if time[1] < '4':
        return ans * 3
      else:
        return ans * 2
    if time[1] == '?':
      if time[0] == '2':
        return ans * 4
      else:
        return ans * 10
    return ans
"
2332,"You are given a 0-indexed integer array `buses` of length `n`, where
`buses[i]` represents the departure time of the `ith` bus. You are also given
a 0-indexed integer array `passengers` of length `m`, where `passengers[j]`
represents the arrival time of the `jth` passenger. All bus departure times
are unique. All passenger arrival times are unique.

You are given an integer `capacity`, which represents the maximum number of
passengers that can get on each bus.

When a passenger arrives, they will wait in line for the next available bus.
You can get on a bus that departs at `x` minutes if you arrive at `y` minutes
where `y <= x`, and the bus is not full. Passengers with the earliest arrival
times get on the bus first.

More formally when a bus arrives, either:

* If `capacity` or fewer passengers are waiting for a bus, they will all get on the bus, or
* The `capacity` passengers with the earliest arrival times will get on the bus.

Return the latest time you may arrive at the bus station to catch a bus. You
cannot arrive at the same time as another passenger.

Note: The arrays `buses` and `passengers` are not necessarily sorted.

","def latestTimeCatchTheBus(self, buses: List[int], passengers: List[int], capacity: int) -> int:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def latestTimeCatchTheBus(self, buses: List[int], passengers: List[int], capacity: int) -> int:
    buses.sort()
    passengers.sort()

    if passengers[0] > buses[-1]:
      return buses[-1]

    ans = passengers[0] - 1
    i = 0
    j = 0
    while i < len(buses):
      arrived = 0
      while arrived < capacity and j < len(passengers) and passengers[j] <= buses[i]:
        if j > 0 and passengers[j] != passengers[j - 1] + 1:
          ans = passengers[j] - 1
        j += 1
        arrived += 1

      if arrived < capacity and j > 0 and passengers[j - 1] != buses[i]:
        ans = buses[i]
      i += 1

    return ans
"
2322,"There is an undirected connected tree with `n` nodes labeled from `0` to `n -
1` and `n - 1` edges.

You are given a 0-indexed integer array `nums` of length `n` where `nums[i]`
represents the value of the `ith` node. You are also given a 2D integer array
`edges` of length `n - 1` where `edges[i] = [ai, bi]` indicates that there is
an edge between nodes `ai` and `bi` in the tree.

Remove two distinct edges of the tree to form three connected components. For
a pair of removed edges, the following steps are defined:

1. Get the XOR of all the values of the nodes for each of the three components respectively.
2. The difference between the largest XOR value and the smallest XOR value is the score of the pair.

* For example, say the three components have the node values: `[4,5,7]`, `[1,9]`, and `[3,3,3]`. The three XOR values are `4 ^ 5 ^ 7 = 6`, `1 ^ 9 = 8`, and `3 ^ 3 ^ 3 = 3`. The largest XOR value is `8` and the smallest XOR value is `3`. The score is then `8 - 3 = 5`.

Return the minimum score of any possible pair of edge removals on the given
tree.

","def minimumScore(self, nums: List[int], edges: List[List[int]]) -> int:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator, Set

class Solution:
  def minimumScore(self, nums: List[int], edges: List[List[int]]) -> int:
    n = len(nums)
    xors = functools.reduce(lambda x, y: x ^ y, nums)
    subXors = nums[:]
    tree = [[] for _ in range(n)]
    children = [{i} for i in range(n)]

    for u, v in edges:
      tree[u].append(v)
      tree[v].append(u)

    def dfs(u: int, parent: int) -> Tuple[int, Set[int]]:
      for v in tree[u]:
        if v == parent:
          continue
        vXor, vChildren = dfs(v, u)
        subXors[u] ^= vXor
        children[u] |= vChildren
      return subXors[u], children[u]

    dfs(0, -1)

    ans = math.inf
    for i in range(len(edges)):
      a, b = edges[i]
      if b in children[a]:
        a, b = b, a
      for j in range(i):
        c, d = edges[j]
        if d in children[c]:
          c, d = d, c

        if c in children[a] and a != c:
          cands = [subXors[c], subXors[a] ^ subXors[c], xors ^ subXors[a]]
        elif a in children[c] and a != c:
          cands = [subXors[a], subXors[c] ^ subXors[a], xors ^ subXors[c]]
        else:
          cands = [subXors[a], subXors[c], xors ^ subXors[a] ^ subXors[c]]
        ans = min(ans, max(cands) - min(cands))

    return ans
"
2258,"You are given a 0-indexed 2D integer array `grid` of size `m x n` which
represents a field. Each cell has one of three values:

* `0` represents grass,
* `1` represents fire,
* `2` represents a wall that you and fire cannot pass through.

You are situated in the top-left cell, `(0, 0)`, and you want to travel to the
safehouse at the bottom-right cell, `(m - 1, n - 1)`. Every minute, you may
move to an adjacent grass cell. After your move, every fire cell will spread
to all adjacent cells that are not walls.

Return the maximum number of minutes that you can stay in your initial
position before moving while still safely reaching the safehouse. If this is
impossible, return `-1`. If you can always reach the safehouse regardless of
the minutes stayed, return `109`.

Note that even if the fire spreads to the safehouse immediately after you have
reached it, it will be counted as safely reaching the safehouse.

A cell is adjacent to another cell if the former is directly north, east,
south, or west of the latter (i.e., their sides are touching).

","def maximumMinutes(self, grid: List[List[int]]) -> int:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def maximumMinutes(self, grid: List[List[int]]) -> int:
    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))
    kMax = len(grid) * len(grid[0])
    fireGrid = [[-1] * len(grid[0]) for _ in range(len(grid))]
    self._buildFireGrid(grid, fireGrid, dirs)

    ans = -1
    l = 0
    r = kMax

    while l <= r:
      m = (l + r) // 2
      if self._canStayFor(grid, fireGrid, m, dirs):
        ans = m
        l = m + 1
      else:
        r = m - 1

    return int(1e9) if ans == kMax else ans

  def _buildFireGrid(self, grid: List[List[int]], fireMinute: List[List[int]], dirs: List[int]) -> None:
    minuteFromFire = 0
    q = collections.deque()

    for i in range(len(grid)):
      for j in range(len(grid[0])):
        if grid[i][j] == 1:
          q.append((i, j))
          fireMinute[i][j] = 0
    while q:
      minuteFromFire += 1
      for _ in range(len(q)):
        i, j = q.popleft()
        for dx, dy in dirs:
          x = i + dx
          y = j + dy
          if x < 0 or x == len(grid) or y < 0 or y == len(grid[0]):
            continue
          if grid[x][y] == 2:
            continue
          if fireMinute[x][y] != -1:
            continue
          fireMinute[x][y] = minuteFromFire
          q.append((x, y))

  def _canStayFor(self, grid: List[List[int]], fireMinute: List[List[int]], minute: int, dirs: List[int]) -> bool:
    q = collections.deque([(0, 0)])
    seen = {(0, 0)}

    while q:
      minute += 1
      for _ in range(len(q)):
        i, j = q.popleft()
        for dx, dy in dirs:
          x = i + dx
          y = j + dy
          if x < 0 or x == len(grid) or y < 0 or y == len(grid[0]):
            continue
          if grid[x][y] == 2:
            continue
          if x == len(grid) - 1 and y == len(grid[0]) - 1:
            if fireMinute[x][y] != -1 and fireMinute[x][y] < minute:
              continue
            return True
          if fireMinute[x][y] != -1 and fireMinute[x][y] <= minute:
            continue
          if (x, y) in seen:
            continue
          q.append((x, y))
          seen.add((x, y))

    return False
"
2290,"You are given a 0-indexed 2D integer array `grid` of size `m x n`. Each cell
has one of two values:

* `0` represents an empty cell,
* `1` represents an obstacle that may be removed.

You can move up, down, left, or right from and to an empty cell.

Return the minimum number of obstacles to remove so you can move from the
upper left corner `(0, 0)` to the lower right corner `(m - 1, n - 1)`.

","def minimumObstacles(self, grid: List[List[int]]) -> int:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def minimumObstacles(self, grid: List[List[int]]) -> int:
    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))
    m = len(grid)
    n = len(grid[0])
    minHeap = [(grid[0][0], 0, 0)]  # (d, i, j)
    dist = [[math.inf] * n for _ in range(m)]
    dist[0][0] = grid[0][0]

    while minHeap:
      d, i, j = heapq.heappop(minHeap)
      if i == m - 1 and j == n - 1:
        return d
      for dx, dy in dirs:
        x = i + dx
        y = j + dy
        if x < 0 or x == m or y < 0 or y == n:
          continue
        newDist = d + grid[i][j]
        if newDist < dist[x][y]:
          dist[x][y] = newDist
          heapq.heappush(minHeap, (newDist, x, y))

    return dist[m - 1][n - 1]
"
2299,"A password is said to be strong if it satisfies all the following criteria:

* It has at least `8` characters.
* It contains at least one lowercase letter.
* It contains at least one uppercase letter.
* It contains at least one digit.
* It contains at least one special character. The special characters are the characters in the following string: `""!@#$%^&*()-+""`.
* It does not contain `2` of the same character in adjacent positions (i.e., `""aab""` violates this condition, but `""aba""` does not).

Given a string `password`, return `true` if it is a strong password.
Otherwise, return `false`.

","def strongPasswordCheckerII(self, password: str) -> bool:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def strongPasswordCheckerII(self, password: str) -> bool:
    if len(password) < 8:
      return False
    if not any(c.islower() for c in password):
      return False
    if not any(c.isupper() for c in password):
      return False
    if not any(c.isdigit() for c in password):
      return False
    if not any(""!@#$%^&*()-+"".find(c) != -1 for c in password):
      return False
    return all(a != b for a, b in zip(password, password[1:]))
"
2392,"You are given a positive integer `k`. You are also given:

* a 2D integer array `rowConditions` of size `n` where `rowConditions[i] = [abovei, belowi]`, and
* a 2D integer array `colConditions` of size `m` where `colConditions[i] = [lefti, righti]`.

The two arrays contain integers from `1` to `k`.

You have to build a `k x k` matrix that contains each of the numbers from `1`
to `k` exactly once. The remaining cells should have the value `0`.

The matrix should also satisfy the following conditions:

* The number `abovei` should appear in a row that is strictly above the row at which the number `belowi` appears for all `i` from `0` to `n - 1`.
* The number `lefti` should appear in a column that is strictly left of the column at which the number `righti` appears for all `i` from `0` to `m - 1`.

Return any matrix that satisfies the conditions. If no answer exists, return
an empty matrix.

","def buildMatrix(self, k: int, rowConditions: List[List[int]], colConditions: List[List[int]]) -> List[List[int]]:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def buildMatrix(self, k: int, rowConditions: List[List[int]], colConditions: List[List[int]]) -> List[List[int]]:
    rowOrder = self._topologicalSort(rowConditions, k)
    if not rowOrder:
      return []

    colOrder = self._topologicalSort(colConditions, k)
    if not colOrder:
      return []

    ans = [[0] * k for _ in range(k)]
    nodeToRowIndex = [0] * (k + 1)

    for i, node in enumerate(rowOrder):
      nodeToRowIndex[node] = i

    for j, node in enumerate(colOrder):
      i = nodeToRowIndex[node]
      ans[i][j] = node

    return ans

  def _topologicalSort(self, conditions: List[List[int]], n: int) -> List[int]:
    order = []
    graph = [[] for _ in range(n + 1)]
    inDegrees = [0] * (n + 1)

    for u, v in conditions:
      graph[u].append(v)
      inDegrees[v] += 1

    q = collections.deque([i for i in range(1, n + 1) if inDegrees[i] == 0])

    while q:
      u = q.popleft()
      order.append(u)
      for v in graph[u]:
        inDegrees[v] -= 1
        if inDegrees[v] == 0:
          q.append(v)

    if len(order) == n:
      return order
    else:
      return []
"
2301,"You are given two strings `s` and `sub`. You are also given a 2D character
array `mappings` where `mappings[i] = [oldi, newi]` indicates that you may
perform the following operation any number of times:

* Replace a character `oldi` of `sub` with `newi`.

Each character in `sub` cannot be replaced more than once.

Return `true` if it is possible to make `sub` a substring of `s` by replacing
zero or more characters according to `mappings`. Otherwise, return `false`.

A substring is a contiguous non-empty sequence of characters within a string.

","def matchReplacement(self, s: str, sub: str, mappings: List[List[str]]) -> bool:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def matchReplacement(self, s: str, sub: str, mappings: List[List[str]]) -> bool:
    isMapped = [[False] * 128 for _ in range(128)]

    for old, new in mappings:
      isMapped[ord(old)][ord(new)] = True

    for i in range(len(s)):
      if self._canTransform(s, i, sub, isMapped):
        return True

    return False

  def _canTransform(self, s: str, start: int, sub: str, isMapped: List[List[bool]]) -> bool:
    if start + len(sub) > len(s):
      return False

    for i in range(len(sub)):
      a = sub[i]
      b = s[start + i]
      if a != b and not isMapped[ord(a)][ord(b)]:
        return False

    return True
"
2337,"You are given two strings `start` and `target`, both of length `n`. Each
string consists only of the characters `'L'`, `'R'`, and `'_'` where:

* The characters `'L'` and `'R'` represent pieces, where a piece `'L'` can move to the left only if there is a blank space directly to its left, and a piece `'R'` can move to the right only if there is a blank space directly to its right.
* The character `'_'` represents a blank space that can be occupied by any of the `'L'` or `'R'` pieces.

Return `true` if it is possible to obtain the string `target` by moving the
pieces of the string `start` any number of times. Otherwise, return `false`.

","def canChange(self, start: str, target: str) -> bool:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def canChange(self, start: str, target: str) -> bool:
    n = len(start)
    i = 0
    j = 0

    while i <= n and j <= n:
      while i < n and start[i] == '_':
        i += 1
      while j < n and target[j] == '_':
        j += 1
      if i == n or j == n:
        return i == n and j == n
      if start[i] != target[j]:
        return False
      if start[i] == 'R' and i > j:
        return False
      if start[i] == 'L' and i < j:
        return False
      i += 1
      j += 1

    return True
"
2257,"You are given two integers `m` and `n` representing a 0-indexed `m x n` grid.
You are also given two 2D integer arrays `guards` and `walls` where `guards[i]
= [rowi, coli]` and `walls[j] = [rowj, colj]` represent the positions of the
`ith` guard and `jth` wall respectively.

A guard can see every cell in the four cardinal directions (north, east,
south, or west) starting from their position unless obstructed by a wall or
another guard. A cell is guarded if there is at least one guard that can see
it.

Return the number of unoccupied cells that are not guarded.

","def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:
    ans = 0
    grid = [[0] * n for _ in range(m)]
    left = [[0] * n for _ in range(m)]
    right = [[0] * n for _ in range(m)]
    up = [[0] * n for _ in range(m)]
    down = [[0] * n for _ in range(m)]

    for row, col in guards:
      grid[row][col] = 'G'

    for row, col in walls:
      grid[row][col] = 'W'

    for i in range(m):
      lastCell = 0
      for j in range(n):
        if grid[i][j] == 'G' or grid[i][j] == 'W':
          lastCell = grid[i][j]
        else:
          left[i][j] = lastCell
      lastCell = 0
      for j in range(n - 1, -1, -1):
        if grid[i][j] == 'G' or grid[i][j] == 'W':
          lastCell = grid[i][j]
        else:
          right[i][j] = lastCell

    for j in range(n):
      lastCell = 0
      for i in range(m):
        if grid[i][j] == 'G' or grid[i][j] == 'W':
          lastCell = grid[i][j]
        else:
          up[i][j] = lastCell
      lastCell = 0
      for i in range(m - 1, -1, -1):
        if grid[i][j] == 'G' or grid[i][j] == 'W':
          lastCell = grid[i][j]
        else:
          down[i][j] = lastCell

    for i in range(m):
      for j in range(n):
        if grid[i][j] == 0 and left[i][j] != 'G' and right[i][j] != 'G' and up[i][j] != 'G' and down[i][j] != 'G':
          ans += 1

    return ans
"
4,"Given two sorted arrays `nums1` and `nums2` of size `m` and `n` respectively,
return the median of the two sorted arrays.

The overall run time complexity should be `O(log (m+n))`.

","def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
    n1 = len(nums1)
    n2 = len(nums2)
    if n1 > n2:
      return self.findMedianSortedArrays(nums2, nums1)

    l = 0
    r = n1

    while l <= r:
      partition1 = (l + r) // 2
      partition2 = (n1 + n2 + 1) // 2 - partition1
      maxLeft1 = -2**31 if partition1 == 0 else nums1[partition1 - 1]
      maxLeft2 = -2**31 if partition2 == 0 else nums2[partition2 - 1]
      minRight1 = 2**31 - 1 if partition1 == n1 else nums1[partition1]
      minRight2 = 2**31 - 1 if partition2 == n2 else nums2[partition2]
      if maxLeft1 <= minRight2 and maxLeft2 <= minRight1:
        if (n1 + n2) % 2 == 0:
          return (max(maxLeft1, maxLeft2) + min(minRight1, minRight2)) * 0.5
        else:
          return max(maxLeft1, maxLeft2)
      elif maxLeft1 > minRight2:
        r = partition1 - 1
      else:
        l = partition1 + 1
"
2146,"You are given a 0-indexed 2D integer array `grid` of size `m x n` that
represents a map of the items in a shop. The integers in the grid represent
the following:

* `0` represents a wall that you cannot pass through.
* `1` represents an empty cell that you can freely move to and from.
* All other positive integers represent the price of an item in that cell. You may also freely move to and from these item cells.

It takes `1` step to travel between adjacent grid cells.

You are also given integer arrays `pricing` and `start` where `pricing = [low,
high]` and `start = [row, col]` indicates that you start at the position
`(row, col)` and are interested only in items with a price in the range of
`[low, high]` (inclusive). You are further given an integer `k`.

You are interested in the positions of the `k` highest-ranked items whose
prices are within the given price range. The rank is determined by the first
of these criteria that is different:

1. Distance, defined as the length of the shortest path from the `start` (shorter distance has a higher rank).
2. Price (lower price has a higher rank, but it must be in the price range).
3. The row number (smaller row number has a higher rank).
4. The column number (smaller column number has a higher rank).

Return the `k` highest-ranked items within the price range sorted by their
rank (highest to lowest). If there are fewer than `k` reachable items within
the price range, return all of them.

","def highestRankedKItems(self, grid: List[List[int]], pricing: List[int], start: List[int], k: int) -> List[List[int]]:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def highestRankedKItems(self, grid: List[List[int]], pricing: List[int], start: List[int], k: int) -> List[List[int]]:
    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))
    m = len(grid)
    n = len(grid[0])
    low, high = pricing
    row, col = start
    ans = []

    if low <= grid[row][col] <= high:
      ans.append([row, col])
      if k == 1:
        return ans

    q = collections.deque([(row, col)])
    seen = {(row, col)}

    while q:
      neighbors = []
      for _ in range(len(q)):
        i, j = q.popleft()
        for t in range(4):
          x = i + dirs[t][0]
          y = j + dirs[t][1]
          if x < 0 or x == m or y < 0 or y == n:
            continue
          if not grid[x][y] or (x, y) in seen:
            continue
          if low <= grid[x][y] <= high:
            neighbors.append([x, y])
          q.append((x, y))
          seen.add((x, y))
      neighbors.sort(key=lambda x: (grid[x[0]][x[1]], x[0], x[1]))
      for neighbor in neighbors:
        if len(ans) < k:
          ans.append(neighbor)
        if len(ans) == k:
          return ans

    return ans
"
2132,"You are given an `m x n` binary matrix `grid` where each cell is either `0`
(empty) or `1` (occupied).

You are then given stamps of size `stampHeight x stampWidth`. We want to fit
the stamps such that they follow the given restrictions and requirements:

1. Cover all the empty cells.
2. Do not cover any of the occupied cells.
3. We can put as many stamps as we want.
4. Stamps can overlap with each other.
5. Stamps are not allowed to be rotated.
6. Stamps must stay completely inside the grid.

Return `true` if it is possible to fit the stamps while following the given
restrictions and requirements. Otherwise, return `false`.

","def possibleToStamp(self, grid: List[List[int]], stampHeight: int, stampWidth: int) -> bool:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def possibleToStamp(self, grid: List[List[int]], stampHeight: int, stampWidth: int) -> bool:
    m = len(grid)
    n = len(grid[0])
    A = [[0] * (n + 1) for _ in range(m + 1)]
    B = [[0] * (n + 1) for _ in range(m + 1)]
    fit = [[False] * n for _ in range(m)]

    for i in range(m):
      for j in range(n):
        A[i + 1][j + 1] = A[i + 1][j] + A[i][j + 1] - A[i][j] + grid[i][j]
        if i + 1 >= stampHeight and j + 1 >= stampWidth:
          x = i - stampHeight + 1
          y = j - stampWidth + 1
          if A[i + 1][j + 1] - A[x][j + 1] - A[i + 1][y] + A[x][y] == 0:
            fit[i][j] = True

    for i in range(m):
      for j in range(n):
        B[i + 1][j + 1] = B[i + 1][j] + B[i][j + 1] - B[i][j] + fit[i][j]

    for i in range(m):
      for j in range(n):
        if not grid[i][j]:
          x = min(i + stampHeight, m)
          y = min(j + stampWidth, n)
          if B[x][y] - B[i][y] - B[x][j] + B[i][j] == 0:
            return False

    return True
"
1857,"There is a directed graph of `n` colored nodes and `m` edges. The nodes are
numbered from `0` to `n - 1`.

You are given a string `colors` where `colors[i]` is a lowercase English
letter representing the color of the `ith` node in this graph (0-indexed). You
are also given a 2D array `edges` where `edges[j] = [aj, bj]` indicates that
there is a directed edge from node `aj` to node `bj`.

A valid path in the graph is a sequence of nodes `x1 -> x2 -> x3 -> ... -> xk`
such that there is a directed edge from `xi` to `xi+1` for every `1 <= i < k`.
The color value of the path is the number of nodes that are colored the most
frequently occurring color along that path.

Return the largest color value of any valid path in the given graph, or `-1`
if the graph contains a cycle.

","def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:
    n = len(colors)
    ans = 0
    processed = 0
    graph = [[] for _ in range(n)]
    inDegrees = [0] * n
    q = collections.deque()
    count = [[0] * 26 for _ in range(n)]

    for u, v in edges:
      graph[u].append(v)
      inDegrees[v] += 1

    for i, degree in enumerate(inDegrees):
      if degree == 0:
        q.append(i)

    while q:
      u = q.popleft()
      processed += 1
      count[u][ord(colors[u]) - ord('a')] += 1
      ans = max(ans, count[u][ord(colors[u]) - ord('a')])
      for v in graph[u]:
        for i in range(26):
          count[v][i] = max(count[v][i], count[u][i])
        inDegrees[v] -= 1
        if inDegrees[v] == 0:
          q.append(v)

    if processed == n:
      return ans
    else:
      return -1
"
1878,"You are given an `m x n` integer matrix `grid`​​​.

A rhombus sum is the sum of the elements that form the border of a regular
rhombus shape in `grid`​​​. The rhombus must have the shape of a square
rotated 45 degrees with each of the corners centered in a grid cell. Below is
an image of four valid rhombus shapes with the corresponding colored cells
that should be included in each rhombus sum:

Note that the rhombus can have an area of 0, which is depicted by the purple
rhombus in the bottom right corner.

Return the biggest three distinct rhombus sums in the `grid` in descending
order. If there are less than three distinct values, return all of them.

","def getBiggestThree(self, grid: List[List[int]]) -> List[int]:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

from sortedcontainers import SortedSet


class Solution:
  def getBiggestThree(self, grid: List[List[int]]) -> List[int]:
    m = len(grid)
    n = len(grid[0])
    sums = SortedSet()

    for i in range(m):
      for j in range(n):
        sz = 0
        while i + sz < m and i - sz >= 0 and j + 2 * sz < n:
          summ = grid[i][j] if sz == 0 else self._getSum(grid, i, j, sz)
          sums.add(summ)
          if len(sums) > 3:
            sums.pop(0)
          sz += 1

    return reversed(sums)

  def _getSum(self, grid: List[List[int]], i: int, j: int, sz: int) -> int:
    x = i
    y = j
    summ = 0

    for _ in range(sz):
      x -= 1
      y += 1
      summ += grid[x][y]

    for _ in range(sz):
      x += 1
      y += 1
      summ += grid[x][y]

    for _ in range(sz):
      x += 1
      y -= 1
      summ += grid[x][y]

    for _ in range(sz):
      x -= 1
      y -= 1
      summ += grid[x][y]

    return summ
"
1896,"You are given a valid boolean expression as a string `expression` consisting
of the characters `'1'`,`'0'`,`'&'` (bitwise AND operator),`'|'` (bitwise OR
operator),`'('`, and `')'`.

* For example, `""()1|1""` and `""(1)&()""` are not valid while `""1""`, `""(((1))|(0))""`, and `""1|(0&(1))""` are valid expressions.

Return the minimum cost to change the final value of the expression.

* For example, if `expression = ""1|1|(0&0)&1""`, its value is `1|1|(0&0)&1 = 1|1|0&1 = 1|0&1 = 1&1 = 1`. We want to apply operations so that the new expression evaluates to `0`.

The cost of changing the final value of an expression is the number of
operations performed on the expression. The types of operations are described
as follows:

* Turn a `'1'` into a `'0'`.
* Turn a `'0'` into a `'1'`.
* Turn a `'&'` into a `'|'`.
* Turn a `'|'` into a `'&'`.

Note: `'&'` does not take precedence over `'|'` in the order of calculation.
Evaluate parentheses first, then in left-to-right order.

","def minOperationsToFlip(self, expression: str) -> int:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def minOperationsToFlip(self, expression: str) -> int:
    stack = []

    for e in expression:
      if e in '(&|':
        stack.append((e, 0))
        continue
      if e == ')':
        lastPair = stack.pop()
        stack.pop()
      else: 
        lastPair = (e, 1)
      if stack and stack[-1][0] in '&|':
        op = stack.pop()[0]
        a, costA = stack.pop()
        b, costB = lastPair
        if op == '&':
          if a == '0' and b == '0':
            lastPair = ('0', 1 + min(costA, costB))
          elif a == '0' and b == '1':
            lastPair = ('0', 1)
          elif a == '1' and b == '0':
            lastPair = ('0', 1)
          else:
            lastPair = ('1', min(costA, costB))
        else:
          if a == '0' and b == '0':
            lastPair = ('0', min(costA, costB))
          elif a == '0' and b == '1':
            lastPair = ('1', 1)
          elif a == '1' and b == '0':
            lastPair = ('1', 1)
          else:
            lastPair = ('1', 1 + min(costA, costB))
      stack.append(lastPair)

    return stack[-1][1]
"
1906,"The minimum absolute difference of an array `a` is defined as the minimum
value of `|a[i] - a[j]|`, where `0 <= i < j < a.length` and `a[i] != a[j]`. If
all elements of `a` are the same, the minimum absolute difference is `-1`.

* For example, the minimum absolute difference of the array `[5,2,3,7,2]` is `|2 - 3| = 1`. Note that it is not `0` because `a[i]` and `a[j]` must be different.

You are given an integer array `nums` and the array `queries` where
`queries[i] = [li, ri]`. For each query `i`, compute the minimum absolute
difference of the subarray `nums[li...ri]` containing the elements of `nums`
between the 0-based indices `li` and `ri` (inclusive).

Return an array `ans` where `ans[i]` is the answer to the `ith` query.

A subarray is a contiguous sequence of elements in an array.

The value of `|x|` is defined as:

* `x` if `x >= 0`.
* `-x` if `x < 0`.

","def minDifference(self, nums: List[int], queries: List[List[int]]) -> List[int]:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from bisect import bisect_left
from typing import List, Dict, Tuple, Iterator

class Solution:
  def minDifference(self, nums: List[int], queries: List[List[int]]) -> List[int]:
    numToIndices = [[] for _ in range(101)]

    for i, num in enumerate(nums):
      numToIndices[num].append(i)

    if len(numToIndices[nums[0]]) == len(nums):
      return [-1] * len(queries)

    ans = []

    for l, r in queries:
      prevNum = -1
      minDiff = 101
      for num in range(1, 101):
        indices = numToIndices[num]
        i = bisect_left(indices, l)
        if i == len(indices) or indices[i] > r:
          continue
        if prevNum != -1:
          minDiff = min(minDiff, num - prevNum)
        prevNum = num
      ans.append(-1 if minDiff == 101 else minDiff)

    return ans
"
1923,"There is a country of `n` cities numbered from `0` to `n - 1`. In this
country, there is a road connecting every pair of cities.

There are `m` friends numbered from `0` to `m - 1` who are traveling through
the country. Each one of them will take a path consisting of some cities. Each
path is represented by an integer array that contains the visited cities in
order. The path may contain a city more than once, but the same city will not
be listed consecutively.

Given an integer `n` and a 2D integer array `paths` where `paths[i]` is an
integer array representing the path of the `ith` friend, return the length of
the longest common subpath that is shared by every friend's path, or `0` if
there is no common subpath at all.

A subpath of a path is a contiguous sequence of cities within that path.

",def __init__(self):,"import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator, Set

class Solution:
  def __init__(self):
    self.kMod = 8_417_508_174_513
    self.kBase = 165_131

  def longestCommonSubpath(self, n: int, paths: List[List[int]]) -> int:
    l = 0
    r = len(paths[0])

    while l < r:
      m = l + (r - l + 1) // 2
      if self._checkCommonSubpath(paths, m):
        l = m
      else:
        r = m - 1

    return l

  def _checkCommonSubpath(self, paths: List[List[int]], m: int) -> bool:
    hashSets = [self._rabinKarp(path, m) for path in paths]

    for subpathHash in hashSets[0]:
      if all(subpathHash in hashSet for hashSet in hashSets):
        return True

    return False

  def _rabinKarp(self, path: List[int], m: int) -> Set[int]:
    hashes = set()
    maxPower = 1
    hash = 0

    for i, num in enumerate(path):
      hash = (hash * self.kBase + num) % self.kMod
      if i >= m:
        hash = (hash - path[i - m] * maxPower % self.kMod + self.kMod) % self.kMod
      else:
        maxPower = maxPower * self.kBase % self.kMod
      if i >= m - 1:
        hashes.add(hash)

    return hashes
"
1926,"You are given an `m x n` matrix `maze` (0-indexed) with empty cells
(represented as `'.'`) and walls (represented as `'+'`). You are also given
the `entrance` of the maze, where `entrance = [entrancerow, entrancecol]`
denotes the row and column of the cell you are initially standing at.

In one step, you can move one cell up, down, left, or right. You cannot step
into a cell with a wall, and you cannot step outside the maze. Your goal is to
find the nearest exit from the `entrance`. An exit is defined as an empty cell
that is at the border of the `maze`. The `entrance` does not count as an exit.

Return the number of steps in the shortest path from the `entrance` to the
nearest exit, or `-1` if no such path exists.

","def nearestExit(self, maze: List[List[str]], entrance: List[int]) -> int:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def nearestExit(self, maze: List[List[str]], entrance: List[int]) -> int:
    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))
    m = len(maze)
    n = len(maze[0])
    ans = 0
    q = collections.deque([(entrance[0], entrance[1])])
    seen = {(entrance[0], entrance[1])}

    while q:
      ans += 1
      for _ in range(len(q)):
        i, j = q.popleft()
        for dx, dy in dirs:
          x = i + dx
          y = j + dy
          if x < 0 or x == m or y < 0 or y == n:
            continue
          if (x, y) in seen or maze[x][y] == '+':
            continue
          if x == 0 or x == m - 1 or y == 0 or y == n - 1:
            return ans
          q.append((x, y))
          seen.add((x, y))

    return -1
"
1928,"There is a country of `n` cities numbered from `0` to `n - 1` where all the
cities are connected by bi-directional roads. The roads are represented as a
2D integer array `edges` where `edges[i] = [xi, yi, timei]` denotes a road
between cities `xi` and `yi` that takes `timei` minutes to travel. There may
be multiple roads of differing travel times connecting the same two cities,
but no road connects a city to itself.

Each time you pass through a city, you must pay a passing fee. This is
represented as a 0-indexed integer array `passingFees` of length `n` where
`passingFees[j]` is the amount of dollars you must pay when you pass through
city `j`.

In the beginning, you are at city `0` and want to reach city `n - 1` in
`maxTime` minutes or less. The cost of your journey is the summation of
passing fees for each city that you passed through at some moment of your
journey (including the source and destination cities).

Given `maxTime`, `edges`, and `passingFees`, return the minimum cost to
complete your journey, or `-1` if you cannot complete it within `maxTime`
minutes.

","def minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -> int:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -> int:
    n = len(passingFees)
    graph = [[] for _ in range(n)]

    for u, v, w in edges:
      graph[u].append((v, w))
      graph[v].append((u, w))

    return self._dijkstra(graph, 0, n - 1, maxTime, passingFees)

  def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, dst: int, maxTime: int, passingFees: List[int]) -> int:
    cost = [math.inf for _ in range(len(graph))]
    dist = [maxTime + 1 for _ in range(len(graph))]

    cost[src] = passingFees[src]
    dist[src] = 0
    minHeap = [(cost[src], dist[src], src)]

    while minHeap:
      currCost, d, u = heapq.heappop(minHeap)
      if u == dst:
        return cost[dst]
      if d > dist[u] and currCost > cost[u]:
        continue
      for v, w in graph[u]:
        if d + w > maxTime:
          continue
        if currCost + passingFees[v] < cost[v]:
          cost[v] = currCost + passingFees[v]
          dist[v] = d + w
          heapq.heappush(minHeap, (cost[v], dist[v], v))
        elif d + w < dist[v]:
          dist[v] = d + w
          heapq.heappush(minHeap, (currCost + passingFees[v], dist[v], v))

    return -1
"
1938,"There is a rooted tree consisting of `n` nodes numbered `0` to `n - 1`. Each
node's number denotes its unique genetic value (i.e. the genetic value of node
`x` is `x`). The genetic difference between two genetic values is defined as
the bitwise-XOR of their values. You are given the integer array `parents`,
where `parents[i]` is the parent for node `i`. If node `x` is the root of the
tree, then `parents[x] == -1`.

You are also given the array `queries` where `queries[i] = [nodei, vali]`. For
each query `i`, find the maximum genetic difference between `vali` and `pi`,
where `pi` is the genetic value of any node that is on the path between
`nodei` and the root (including `nodei` and the root). More formally, you want
to maximize `vali XOR pi`.

Return an array `ans` where `ans[i]` is the answer to the `ith` query.

",def __init__(self):,"import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class TrieNode:
  def __init__(self):
    self.children = [None] * 2
    self.count = 0


class Trie:
  def __init__(self):
    self.root = TrieNode()
    self.kHeight = 17

  def update(self, num: int, val: int) -> None:
    node = self.root
    for i in range(self.kHeight, -1, -1):
      bit = (num >> i) & 1
      if not node.children[bit]:
        node.children[bit] = TrieNode()
      node = node.children[bit]
      node.count += val

  def query(self, num: int) -> int:
    ans = 0
    node = self.root
    for i in range(self.kHeight, -1, -1):
      bit = (num >> i) & 1
      targetBit = bit ^ 1
      if node.children[targetBit] and node.children[targetBit].count > 0:
        ans += 1 << i
        node = node.children[targetBit]
      else:
        node = node.children[targetBit ^ 1]
    return ans


class Solution:
  def maxGeneticDifference(self, parents: List[int], queries: List[List[int]]) -> List[int]:
    n = len(parents)
    ans = [0] * len(queries)
    rootVal = -1
    tree = [[] for _ in range(n)]
    nodeToQueries = collections.defaultdict(list)
    trie = Trie()

    for i, parent in enumerate(parents):
      if parent == -1:
        rootVal = i
      else:
        tree[parent].append(i)

    for i, (node, val) in enumerate(queries):
      nodeToQueries[node].append((i, val))

    def dfs(node: int) -> None:
      trie.update(node, 1)

      for i, val in nodeToQueries[node]:
        ans[i] = trie.query(val)

      for child in tree[node]:
        dfs(child)

      trie.update(node, -1)

    dfs(rootVal)
    return ans
"
1971,"There is a bi-directional graph with `n` vertices, where each vertex is
labeled from `0` to `n - 1` (inclusive). The edges in the graph are
represented as a 2D integer array `edges`, where each `edges[i] = [ui, vi]`
denotes a bi-directional edge between vertex `ui` and vertex `vi`. Every
vertex pair is connected by at most one edge, and no vertex has an edge to
itself.

You want to determine if there is a valid path that exists from vertex
`source` to vertex `destination`.

Given `edges` and the integers `n`, `source`, and `destination`, return `true`
if there is a valid path from `source` to `destination`, or `false` otherwise.

","def __init__(self, n: int):","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class UnionFind:
  def __init__(self, n: int):
    self.id = list(range(n))
    self.rank = [0] * n

  def unionByRank(self, u: int, v: int) -> None:
    i = self.find(u)
    j = self.find(v)
    if i == j:
      return
    if self.rank[i] < self.rank[j]:
      self.id[i] = j
    elif self.rank[i] > self.rank[j]:
      self.id[j] = i
    else:
      self.id[i] = j
      self.rank[j] += 1

  def find(self, u: int) -> int:
    if self.id[u] != u:
      self.id[u] = self.find(self.id[u])
    return self.id[u]


class Solution:
  def validPath(self, n: int, edges: List[List[int]], source: int, destination: int) -> bool:
    uf = UnionFind(n)

    for u, v in edges:
      uf.unionByRank(u, v)

    return uf.find(source) == uf.find(destination)
"
1976,"You are in a city that consists of `n` intersections numbered from `0` to `n -
1` with bi-directional roads between some intersections. The inputs are
generated such that you can reach any intersection from any other intersection
and that there is at most one road between any two intersections.

You are given an integer `n` and a 2D integer array `roads` where `roads[i] =
[ui, vi, timei]` means that there is a road between intersections `ui` and
`vi` that takes `timei` minutes to travel. You want to know in how many ways
you can travel from intersection `0` to intersection `n - 1` in the shortest
amount of time.

Return the number of ways you can arrive at your destination in the shortest
amount of time. Since the answer may be large, return it modulo `109 + 7`.

","def countPaths(self, n: int, roads: List[List[int]]) -> int:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def countPaths(self, n: int, roads: List[List[int]]) -> int:
    graph = [[] for _ in range(n)]

    for u, v, w in roads:
      graph[u].append((v, w))
      graph[v].append((u, w))

    return self._dijkstra(graph, 0, n - 1)

  def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, dst: int) -> int:
    kMod = 10**9 + 7
    ways = [0] * len(graph)
    dist = [math.inf] * len(graph)

    ways[src] = 1
    dist[src] = 0
    minHeap = [(dist[src], src)]

    while minHeap:
      d, u = heapq.heappop(minHeap)
      if d > dist[u]:
        continue
      for v, w in graph[u]:
        if d + w < dist[v]:
          dist[v] = d + w
          ways[v] = ways[u]
          heapq.heappush(minHeap, (dist[v], v))
        elif d + w == dist[v]:
          ways[v] += ways[u]
          ways[v] %= kMod

    return ways[dst]
"
1977,"You wrote down many positive integers in a string called `num`. However, you
realized that you forgot to add commas to seperate the different numbers. You
remember that the list of integers was non-decreasing and that no integer had
leading zeros.

Return the number of possible lists of integers that you could have written
down to get the string `num`. Since the answer may be large, return it modulo
`109 + 7`.

","def numberOfCombinations(self, num: str) -> int:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def numberOfCombinations(self, num: str) -> int:
    if num[0] == '0':
      return 0

    kMod = 1_000_000_007
    n = len(num)
    dp = [[0] * (n + 1) for _ in range(n)]
    lcs = [[0] * (n + 1) for _ in range(n + 1)]

    for i in range(n - 1, -1, -1):
      for j in range(i + 1, n):
        if num[i] == num[j]:
          lcs[i][j] = lcs[i + 1][j + 1] + 1

    for i in range(n):
      for k in range(1, i + 2):
        dp[i][k] += dp[i][k - 1]
        dp[i][k] %= kMod
        s = i - k + 1
        if num[s] == '0':
          continue
        if s == 0:
          dp[i][k] += 1
          continue
        if s < k:
          dp[i][k] += dp[s - 1][s]
          continue
        l = lcs[s - k][s]
        if l >= k or num[s - k + l] <= num[s + l]:
          dp[i][k] += dp[s - 1][k]
        else:
          dp[i][k] += dp[s - 1][k - 1]

    return dp[n - 1][n] % kMod
"
1994,"You are given an integer array `nums`. We call a subset of `nums` good if its
product can be represented as a product of one or more distinct prime numbers.

* For example, if `nums = [1, 2, 3, 4]`: 
* `[2, 3]`, `[1, 2, 3]`, and `[1, 3]` are good subsets with products `6 = 2*3`, `6 = 2*3`, and `3 = 3` respectively.
* `[1, 4]` and `[4]` are not good subsets with products `4 = 2*2` and `4 = 2*2` respectively.

Return the number of different good subsets in `nums` modulo `109 + 7`.

A subset of `nums` is any array that can be obtained by deleting some
(possibly none or all) elements from `nums`. Two subsets are different if and
only if the chosen indices to delete are different.

","def numberOfGoodSubsets(self, nums: List[int]) -> int:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def numberOfGoodSubsets(self, nums: List[int]) -> int:
    kMod = 1_000_000_007
    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]
    n = 1 << len(primes)
    dp = [1] + [0] * (n - 1)
    count = collections.Counter(nums)

    for num, freq in count.items():
      if num == 1:
        continue
      if any(num % squared == 0 for squared in [4, 9, 25]):
        continue
      numPrimesMask = 0
      for i, prime in enumerate(primes):
        if num % prime == 0:
          numPrimesMask += 1 << i
      for primesMask in range(n):
        if primesMask & numPrimesMask > 0:
          continue
        nextPrimesMask = numPrimesMask | primesMask
        dp[nextPrimesMask] += dp[primesMask] * freq
        dp[nextPrimesMask] %= kMod

    return (1 << count[1]) * sum(dp[1:]) % kMod
"
1998,"You are given an integer array `nums`, and you can perform the following
operation any number of times on `nums`:

* Swap the positions of two elements `nums[i]` and `nums[j]` if `gcd(nums[i], nums[j]) > 1` where `gcd(nums[i], nums[j])` is the greatest common divisor of `nums[i]` and `nums[j]`.

Return `true` if it is possible to sort `nums` in non-decreasing order using
the above swap method, or `false` otherwise.

","def __init__(self, n: int):","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class UnionFind:
  def __init__(self, n: int):
    self.id = list(range(n))
    self.rank = [0] * n

  def unionByRank(self, u: int, v: int) -> None:
    i = self.find(u)
    j = self.find(v)
    if i == j:
      return False
    if self.rank[i] < self.rank[j]:
      self.id[i] = j
    elif self.rank[i] > self.rank[j]:
      self.id[j] = i
    else:
      self.id[i] = j
      self.rank[j] += 1
    return True

  def find(self, u: int) -> int:
    if self.id[u] != u:
      self.id[u] = self.find(self.id[u])
    return self.id[u]


class Solution:
  def gcdSort(self, nums: List[int]) -> bool:
    maxNum = max(nums)
    minPrimeFactors = self._sieveEratosthenes(maxNum + 1)
    uf = UnionFind(maxNum + 1)

    for num in nums:
      for primeFactor in self._getPrimeFactors(num, minPrimeFactors):
        uf.unionByRank(num, primeFactor)

    for a, b in zip(nums, sorted(nums)):
      if uf.find(a) != uf.find(b):
        return False

    return True

  def _sieveEratosthenes(self, n: int) -> List[int]:
    minPrimeFactors = [i for i in range(n + 1)]
    for i in range(2, int(n**0.5) + 1):
      if minPrimeFactors[i] == i:
        for j in range(i * i, n, i):
          minPrimeFactors[j] = min(minPrimeFactors[j], i)
    return minPrimeFactors

  def _getPrimeFactors(self, num: int, minPrimeFactors: List[int]) -> List[int]:
    primeFactors = []
    while num > 1:
      divisor = minPrimeFactors[num]
      primeFactors.append(divisor)
      while num % divisor == 0:
        num //= divisor
    return primeFactors
"
2019,"You are given a string `s` that contains digits `0-9`, addition symbols `'+'`,
and multiplication symbols `'*'` only, representing a valid math expression of
single digit numbers (e.g., `3+5*2`). This expression was given to `n`
elementary school students. The students were instructed to get the answer of
the expression by following this order of operations:

1. Compute multiplication, reading from left to right; Then,
2. Compute addition, reading from left to right.

You are given an integer array `answers` of length `n`, which are the
submitted answers of the students in no particular order. You are asked to
grade the `answers`, by following these rules:

* If an answer equals the correct answer of the expression, this student will be rewarded `5` points;
* Otherwise, if the answer could be interpreted as if the student applied the operators in the wrong order but had correct arithmetic, this student will be rewarded `2` points;
* Otherwise, this student will be rewarded `0` points.

Return the sum of the points of the students.

","def scoreOfStudents(self, s: str, answers: List[int]) -> int:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
import operator
from typing import List, Dict, Tuple, Iterator

class Solution:
  def scoreOfStudents(self, s: str, answers: List[int]) -> int:
    n = len(s) // 2 + 1
    ans = 0
    func = {'+': operator.add, '*': operator.mul}
    dp = [[set() for j in range(n)] for _ in range(n)]

    for i in range(n):
      dp[i][i].add(int(s[i * 2]))

    for d in range(1, n):
      for i in range(n - d):
        j = i + d
        for k in range(i, j):
          op = s[k * 2 + 1]
          for a in dp[i][k]:
            for b in dp[k + 1][j]:
              res = func[op](a, b)
              if res <= 1000:
                dp[i][j].add(res)

    correctAnswer = eval(s)

    for answer, freq in collections.Counter(answers).items():
      if answer == correctAnswer:
        ans += 5 * freq
      elif answer in dp[0][n - 1]:
        ans += 2 * freq

    return ans
"
2030,"You are given a string `s`, an integer `k`, a letter `letter`, and an integer
`repetition`.

Return the lexicographically smallest subsequence of `s` of length `k` that
has the letter `letter` appear at least `repetition` times. The test cases are
generated so that the `letter` appears in `s` at least `repetition` times.

A subsequence is a string that can be derived from another string by deleting
some or no characters without changing the order of the remaining characters.

A string `a` is lexicographically smaller than a string `b` if in the first
position where `a` and `b` differ, string `a` has a letter that appears
earlier in the alphabet than the corresponding letter in `b`.

","def smallestSubsequence(self, s: str, k: int, letter: str, repetition: int) -> str:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def smallestSubsequence(self, s: str, k: int, letter: str, repetition: int) -> str:
    stack = []
    required = repetition
    nLetters = s.count(letter)

    for i, c in enumerate(s):
      while stack and stack[-1] > c  and len(stack) + len(s) - i - 1 >= k and (stack[-1] != letter or nLetters > required):
        if stack.pop() == letter:
          required += 1
      if len(stack) < k:
        if c == letter:
          stack.append(c)
          required -= 1
        elif k - len(stack) > required:
          stack.append(c)
      if c == letter:
        nLetters -= 1

    return ''.join(stack)
"
2040,"Given two sorted 0-indexed integer arrays `nums1` and `nums2` as well as an
integer `k`, return the `kth` (1-based) smallest product of `nums1[i] *
nums2[j]` where `0 <= i < nums1.length` and `0 <= j < nums2.length`.

","def kthSmallestProduct(self, nums1: List[int], nums2: List[int], k: int) -> int:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def kthSmallestProduct(self, nums1: List[int], nums2: List[int], k: int) -> int:
    A1 = [-num for num in nums1 if num < 0][::-1]
    A2 = [num for num in nums1 if num >= 0]
    B1 = [-num for num in nums2 if num < 0][::-1]
    B2 = [num for num in nums2 if num >= 0]

    negCount = len(A1) * len(B2) + len(A2) * len(B1)

    if k > negCount:
      k -= negCount
      sign = 1
    else:
      k = negCount - k + 1
      sign = -1
      B1, B2 = B2, B1

    def numProductNoGreaterThan(A: List[int], B: List[int], m: int) -> int:
      ans = 0
      j = len(B) - 1
      for i in range(len(A)):
        while j >= 0 and A[i] * B[j] > m:
          j -= 1
        ans += j + 1
      return ans

    l = 0
    r = 10**10

    while l < r:
      m = (l + r) // 2
      if numProductNoGreaterThan(A1, B1, m) + numProductNoGreaterThan(A2, B2, m) >= k:
        r = m
      else:
        l = m + 1

    return sign * l
"
2045,"A city is represented as a bi-directional connected graph with `n` vertices
where each vertex is labeled from `1` to `n` (inclusive). The edges in the
graph are represented as a 2D integer array `edges`, where each `edges[i] =
[ui, vi]` denotes a bi-directional edge between vertex `ui` and vertex `vi`.
Every vertex pair is connected by at most one edge, and no vertex has an edge
to itself. The time taken to traverse any edge is `time` minutes.

Each vertex has a traffic signal which changes its color from green to red and
vice versa every `change` minutes. All signals change at the same time. You
can enter a vertex at any time, but can leave a vertex only when the signal is
green. You cannot wait at a vertex if the signal is green.

The second minimum value is defined as the smallest value strictly larger than
the minimum value.

* For example the second minimum value of `[2, 3, 4]` is `3`, and the second minimum value of `[2, 2, 4]` is `4`.

Given `n`, `edges`, `time`, and `change`, return the second minimum time it
will take to go from vertex `1` to vertex `n`.

Notes:

* You can go through any vertex any number of times, including `1` and `n`.
* You can assume that when the journey starts, all signals have just turned green.

","def secondMinimum(self, n: int, edges: List[List[int]], time: int, change: int) -> int:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def secondMinimum(self, n: int, edges: List[List[int]], time: int, change: int) -> int:
    graph = [[] for _ in range(n + 1)]
    q = collections.deque([(1, 0)])
    minTime = [[math.inf] * 2 for _ in range(n + 1)]
    minTime[1][0] = 0

    for u, v in edges:
      graph[u].append(v)
      graph[v].append(u)

    while q:
      i, prevTime = q.popleft()

      numChangeSignal = prevTime // change
      waitTime = change - (prevTime % change) if numChangeSignal & 1 else 0
      newTime = prevTime + waitTime + time
      for j in graph[i]:
        if newTime < minTime[j][0]:
          minTime[j][0] = newTime
          q.append((j, newTime))
        elif minTime[j][0] < newTime < minTime[j][1]:
          if j == n:
            return newTime
          minTime[j][1] = newTime
          q.append((j, newTime))
"
2059,"You are given a 0-indexed integer array `nums` containing distinct numbers, an
integer `start`, and an integer `goal`. There is an integer `x` that is
initially set to `start`, and you want to perform operations on `x` such that
it is converted to `goal`. You can perform the following operation repeatedly
on the number `x`:

If `0 <= x <= 1000`, then for any index `i` in the array (`0 <= i <
nums.length`), you can set `x` to any of the following:

* `x + nums[i]`
* `x - nums[i]`
* `x ^ nums[i]` (bitwise-XOR)

Note that you can use each `nums[i]` any number of times in any order.
Operations that set `x` to be out of the range `0 <= x <= 1000` are valid, but
no more operations can be done afterward.

Return the minimum number of operations needed to convert `x = start` into
`goal`, and `-1` if it is not possible.

","def minimumOperations(self, nums: List[int], start: int, goal: int) -> int:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def minimumOperations(self, nums: List[int], start: int, goal: int) -> int:
    ans = 0
    q = collections.deque([start])
    seen = {start}

    while q:
      ans += 1
      for _ in range(len(q)):
        x = q.popleft()
        for num in nums:
          for res in (x + num, x - num, x ^ num):
            if res == goal:
              return ans
            if res < 0 or res > 1000 or res in seen:
              continue
            seen.add(res)
            q.append(res)

    return -1
"
2076,"You are given an integer `n` indicating the number of people in a network.
Each person is labeled from `0` to `n - 1`.

You are also given a 0-indexed 2D integer array `restrictions`, where
`restrictions[i] = [xi, yi]` means that person `xi` and person `yi` cannot
become friends, either directly or indirectly through other people.

Initially, no one is friends with each other. You are given a list of friend
requests as a 0-indexed 2D integer array `requests`, where `requests[j] = [uj,
vj]` is a friend request between person `uj` and person `vj`.

A friend request is successful if `uj` and `vj` can be friends. Each friend
request is processed in the given order (i.e., `requests[j]` occurs before
`requests[j + 1]`), and upon a successful request, `uj` and `vj` become direct
friends for all future friend requests.

Return a boolean array `result`, where each `result[j]` is `true` if the `jth`
friend request is successful or `false` if it is not.

Note: If `uj` and `vj` are already direct friends, the request is still
successful.

","def __init__(self, n: int):","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class UnionFind:
  def __init__(self, n: int):
    self.id = list(range(n))
    self.rank = [0] * n

  def unionByRank(self, u: int, v: int) -> None:
    i = self.find(u)
    j = self.find(v)
    if i == j:
      return
    if self.rank[i] < self.rank[j]:
      self.id[i] = j
    elif self.rank[i] > self.rank[j]:
      self.id[j] = i
    else:
      self.id[i] = j
      self.rank[j] += 1

  def find(self, u: int) -> int:
    if self.id[u] != u:
      self.id[u] = self.find(self.id[u])
    return self.id[u]


class Solution:
  def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:
    ans = []
    uf = UnionFind(n)

    for u, v in requests:
      pu = uf.find(u)
      pv = uf.find(v)
      isValid = True
      if pu != pv:
        for x, y in restrictions:
          px = uf.find(x)
          py = uf.find(y)
          if (pu, pv) in [(px, py), (py, px)]:
            isValid = False
            break
      ans.append(isValid)
      if isValid:
        uf.unionByRank(pu, pv)

    return ans
"
2086,"You are given a 0-indexed string `hamsters` where `hamsters[i]` is either:

* `'H'` indicating that there is a hamster at index `i`, or
* `'.'` indicating that index `i` is empty.

You will add some number of food buckets at the empty indices in order to feed
the hamsters. A hamster can be fed if there is at least one food bucket to its
left or to its right. More formally, a hamster at index `i` can be fed if you
place a food bucket at index `i - 1` and/or at index `i + 1`.

Return the minimum number of food buckets you should place at empty indices to
feed all the hamsters or `-1` if it is impossible to feed all of them.

","def minimumBuckets(self, street: str) -> int:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def minimumBuckets(self, street: str) -> int:
    A = list(street)

    for i, c in enumerate(A):
      if c == 'H':
        if i > 0 and A[i - 1] == 'B':
          continue
        if i + 1 < len(A) and A[i + 1] == '.':
          A[i + 1] = 'B'
        elif i > 0 and A[i - 1] == '.':
          A[i - 1] = 'B'
        else:
          return -1

    return A.count('B')
"
2092,"You are given an integer `n` indicating there are `n` people numbered from `0`
to `n - 1`. You are also given a 0-indexed 2D integer array `meetings` where
`meetings[i] = [xi, yi, timei]` indicates that person `xi` and person `yi`
have a meeting at `timei`. A person may attend multiple meetings at the same
time. Finally, you are given an integer `firstPerson`.

Person `0` has a secret and initially shares the secret with a person
`firstPerson` at time `0`. This secret is then shared every time a meeting
takes place with a person that has the secret. More formally, for every
meeting, if a person `xi` has the secret at `timei`, then they will share the
secret with person `yi`, and vice versa.

The secrets are shared instantaneously. That is, a person may receive the
secret and share it with people in other meetings within the same time frame.

Return a list of all the people that have the secret after all the meetings
have taken place. You may return the answer in any order.

","def __init__(self, n: int):","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class UnionFind:
  def __init__(self, n: int):
    self.id = list(range(n))
    self.rank = [0] * n

  def unionByRank(self, u: int, v: int) -> None:
    i = self._find(u)
    j = self._find(v)
    if i == j:
      return
    if self.rank[i] < self.rank[j]:
      self.id[i] = j
    elif self.rank[i] > self.rank[j]:
      self.id[j] = i
    else:
      self.id[i] = j
      self.rank[j] += 1

  def connected(self, u: int, v: int) -> bool:
    return self._find(self.id[u]) == self._find(self.id[v])

  def reset(self, u: int) -> None:
    self.id[u] = u

  def _find(self, u: int) -> int:
    if self.id[u] != u:
      self.id[u] = self._find(self.id[u])
    return self.id[u]


class Solution:
  def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:
    uf = UnionFind(n)
    timeToPairs = collections.defaultdict(list)

    uf.unionByRank(0, firstPerson)

    for x, y, time in meetings:
      timeToPairs[time].append((x, y))

    for _, pairs in sorted(timeToPairs.items(), key=lambda x: x[0]):
      peopleUnioned = set()
      for x, y in pairs:
        uf.unionByRank(x, y)
        peopleUnioned.add(x)
        peopleUnioned.add(y)
      for person in peopleUnioned:
        if not uf.connected(person, 0):
          uf.reset(person)

    res=[]
    for i in range(n):
      if uf.connected(i, 0):
        res.append(i)
    return res
"
2115,"You have information about `n` different recipes. You are given a string array
`recipes` and a 2D string array `ingredients`. The `ith` recipe has the name
`recipes[i]`, and you can create it if you have all the needed ingredients
from `ingredients[i]`. Ingredients to a recipe may need to be created from
other recipes, i.e., `ingredients[i]` may contain a string that is in
`recipes`.

You are also given a string array `supplies` containing all the ingredients
that you initially have, and you have an infinite supply of all of them.

Return a list of all the recipes that you can create. You may return the
answer in any order.

Note that two recipes may contain each other in their ingredients.

","def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:
    ans = []
    supplies = set(supplies)
    graph = collections.defaultdict(list)
    inDegrees = collections.Counter()
    q = collections.deque()

    for i, recipe in enumerate(recipes):
      for ingredient in ingredients[i]:
        if ingredient not in supplies:
          graph[ingredient].append(recipe)
          inDegrees[recipe] += 1

    for recipe in recipes:
      if inDegrees[recipe] == 0:
        q.append(recipe)

    while q:
      u = q.popleft()
      ans.append(u)
      for v in graph[u]:
        inDegrees[v] -= 1
        if inDegrees[v] == 0:
          q.append(v)

    return ans
"
2467,"There is an undirected tree with `n` nodes labeled from `0` to `n - 1`, rooted
at node `0`. You are given a 2D integer array `edges` of length `n - 1` where
`edges[i] = [ai, bi]` indicates that there is an edge between nodes `ai` and
`bi` in the tree.

At every node `i`, there is a gate. You are also given an array of even
integers `amount`, where `amount[i]` represents:

* the price needed to open the gate at node `i`, if `amount[i]` is negative, or,
* the cash reward obtained on opening the gate at node `i`, otherwise.

The game goes on as follows:

* Initially, Alice is at node `0` and Bob is at node `bob`.
* At every second, Alice and Bob each move to an adjacent node. Alice moves towards some leaf node, while Bob moves towards node `0`.
* For every node along their path, Alice and Bob either spend money to open the gate at that node, or accept the reward. Note that: 
* If the gate is already open, no price will be required, nor will there be any cash reward.
* If Alice and Bob reach the node simultaneously, they share the price/reward for opening the gate there. In other words, if the price to open the gate is `c`, then both Alice and Bob pay `c / 2` each. Similarly, if the reward at the gate is `c`, both of them receive `c / 2` each.
* If Alice reaches a leaf node, she stops moving. Similarly, if Bob reaches node `0`, he stops moving. Note that these events are independent of each other.

Return the maximum net income Alice can have if she travels towards the
optimal leaf node.

","def mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def mostProfitablePath(self, edges: List[List[int]], bob: int, amount: List[int]) -> int:
    n = len(amount)
    tree = [[] for _ in range(n)]
    parent = [0] * n
    aliceDist = [-1] * n

    for u, v in edges:
      tree[u].append(v)
      tree[v].append(u)

    def dfs(u: int, prev: int, d: int) -> None:
      parent[u] = prev
      aliceDist[u] = d
      for v in tree[u]:
        if aliceDist[v] == -1:
          dfs(v, u, d + 1)

    dfs(0, -1, 0)

    u = bob
    bobDist = 0
    while u != 0:
      if bobDist < aliceDist[u]:
        amount[u] = 0
      elif bobDist == aliceDist[u]:
        amount[u] //= 2
      u = parent[u]
      bobDist += 1

    return self._getMoney(tree, 0, -1, amount)

  def _getMoney(self, tree: List[List[int]], u: int, prev: int, amount: List[int]) -> int:
    if len(tree[u]) == 1 and tree[u][0] == prev:
      return amount[u]

    maxPath = -math.inf
    for v in tree[u]:
      if v != prev:
        maxPath = max(maxPath, self._getMoney(tree, v, u, amount))

    return amount[u] + maxPath
"
2127,"A company is organizing a meeting and has a list of `n` employees, waiting to
be invited. They have arranged for a large circular table, capable of seating
any number of employees.

The employees are numbered from `0` to `n - 1`. Each employee has a favorite
person and they will attend the meeting only if they can sit next to their
favorite person at the table. The favorite person of an employee is not
themself.

Given a 0-indexed integer array `favorite`, where `favorite[i]` denotes the
favorite person of the `ith` employee, return the maximum number of employees
that can be invited to the meeting.

","def maximumInvitations(self, favorite: List[int]) -> int:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

from enum import Enum


class State(Enum):
  kInit = 0
  kVisiting = 1
  kVisited = 2


class Solution:
  def maximumInvitations(self, favorite: List[int]) -> int:
    n = len(favorite)
    sumComponentsLength = 0
    graph = [[] for _ in range(n)]
    inDegrees = [0] * n
    maxChainLength = [1] * n

    for i, f in enumerate(favorite):
      graph[i].append(f)
      inDegrees[f] += 1

    q = collections.deque([i for i, d in enumerate(inDegrees) if d == 0])

    while q:
      u = q.popleft()
      for v in graph[u]:
        inDegrees[v] -= 1
        if inDegrees[v] == 0:
          q.append(v)
        maxChainLength[v] = max(maxChainLength[v], 1 + maxChainLength[u])

    for i in range(n):
      if favorite[favorite[i]] == i:
        sumComponentsLength += maxChainLength[i] + maxChainLength[favorite[i]]

    maxCycleLength = 0
    parent = [-1] * n
    seen = set()
    states = [State.kInit] * n

    def findCycle(u: int) -> None:
      nonlocal maxCycleLength
      seen.add(u)
      states[u] = State.kVisiting
      for v in graph[u]:
        if v not in seen:
          parent[v] = u
          findCycle(v)
        elif states[v] == State.kVisiting:
          curr = u
          cycleLength = 1
          while curr != v:
            curr = parent[curr]
            cycleLength += 1
          maxCycleLength = max(maxCycleLength, cycleLength)
      states[u] = State.kVisited

    for i in range(n):
      if i not in seen:
        findCycle(i)

    return max(sumComponentsLength // 2, maxCycleLength)
"
2532,"There are `k` workers who want to move `n` boxes from an old warehouse to a
new one. You are given the two integers `n` and `k`, and a 2D integer array
`time` of size `k x 4` where `time[i] = [leftToRighti, pickOldi, rightToLefti,
putNewi]`.

The warehouses are separated by a river and connected by a bridge. The old
warehouse is on the right bank of the river, and the new warehouse is on the
left bank of the river. Initially, all `k` workers are waiting on the left
side of the bridge. To move the boxes, the `ith` worker (0-indexed) can :

* Cross the bridge from the left bank (new warehouse) to the right bank (old warehouse) in `leftToRighti` minutes.
* Pick a box from the old warehouse and return to the bridge in `pickOldi` minutes. Different workers can pick up their boxes simultaneously.
* Cross the bridge from the right bank (old warehouse) to the left bank (new warehouse) in `rightToLefti` minutes.
* Put the box in the new warehouse and return to the bridge in `putNewi` minutes. Different workers can put their boxes simultaneously.

A worker `i` is less efficient than a worker `j` if either condition is met:

* `leftToRighti + rightToLefti > leftToRightj + rightToLeftj`
* `leftToRighti + rightToLefti == leftToRightj + rightToLeftj` and `i > j`

The following rules regulate the movement of the workers through the bridge :

* If a worker `x` reaches the bridge while another worker `y` is crossing the bridge, `x` waits at their side of the bridge.
* If the bridge is free, the worker waiting on the right side of the bridge gets to cross the bridge. If more than one worker is waiting on the right side, the one with the lowest efficiency crosses first.
* If the bridge is free and no worker is waiting on the right side, and at least one box remains at the old warehouse, the worker on the left side of the river gets to cross the bridge. If more than one worker is waiting on the left side, the one with the lowest efficiency crosses first.

Return the instance of time at which the last worker reaches the left bank of
the river after all n boxes have been put in the new warehouse.

","def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:
    ans = 0
    leftBridgeQueue = [(-leftToRight - rightToLeft, -i) for i, (leftToRight, pickOld, rightToLeft, pickNew) in enumerate(time)]
    rightBridgeQueue = []
    leftWorkers = []
    rightWorkers = []

    heapq.heapify(leftBridgeQueue)

    while n > 0 or rightBridgeQueue or rightWorkers:
      while leftWorkers and leftWorkers[0][0] <= ans:
        i = heapq.heappop(leftWorkers)[1]
        heapq.heappush(leftBridgeQueue, (-time[i][0] - time[i][2], -i))
      while rightWorkers and rightWorkers[0][0] <= ans:
        i = heapq.heappop(rightWorkers)[1]
        heapq.heappush(rightBridgeQueue, (-time[i][0] - time[i][2], -i))
      if rightBridgeQueue:
        i = -heapq.heappop(rightBridgeQueue)[1]
        ans += time[i][2]
        heapq.heappush(leftWorkers, (ans + time[i][3], i))
      elif leftBridgeQueue and n > 0:
        i = -heapq.heappop(leftBridgeQueue)[1]
        ans += time[i][0]
        heapq.heappush(rightWorkers, (ans + time[i][1], i))
        n -= 1
      else:
        if leftWorkers and n > 0:
          ans1=leftWorkers[0][0]
        else:
          ans1=math.inf
        if rightWorkers:
          ans2=rightWorkers[0][0]
        else:
          ans2=math.inf
        ans=min(ans1,ans2)

    return ans"
2499,"You are given two 0-indexed integer arrays `nums1` and `nums2`, of equal
length `n`.

In one operation, you can swap the values of any two indices of `nums1`. The
cost of this operation is the sum of the indices.

Find the minimum total cost of performing the given operation any number of
times such that `nums1[i] != nums2[i]` for all `0 <= i <= n - 1` after
performing all the operations.

Return the minimum total cost such that `nums1` and `nums2` satisfy the above
condition. In case it is not possible, return `-1`.

","def minimumTotalCost(self, nums1: List[int], nums2: List[int]) -> int:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def minimumTotalCost(self, nums1: List[int], nums2: List[int]) -> int:
    n = len(nums1)
    ans = 0
    maxFreq = 0
    maxFreqNum = 0
    shouldBeSwapped = 0
    conflictedNumCount = [0] * (n + 1)

    for i, (num1, num2) in enumerate(zip(nums1, nums2)):
      if num1 == num2:
        conflictedNum = num1
        conflictedNumCount[conflictedNum] += 1
        if conflictedNumCount[conflictedNum] > maxFreq:
          maxFreq = conflictedNumCount[conflictedNum]
          maxFreqNum = conflictedNum
        shouldBeSwapped += 1
        ans += i

    for i, (num1, num2) in enumerate(zip(nums1, nums2)):
      if maxFreq * 2 <= shouldBeSwapped:
        break
      if num1 == num2:
        continue

      if num1 == maxFreqNum or num2 == maxFreqNum:
        continue
      shouldBeSwapped += 1
      ans += i

    if maxFreq * 2 > shouldBeSwapped:
      return -1
    else:
      return ans
"
2983,"You are given a 0-indexed string `s` having an even length `n`.

You are also given a 0-indexed 2D integer array, `queries`, where `queries[i]
= [ai, bi, ci, di]`.

For each query `i`, you are allowed to perform the following operations:

* Rearrange the characters within the substring `s[ai:bi]`, where `0 <= ai <= bi < n / 2`.
* Rearrange the characters within the substring `s[ci:di]`, where `n / 2 <= ci <= di < n`.

For each query, your task is to determine whether it is possible to make `s` a
palindrome by performing the operations.

Each query is answered independently of the others.

Return a 0-indexed array `answer`, where `answer[i] == true` if it is possible
to make `s` a palindrome by performing operations specified by the `ith`
query, and `false` otherwise.

* A substring is a contiguous sequence of characters within a string.
* `s[x:y]` represents the substring consisting of characters from the index `x` to index `y` in `s`, both inclusive.

","def canMakePalindromeQueries(self, s: str, queries: List[List[int]]) -> List[bool]:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def canMakePalindromeQueries(self, s: str, queries: List[List[int]]) -> List[bool]:
    n = len(s)
    mirroredDiffs = self._getMirroredDiffs(s)
    counts = self._getCounts(s)
    ans = []

    def subtractArrays(a: List[int], b: List[int]):
      return [x - y for x, y in zip(a, b)]

    for a, b, c, d in queries:
      b += 1
      d += 1
      ra = n - a
      rb = n - b
      rc = n - c
      rd = n - d

      if (min(a, rd) > 0 and mirroredDiffs[min(a, rd)] > 0) or (n // 2 > max(b, rc) and mirroredDiffs[n // 2] - mirroredDiffs[max(b, rc)] > 0) or (rd > b and mirroredDiffs[rd] - mirroredDiffs[b] > 0) or (a > rc and mirroredDiffs[a] - mirroredDiffs[rc] > 0):
        ans.append(False)
      else:
        leftRangeCount = subtractArrays(counts[b], counts[a])
        rightRangeCount = subtractArrays(counts[d], counts[c])
        if a > rd:
          rightRangeCount = subtractArrays(
              rightRangeCount, subtractArrays(counts[min(a, rc)], counts[rd]))
        if rc > b:
          rightRangeCount = subtractArrays(
              rightRangeCount, subtractArrays(counts[rc], counts[max(b, rd)]))
        if c > rb:
          leftRangeCount = subtractArrays(
              leftRangeCount, subtractArrays(counts[min(c, ra)], counts[rb]))
        if ra > d:
          leftRangeCount = subtractArrays(
              leftRangeCount, subtractArrays(counts[ra], counts[max(d, rb)]))
        ans.append(min(leftRangeCount) >= 0
                   and min(rightRangeCount) >= 0
                   and leftRangeCount == rightRangeCount)

    return ans

  def _getMirroredDiffs(self, s: str) -> List[int]:
    diffs = [0]
    for i, j in zip(range(len(s)), reversed(range(len(s)))):
      if i >= j:
        break
      diffs.append(diffs[-1] + (s[i] != s[j]))
    return diffs

  def _getCounts(self, s: str) -> List[List[int]]:
    count = [0] * 26
    counts = [count.copy()]
    for c in s:
      count[ord(c) - ord('a')] += 1
      counts.append(count.copy())
    return counts
"
2904,"You are given a binary string `s` and a positive integer `k`.

A substring of `s` is beautiful if the number of `1`'s in it is exactly `k`.

Let `len` be the length of the shortest beautiful substring.

Return the lexicographically smallest beautiful substring of string `s` with
length equal to `len`. If `s` doesn't contain a beautiful substring, return an
empty string.

A string `a` is lexicographically larger than a string `b` (of the same
length) if in the first position where `a` and `b` differ, `a` has a character
strictly larger than the corresponding character in `b`.

* For example, `""abcd""` is lexicographically larger than `""abcc""` because the first position they differ is at the fourth character, and `d` is greater than `c`.

","def shortestBeautifulSubstring(self, s: str, k: int) -> str:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def shortestBeautifulSubstring(self, s: str, k: int) -> str:
    bestLeft = -1
    minLength = len(s) + 1
    ones = 0

    l = 0
    for r, c in enumerate(s):
      if c == '1':
        ones += 1
      while ones == k:
        if r - l + 1 < minLength:
          bestLeft = l
          minLength = r - l + 1
        elif r - l + 1 == minLength and s[l:l + minLength] < s[bestLeft:bestLeft + minLength]:
          bestLeft = l
        if s[l] == '1':
          ones -= 1
        l += 1

    if bestLeft == -1:
      return """"
    else:
      return s[bestLeft:bestLeft + minLength]
"
2911,"Given a string `s` and an integer `k`, partition `s` into `k` substrings such
that the letter changes needed to make each substring a semi-palindrome are
minimized.

Return the minimum number of letter changes required.

A semi-palindrome is a special type of string that can be divided into
palindromes based on a repeating pattern. To check if a string is a semi-
palindrome:​

1. Choose a positive divisor `d` of the string's length. `d` can range from `1` up to, but not including, the string's length. For a string of length `1`, it does not have a valid divisor as per this definition, since the only divisor is its length, which is not allowed.
2. For a given divisor `d`, divide the string into groups where each group contains characters from the string that follow a repeating pattern of length `d`. Specifically, the first group consists of characters at positions `1`, `1 + d`, `1 + 2d`, and so on; the second group includes characters at positions `2`, `2 + d`, `2 + 2d`, etc.
3. The string is considered a semi-palindrome if each of these groups forms a palindrome.

Consider the string `""abcabc""`:

* The length of `""abcabc""` is `6`. Valid divisors are `1`, `2`, and `3`.
* For `d = 1`: The entire string `""abcabc""` forms one group. Not a palindrome.
* For `d = 2`: 
* Group 1 (positions `1, 3, 5`): `""acb""`
* Group 2 (positions `2, 4, 6`): `""bac""`
* Neither group forms a palindrome.
* For `d = 3`: 
* Group 1 (positions `1, 4`): `""aa""`
* Group 2 (positions `2, 5`): `""bb""`
* Group 3 (positions `3, 6`): `""cc""`
* All groups form palindromes. Therefore, `""abcabc""` is a semi-palindrome.

","def minimumChanges(self, s: str, k: int) -> int:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def minimumChanges(self, s: str, k: int) -> int:
    n = len(s)
    factors = self._getFactors(n)
    cost = self._getCost(s, n, factors)
    dp = [[n] * (k + 1) for _ in range(n + 1)]

    dp[n][0] = 0

    for i in range(n - 1, -1, -1):
      for j in range(1, k + 1):
        for l in range(i + 1, n):
          dp[i][j] = min(dp[i][j], dp[l + 1][j - 1] + cost[i][l])

    return dp[0][k]

  def _getFactors(self, n: int) -> List[List[int]]:
    factors = [[1] for _ in range(n + 1)]
    for d in range(2, n):
      for i in range(d * 2, n + 1, d):
        factors[i].append(d)
    return factors

  def _getCost(self, s: str, n: int, factors: List[List[int]]) -> List[List[int]]:
    cost = [[0] * n for _ in range(n)]
    for i in range(n):
      for j in range(i + 1, n):
        length = j - i + 1
        minCost = length
        for d in factors[length]:
          minCost = min(minCost, self._getCostD(s, i, j, d))
        cost[i][j] = minCost
    return cost

  def _getCostD(self, s: str, i: int, j: int, d: int) -> int:
    cost = 0
    for offset in range(d):
      l = i + offset
      r = j - d + 1 + offset
      while l < r:
        if s[l] != s[r]:
          cost += 1
        l += d
        r -= d
    return cost
"
2932,"You are given a 0-indexed integer array `nums`. A pair of integers `x` and `y`
is called a strong pair if it satisfies the condition:

* `|x - y| <= min(x, y)`

You need to select two integers from `nums` such that they form a strong pair
and their bitwise `XOR` is the maximum among all strong pairs in the array.

Return the maximum `XOR` value out of all possible strong pairs in the array
`nums`.

Note that you can pick the same integer twice to form a pair.

",def __init__(self):,"import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator, Optional

class TrieNode:
  def __init__(self):
    self.children: List[Optional[TrieNode]] = [None] * 2
    self.min = math.inf
    self.max = -math.inf


class BitTrie:
  def __init__(self, maxBit: int):
    self.maxBit = maxBit
    self.root = TrieNode()

  def insert(self, num: int) -> None:
    node = self.root
    for i in range(self.maxBit, -1, -1):
      bit = num >> i & 1
      if not node.children[bit]:
        node.children[bit] = TrieNode()
      node = node.children[bit]
      node.min = min(node.min, num)
      node.max = max(node.max, num)

  def getMaxXor(self, x: int) -> int:
    maxXor = 0
    node = self.root
    for i in range(self.maxBit, -1, -1):
      bit = x >> i & 1
      toggleBit = bit ^ 1
      if node.children[toggleBit] and node.children[toggleBit].max > x and node.children[toggleBit].min <= 2 * x:
        maxXor = maxXor | 1 << i
        node = node.children[toggleBit]
      elif node.children[bit]:
        node = node.children[bit]
      else:
        return 0
    return maxXor


class Solution:
  def maximumStrongPairXor(self, nums: List[int]) -> int:
    maxNum = max(nums)
    maxBit = int(math.log2(maxNum))
    bitTrie = BitTrie(maxBit)

    for num in nums:
      bitTrie.insert(num)

    return max(bitTrie.getMaxXor(num) for num in nums)
"
2940,"You are given a 0-indexed array `heights` of positive integers, where
`heights[i]` represents the height of the `ith` building.

If a person is in building `i`, they can move to any other building `j` if and
only if `i < j` and `heights[i] < heights[j]`.

You are also given another array `queries` where `queries[i] = [ai, bi]`. On
the `ith` query, Alice is in building `ai` while Bob is in building `bi`.

Return an array `ans` where `ans[i]` is the index of the leftmost building
where Alice and Bob can meet on the `ith` query. If Alice and Bob cannot move
to a common building on query `i`, set `ans[i]` to `-1`.

","def __init__(self, queryIndex: int, a: int, b: int):","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class IndexedQuery:
  def __init__(self, queryIndex: int, a: int, b: int):
    self.queryIndex = queryIndex
    self.a = a
    self.b = b

  def __iter__(self):
    yield self.queryIndex
    yield self.a
    yield self.b


class Solution:
  def leftmostBuildingQueries(self, heights: List[int], queries: List[List[int]]) -> List[int]:
    ans = [-1] * len(queries)
    stack = []

    heightsIndex = len(heights) - 1
    for queryIndex, a, b in sorted([IndexedQuery(i, min(a, b), max(a, b)) for i, (a, b) in enumerate(queries)], key=lambda iq: -iq.b):
      if a == b or heights[a] < heights[b]:
        ans[queryIndex] = b
      else:
        while heightsIndex > b:
          while stack and heights[stack[-1]] <= heights[heightsIndex]:
            stack.pop()
          stack.append(heightsIndex)
          heightsIndex -= 1
        j = self._lastGreater(stack, a, heights)
        if j != -1:
          ans[queryIndex] = stack[j]

    return ans

  def _lastGreater(self, A: List[int], target: int, heights: List[int]):
    l = -1
    r = len(A) - 1
    while l < r:
      m = (l + r + 1) // 2
      if heights[A[m]] > heights[target]:
        l = m
      else:
        r = m - 1
    return l
"
2948,"You are given a 0-indexed array of positive integers `nums` and a positive
integer `limit`.

In one operation, you can choose any two indices `i` and `j` and swap
`nums[i]` and `nums[j]` if `|nums[i] - nums[j]| <= limit`.

Return the lexicographically smallest array that can be obtained by performing
the operation any number of times.

An array `a` is lexicographically smaller than an array `b` if in the first
position where `a` and `b` differ, array `a` has an element that is less than
the corresponding element in `b`. For example, the array `[2,10,3]` is
lexicographically smaller than the array `[10,2,3]` because they differ at
index `0` and `2 < 10`.

","def lexicographicallySmallestArray(self, nums: List[int], limit: int) -> List[int]:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def lexicographicallySmallestArray(self, nums: List[int], limit: int) -> List[int]:
    ans = [0] * len(nums)
    numAndIndexes = sorted([(num, i) for i, num in enumerate(nums)])
    numAndIndexesGroups: List[List[Tuple[int, int]]] = []

    for numAndIndex in numAndIndexes:
      if not numAndIndexesGroups or numAndIndex[0] - numAndIndexesGroups[-1][-1][0] > limit:
        numAndIndexesGroups.append([numAndIndex])
      else:
        numAndIndexesGroups[-1].append(numAndIndex)

    for numAndIndexesGroup in numAndIndexesGroups:
      sortedNums = [num for num, _ in numAndIndexesGroup]
      sortedIndices = sorted([index for _, index in numAndIndexesGroup])
      for num, index in zip(sortedNums, sortedIndices):
        ans[index] = num

    return ans
"
2953,"You are given a string `word` and an integer `k`.

A substring `s` of `word` is complete if:

* Each character in `s` occurs exactly `k` times.
* The difference between two adjacent characters is at most `2`. That is, for any two adjacent characters `c1` and `c2` in `s`, the absolute difference in their positions in the alphabet is at most `2`.

Return the number of complete substrings of `word`.

A substring is a non-empty contiguous sequence of characters in a string.

","def countCompleteSubstrings(self, word: str, k: int) -> int:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def countCompleteSubstrings(self, word: str, k: int) -> int:
    uniqueLetters = len(set(word))
    return sum(self._countCompleteStrings(word, k, windowSize) for windowSize in range(k, k * uniqueLetters + 1, k))

  def _countCompleteStrings(self, word: str, k: int, windowSize: int) -> int:
    res = 0
    countLetters = 0
    count = collections.Counter()

    for i, c in enumerate(word):
      count[c] += 1
      countLetters += 1
      if i > 0 and abs(ord(c) - ord(word[i - 1])) > 2:
        count = collections.Counter()
        count[c] += 1
        countLetters = 1
      if countLetters == windowSize + 1:
        count[word[i - windowSize]] -= 1
        countLetters -= 1
      if countLetters == windowSize:
        res += all(freq == 0 or freq == k for freq in count.values())

    return res
"
2959,"There is a company with `n` branches across the country, some of which are
connected by roads. Initially, all branches are reachable from each other by
traveling some roads.

The company has realized that they are spending an excessive amount of time
traveling between their branches. As a result, they have decided to close down
some of these branches (possibly none). However, they want to ensure that the
remaining branches have a distance of at most `maxDistance` from each other.

The distance between two branches is the minimum total traveled length needed
to reach one branch from another.

You are given integers `n`, `maxDistance`, and a 0-indexed 2D array `roads`,
where `roads[i] = [ui, vi, wi]` represents the undirected road between
branches `ui` and `vi` with length `wi`.

Return the number of possible sets of closing branches, so that any branch has
a distance of at most `maxDistance` from any other.

Note that, after closing a branch, the company will no longer have access to
any roads connected to it.

Note that, multiple roads are allowed.

","def numberOfSets(self, n: int, maxDistance: int, roads: List[List[int]]) -> int:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def numberOfSets(self, n: int, maxDistance: int, roads: List[List[int]]) -> int:
    return sum(self._floydWarshall(n, maxDistance, roads, mask) <= maxDistance for mask in range(1 << n))

  def _floydWarshall(self, n: int, maxDistanceThreshold: int, roads: List[List[int]], mask: int) -> List[List[int]]:
    maxDistance = 0
    dist = [[maxDistanceThreshold + 1] * n for _ in range(n)]

    for i in range(n):
      if mask >> i & 1:
        dist[i][i] = 0

    for u, v, w in roads:
      if mask >> u & 1 and mask >> v & 1:
        dist[u][v] = min(dist[u][v], w)
        dist[v][u] = min(dist[v][u], w)

    for k in range(n):
      if mask >> k & 1:
        for i in range(n):
          if mask >> i & 1:
            for j in range(n):
              if mask >> j & 1:
                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])

    for i in range(n):
      if mask >> i & 1:
        for j in range(i + 1, n):
          if mask >> j & 1:
            maxDistance = max(maxDistance, dist[i][j])

    return maxDistance
"
2973,"You are given an undirected tree with `n` nodes labeled from `0` to `n - 1`,
and rooted at node `0`. You are given a 2D integer array `edges` of length `n
- 1`, where `edges[i] = [ai, bi]` indicates that there is an edge between
nodes `ai` and `bi` in the tree.

You are also given a 0-indexed integer array `cost` of length `n`, where
`cost[i]` is the cost assigned to the `ith` node.

You need to place some coins on every node of the tree. The number of coins to
be placed at node `i` can be calculated as:

* If size of the subtree of node `i` is less than `3`, place `1` coin.
* Otherwise, place an amount of coins equal to the maximum product of cost values assigned to `3` distinct nodes in the subtree of node `i`. If this product is negative, place `0` coins.

Return an array `coin` of size `n` such that `coin[i]` is the number of coins
placed at node `i`.

","def __init__(self, cost: int):","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class ChildCost:
  def __init__(self, cost: int):
    self.numNodes = 1
    self.maxPosCosts = [cost] if cost > 0 else []
    self.minNegCosts = [cost] if cost < 0 else []

  def update(self, childCost: 'ChildCost') -> None:
    self.numNodes += childCost.numNodes
    self.maxPosCosts.extend(childCost.maxPosCosts)
    self.minNegCosts.extend(childCost.minNegCosts)
    self.maxPosCosts.sort(reverse=True)
    self.minNegCosts.sort()
    self.maxPosCosts = self.maxPosCosts[:3]
    self.minNegCosts = self.minNegCosts[:2]

  def maxProduct(self) -> int:
    if self.numNodes < 3:
      return 1
    if not self.maxPosCosts:
      return 0
    res = 0
    if len(self.maxPosCosts) == 3:
      res = self.maxPosCosts[0] * self.maxPosCosts[1] * self.maxPosCosts[2]
    if len(self.minNegCosts) == 2:
      res = max(res, self.minNegCosts[0] * self.minNegCosts[1] * self.maxPosCosts[0])
    return res


class Solution:
  def placedCoins(self, edges: List[List[int]], cost: List[int]) -> List[int]:
    n = len(cost)
    ans = [0] * n
    tree = [[] for _ in range(n)]

    for u, v in edges:
      tree[u].append(v)
      tree[v].append(u)

    def dfs(u: int, prev: int) -> None:
      res = ChildCost(cost[u])
      for v in tree[u]:
        if v != prev:
          res.update(dfs(v, u))
      ans[u] = res.maxProduct()
      return res

    dfs(0, -1)
    return ans
"
2976,"You are given two 0-indexed strings `source` and `target`, both of length `n`
and consisting of lowercase English letters. You are also given two 0-indexed
character arrays `original` and `changed`, and an integer array `cost`, where
`cost[i]` represents the cost of changing the character `original[i]` to the
character `changed[i]`.

You start with the string `source`. In one operation, you can pick a character
`x` from the string and change it to the character `y` at a cost of `z` if
there exists any index `j` such that `cost[j] == z`, `original[j] == x`, and
`changed[j] == y`.

Return the minimum cost to convert the string `source` to the string `target`
using any number of operations. If it is impossible to convert `source` to
`target`, return `-1`.

Note that there may exist indices `i`, `j` such that `original[j] ==
original[i]` and `changed[j] == changed[i]`.

","def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:
    ans = 0
    dist = [[math.inf] * 26 for _ in range(26)]

    for a, b, c in zip(original, changed, cost):
      u = ord(a) - ord('a')
      v = ord(b) - ord('a')
      dist[u][v] = min(dist[u][v], c)

    for k in range(26):
      for i in range(26):
        if dist[i][k] < math.inf:
          for j in range(26):
            if dist[k][j] < math.inf:
              dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])

    for s, t in zip(source, target):
      if s == t:
        continue
      u = ord(s) - ord('a')
      v = ord(t) - ord('a')
      if dist[u][v] == math.inf:
        return -1
      ans += dist[u][v]

    return ans
"
2977,"You are given two 0-indexed strings `source` and `target`, both of length `n`
and consisting of lowercase English characters. You are also given two
0-indexed string arrays `original` and `changed`, and an integer array `cost`,
where `cost[i]` represents the cost of converting the string `original[i]` to
the string `changed[i]`.

You start with the string `source`. In one operation, you can pick a substring
`x` from the string, and change it to `y` at a cost of `z` if there exists any
index `j` such that `cost[j] == z`, `original[j] == x`, and `changed[j] == y`.
You are allowed to do any number of operations, but any pair of operations
must satisfy either of these two conditions:

* The substrings picked in the operations are `source[a..b]` and `source[c..d]` with either `b < c` or `d < a`. In other words, the indices picked in both operations are disjoint.
* The substrings picked in the operations are `source[a..b]` and `source[c..d]` with `a == c` and `b == d`. In other words, the indices picked in both operations are identical.

Return the minimum cost to convert the string `source` to the string `target`
using any number of operations. If it is impossible to convert `source` to
`target`, return `-1`.

Note that there may exist indices `i`, `j` such that `original[j] ==
original[i]` and `changed[j] == changed[i]`.

","def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:
    subLengths = set(len(s) for s in original)
    subToId = self._getSubToId(original, changed)
    subCount = len(subToId)
    dist = [[math.inf for _ in range(subCount)] for _ in range(subCount)]
    dp = [math.inf for _ in range(len(source) + 1)]

    for a, b, c in zip(original, changed, cost):
      u = subToId[a]
      v = subToId[b]
      dist[u][v] = min(dist[u][v], c)

    for k in range(subCount):
      for i in range(subCount):
        if dist[i][k] < math.inf:
          for j in range(subCount):
            if dist[k][j] < math.inf:
              dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])

    dp[0] = 0

    for i, (s, t) in enumerate(zip(source, target)):
      if dp[i] == math.inf:
        continue
      if s == t:
        dp[i + 1] = min(dp[i + 1], dp[i])
      for subLength in subLengths:
        if i + subLength > len(source):
          continue
        subSource = source[i:i + subLength]
        subTarget = target[i:i + subLength]
        if subSource not in subToId or subTarget not in subToId:
          continue
        u = subToId[subSource]
        v = subToId[subTarget]
        if dist[u][v] != math.inf:
          dp[i + subLength] = min(dp[i + subLength], dp[i] + dist[u][v])

    if dp[len(source)] == math.inf:
      return -1
    else:
      return dp[len(source)]

  def _getSubToId(self, original: str, changed: str) -> Dict[str, int]:
    subToId = {}
    for s in original + changed:
      if s not in subToId:
        subToId[s] = len(subToId)
    return subToId
"
3001,"There is a 1-indexed `8 x 8` chessboard containing `3` pieces.

You are given `6` integers `a`, `b`, `c`, `d`, `e`, and `f` where:

* `(a, b)` denotes the position of the white rook.
* `(c, d)` denotes the position of the white bishop.
* `(e, f)` denotes the position of the black queen.

Given that you can only move the white pieces, return the minimum number of
moves required to capture the black queen.

Note that:

* Rooks can move any number of squares either vertically or horizontally, but cannot jump over other pieces.
* Bishops can move any number of squares diagonally, but cannot jump over other pieces.
* A rook or a bishop can capture the queen if it is located in a square that they can move to.
* The queen does not move.

","def minMovesToCaptureTheQueen(self, a: int, b: int, c: int, d: int, e: int, f: int) -> int:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def minMovesToCaptureTheQueen(self, a: int, b: int, c: int, d: int, e: int, f: int) -> int:
    if a == e:
      if c == a and (b < d < f or b > d > f):
        return 2
      else:
        return 1
    if b == f:
      if d == f and (a < c < e or a > c > e):
        return 2
      else:
        return 1
    if c + d == e + f:
      if a + b == c + d and (c < a < e or c > a > e):
        return 2
      else:
        return 1
    if c - d == e - f:
      if a - b == c - d and (c < a < e or c > a > e):
        return 2
      else:
        return 1
    return 2
"
2503,"You are given an `m x n` integer matrix `grid` and an array `queries` of size
`k`.

Find an array `answer` of size `k` such that for each integer `queries[i]` you
start in the top left cell of the matrix and repeat the following process:

* If `queries[i]` is strictly greater than the value of the current cell that you are in, then you get one point if it is your first time visiting this cell, and you can move to any adjacent cell in all `4` directions: up, down, left, and right.
* Otherwise, you do not get any points, and you end this process.

After the process, `answer[i]` is the maximum number of points you can get.
Note that for each query you are allowed to visit the same cell multiple
times.

Return the resulting array `answer`.

","def __init__(self, queryIndex: int, query: int):","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class IndexedQuery:
  def __init__(self, queryIndex: int, query: int):
    self.queryIndex = queryIndex
    self.query = query

  def __iter__(self):
    yield self.queryIndex
    yield self.query


class Solution:
  def maxPoints(self, grid: List[List[int]], queries: List[int]) -> List[int]:
    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))
    m = len(grid)
    n = len(grid[0])
    ans = [0] * len(queries)
    minHeap = [(grid[0][0], 0, 0)]
    seen = {(0, 0)}
    accumulate = 0

    for queryIndex, query in sorted([IndexedQuery(i, query) for i, query in enumerate(queries)], key=lambda iq: iq.query):
      while minHeap:
        val, i, j = heapq.heappop(minHeap)
        if val >= query:
          heapq.heappush(minHeap, (val, i, j))
          break
        accumulate += 1
        for dx, dy in dirs:
          x = i + dx
          y = j + dy
          if x < 0 or x == m or y < 0 or y == n:
            continue
          if (x, y) in seen:
            continue
          heapq.heappush(minHeap, (grid[x][y], x, y))
          seen.add((x, y))
      ans[queryIndex] = accumulate

    return ans
"
3006,"You are given a 0-indexed string `s`, a string `a`, a string `b`, and an
integer `k`.

An index `i` is beautiful if:

* `0 <= i <= s.length - a.length`
* `s[i..(i + a.length - 1)] == a`
* There exists an index `j` such that: 
* `0 <= j <= s.length - b.length`
* `s[j..(j + b.length - 1)] == b`
* `|j - i| <= k`

Return the array that contains beautiful indices in sorted order from smallest
to largest.

","def beautifulIndices(self, s: str, a: str, b: str, k: int) -> List[int]:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def beautifulIndices(self, s: str, a: str, b: str, k: int) -> List[int]:
    ans = []
    indicesA = self._kmp(s, a)
    indicesB = self._kmp(s, b)
    indicesBIndex = 0

    for i in indicesA:
      while indicesBIndex < len(indicesB) and indicesB[indicesBIndex] - i < -k:
        indicesBIndex += 1
      if indicesBIndex < len(indicesB) and indicesB[indicesBIndex] - i <= k:
        ans.append(i)

    return ans

  def _kmp(self, s: str, pattern: str) -> List[int]:
    def getLPS(pattern: str) -> List[int]:
      lps = [0] * len(pattern)
      j = 0
      for i in range(1, len(pattern)):
        while j > 0 and pattern[j] != pattern[i]:
          j = lps[j - 1]
        if pattern[i] == pattern[j]:
          lps[i] = j + 1
          j += 1
      return lps

    res = []
    lps = getLPS(pattern)
    i = 0
    j = 0
    while i < len(s):
      if s[i] == pattern[j]:
        i += 1
        j += 1
        if j == len(pattern):
          res.append(i - j)
          j = lps[j - 1]
      elif j != 0:
        j = lps[j - 1]
      else:
        i += 1
    return res
"
3029,"You are given a 0-indexed string `word` and an integer `k`.

At every second, you must perform the following operations:

* Remove the first `k` characters of `word`.
* Add any `k` characters to the end of `word`.

Note that you do not necessarily need to add the same characters that you
removed. However, you must perform both operations at every second.

Return the minimum time greater than zero required for `word` to revert to its
initial state.

","def minimumTimeToInitialState(self, word: str, k: int) -> int:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def minimumTimeToInitialState(self, word: str, k: int) -> int:
    n = len(word)
    maxOps = (n - 1) // k + 1
    z = self._zFunction(word)

    for ans in range(1, maxOps):
      if z[ans * k] >= n - ans * k:
        return ans

    return maxOps

  def _zFunction(self, s: str) -> List[int]:
    n = len(s)
    z = [0] * n
    l = 0
    r = 0
    for i in range(1, n):
      if i < r:
        z[i] = min(r - i, z[i - l])
      while i + z[i] < n and s[z[i]] == s[i + z[i]]:
        z[i] += 1
      if i + z[i] > r:
        l = i
        r = i + z[i]
    return z
"
3030,"You are given a 0-indexed `m x n` grid `image` which represents a grayscale
image, where `image[i][j]` represents a pixel with intensity in the
range`[0..255]`. You are also given a non-negative integer `threshold`.

Two pixels `image[a][b]` and `image[c][d]` are said to be adjacent if `|a - c|
+ |b - d| == 1`.

A region is a `3 x 3` subgrid where the absolute difference in intensity
between any two adjacent pixels is less than or equal to `threshold`.

All pixels in a region belong to that region, note that a pixel can belong to
multiple regions.

You need to calculate a 0-indexed `m x n` grid `result`, where `result[i][j]`
is the average intensity of the region to which `image[i][j]` belongs, rounded
down to the nearest integer. If `image[i][j]` belongs to multiple regions,
`result[i][j]` is the average of the rounded down average intensities of these
regions, rounded down to the nearest integer. If `image[i][j]` does not belong
to any region, `result[i][j]` is equal to `image[i][j]`.

Return the grid `result`.

","def resultGrid(self, image: List[List[int]], threshold: int) -> List[List[int]]:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def resultGrid(self, image: List[List[int]], threshold: int) -> List[List[int]]:
    m = len(image)
    n = len(image[0])
    sums = [[0] * n for _ in range(m)]
    counts = [[0] * n for _ in range(m)]

    for i in range(m - 2):
      for j in range(n - 2):
        if self._isRegion(image, i, j, threshold):
          subgridSum = sum(image[x][y] for x in range(i, i + 3) for y in range(j, j + 3))
          for x in range(i, i + 3):
            for y in range(j, j + 3):
              sums[x][y] += subgridSum // 9
              counts[x][y] += 1

    for i in range(m):
      for j in range(n):
        if counts[i][j] > 0:
          image[i][j] = sums[i][j] // counts[i][j]

    return image

  def _isRegion(self, image: List[List[int]], i: int, j: int, threshold: int) -> bool:
    for x in range(i, i + 3):
      for y in range(j, j + 3):
        if x > i and abs(image[x][y] - image[x - 1][y]) > threshold:
          return False
        if y > j and abs(image[x][y] - image[x][y - 1]) > threshold:
          return False
    return True
"
3043,"You are given two arrays with positive integers `arr1` and `arr2`.

A prefix of a positive integer is an integer formed by one or more of its
digits, starting from its leftmost digit. For example, `123` is a prefix of
the integer `12345`, while `234` is not.

A common prefix of two integers `a` and `b` is an integer `c`, such that `c`
is a prefix of both `a` and `b`. For example, `5655359` and `56554` have a
common prefix `565` while `1223` and `43456` do not have a common prefix.

You need to find the length of the longest common prefix between all pairs of
integers `(x, y)` such that `x` belongs to `arr1` and `y` belongs to `arr2`.

Return the length of the longest common prefix among all pairs. If no common
prefix exists among them, return `0`.

",def __init__(self):,"import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class TrieNode:
  def __init__(self):
    self.children: Dict[str, TrieNode] = {}


class Trie:
  def __init__(self):
    self.root = TrieNode()

  def insert(self, word: str) -> None:
    node: TrieNode = self.root
    for c in word:
      node = node.children.setdefault(c, TrieNode())
    node.isWord = True

  def search(self, word: str) -> int:
    prefixLength = 0
    node = self.root
    for c in word:
      if c not in node.children:
        break
      node = node.children[c]
      prefixLength += 1
    return prefixLength


class Solution:
  def longestCommonPrefix(self, arr1: List[int], arr2: List[int]) -> int:
    trie = Trie()

    for num in arr1:
      trie.insert(str(num))

    return max(trie.search(str(num)) for num in arr2)
"
3044,"You are given a `m x n` 0-indexed 2D matrix `mat`. From every cell, you can
create numbers in the following way:

* There could be at most `8` paths from the cells namely: east, south-east, south, south-west, west, north-west, north, and north-east.
* Select a path from them and append digits in this path to the number being formed by traveling in this direction.
* Note that numbers are generated at every step, for example, if the digits along the path are `1, 9, 1`, then there will be three numbers generated along the way: `1, 19, 191`.

Return the most frequent prime number greater than `10` out of all the numbers
created by traversing the matrix or `-1` if no such prime number exists. If
there are multiple prime numbers with the highest frequency, then return the
largest among them.

Note: It is invalid to change the direction during the move.

","def mostFrequentPrime(self, mat: List[List[int]]) -> int:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def mostFrequentPrime(self, mat: List[List[int]]) -> int:
    dirs = ((1, 0), (1, -1), (0, -1), (-1, -1),
            (-1, 0), (-1, 1), (0, 1), (1, 1))
    m = len(mat)
    n = len(mat[0])
    count = collections.Counter()

    def isPrime(num: int) -> bool:
      return not any(num % i == 0 for i in range(2, int(num**0.5 + 1)))

    for i in range(m):
      for j in range(n):
        for dx, dy in dirs:
          num = 0
          x = i
          y = j
          while 0 <= x < m and 0 <= y < n:
            num = num * 10 + mat[x][y]
            if num > 10 and isPrime(num):
              count[num] += 1
            x += dx
            y += dy

    if not count.items():
      return -1
    return max(count.items(), key=lambda x: (x[1], x[0]))[0]
"
3072,"You are given a 1-indexed array of integers `nums` of length `n`.

We define a function `greaterCount` such that `greaterCount(arr, val)` returns
the number of elements in `arr` that are strictly greater than `val`.

You need to distribute all the elements of `nums` between two arrays `arr1`
and `arr2` using `n` operations. In the first operation, append `nums[1]` to
`arr1`. In the second operation, append `nums[2]` to `arr2`. Afterwards, in
the `ith` operation:

* If `greaterCount(arr1, nums[i]) > greaterCount(arr2, nums[i])`, append `nums[i]` to `arr1`.
* If `greaterCount(arr1, nums[i]) < greaterCount(arr2, nums[i])`, append `nums[i]` to `arr2`.
* If `greaterCount(arr1, nums[i]) == greaterCount(arr2, nums[i])`, append `nums[i]` to the array with a lesser number of elements.
* If there is still a tie, append `nums[i]` to `arr1`.

The array `result` is formed by concatenating the arrays `arr1` and `arr2`.
For example, if `arr1 == [1,2,3]` and `arr2 == [4,5,6]`, then `result =
[1,2,3,4,5,6]`.

Return the integer array `result`.

","def __init__(self, n: int):","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class FenwickTree:
  def __init__(self, n: int):
    self.sums = [0] * (n + 1)

  def update(self, i: int, delta: int) -> None:
    while i < len(self.sums):
      self.sums[i] += delta
      i += FenwickTree.lowbit(i)

  def get(self, i: int) -> int:
    summ = 0
    while i > 0:
      summ += self.sums[i]
      i -= FenwickTree.lowbit(i)
    return summ

  @staticmethod
  def lowbit(i: int) -> int:
    return i & -i


class Solution:
  def resultArray(self, nums: List[int]) -> List[int]:
    arr1 = []
    arr2 = []
    ranks = self._getRanks(nums)
    tree1 = FenwickTree(len(ranks))
    tree2 = FenwickTree(len(ranks))

    def add(num: int, arr: List[int], tree: FenwickTree) -> None:
      arr.append(num)
      tree.update(ranks[num], 1)

    add(nums[0], arr1, tree1)
    add(nums[1], arr2, tree2)

    for i in range(2, len(nums)):
      greaterCount1 = len(arr1) - tree1.get(ranks[nums[i]])
      greaterCount2 = len(arr2) - tree2.get(ranks[nums[i]])
      if greaterCount1 > greaterCount2:
        add(nums[i], arr1, tree1)
      elif greaterCount1 < greaterCount2:
        add(nums[i], arr2, tree2)
      elif len(arr1) > len(arr2):
        add(nums[i], arr2, tree2)
      else:
        add(nums[i], arr1, tree1)

    return arr1 + arr2

  def _getRanks(self, nums: List[int]) -> Dict[int, int]:
    ranks = collections.Counter()
    rank = 0
    for num in sorted(set(nums)):
      rank += 1
      ranks[num] = rank
    return ranks
"
3095,"You are given an array `nums` of non-negative integers and an integer `k`.

An array is called special if the bitwise `OR` of all of its elements is at
least `k`.

Return the length of the shortest special non-empty subarray of `nums`, or
return `-1` if no special subarray exists.

","def minimumSubarrayLength(self, nums: List[int], k: int) -> int:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def minimumSubarrayLength(self, nums: List[int], k: int) -> int:
    ans = len(nums) + 1
    ors = 0
    count = collections.Counter()

    l = 0
    for r, num in enumerate(nums):
      ors = self._orNum(ors, num, count)
      while ors >= k and l <= r:
        ans = min(ans, r - l + 1)
        ors = self._undoOrNum(ors, nums[l], count)
        l += 1

    return -1 if ans == len(nums) + 1 else ans

  def _orNum(self, ors: int, num: int, count: Dict[int, int]) -> int:
    for i in range(30):
      if num >> i & 1:
        count[i] += 1
        if count[i] == 1:
          ors += 1 << i
    return ors

  def _undoOrNum(self, ors: int, num: int, count: Dict[int, int]) -> int:
    for i in range(30):
      if num >> i & 1:
        count[i] -= 1
        if count[i] == 0:
          ors -= 1 << i
    return ors
"
3102,"You are given a array `points` representing integer coordinates of some points
on a 2D plane, where `points[i] = [xi, yi]`.

The distance between two points is defined as their Manhattan distance.

Return the minimum possible value for maximum distance between any two points
by removing exactly one point.

","def minimumDistance(self, points: List[List[int]]) -> int:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def minimumDistance(self, points: List[List[int]]) -> int:
    i, j = self._maxManhattanDistance(points, -1)
    xi, yi = self._maxManhattanDistance(points, i)
    xj, yj = self._maxManhattanDistance(points, j)
    return min(self._manhattan(points, xi, yi), self._manhattan(points, xj, yj))

  def _maxManhattanDistance(self, points: List[List[int]], excludedIndex: int) -> int:
    minSum = math.inf
    maxSum = -math.inf
    minDiff = math.inf
    maxDiff = -math.inf
    minSumIndex = -1
    maxSumIndex = -1
    minDiffIndex = -1
    maxDiffIndex = -1

    for i, (x, y) in enumerate(points):
      if i == excludedIndex:
        continue
      summ = x + y
      diff = x - y
      if summ < minSum:
        minSum = summ
        minSumIndex = i
      if summ > maxSum:
        maxSum = summ
        maxSumIndex = i
      if diff < minDiff:
        minDiff = diff
        minDiffIndex = i
      if diff > maxDiff:
        maxDiff = diff
        maxDiffIndex = i

    if maxSum - minSum >= maxDiff - minDiff:
      return [minSumIndex, maxSumIndex]
    else:
      return [minDiffIndex, maxDiffIndex]

  def _manhattan(self, points: List[List[int]], i: int, j: int) -> int:
    return abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])
"
3108,"There is an undirected weighted graph with `n` vertices labeled from `0` to `n
- 1`.

You are given the integer `n` and an array `edges`, where `edges[i] = [ui, vi,
wi]` indicates that there is an edge between vertices `ui` and `vi` with a
weight of `wi`.

A walk on a graph is a sequence of vertices and edges. The walk starts and
ends with a vertex, and each edge connects the vertex that comes before it and
the vertex that comes after it. It's important to note that a walk may visit
the same edge or vertex more than once.

The cost of a walk starting at node `u` and ending at node `v` is defined as
the bitwise `AND` of the weights of the edges traversed during the walk. In
other words, if the sequence of edge weights encountered during the walk is
`w0, w1, w2, ..., wk`, then the cost is calculated as `w0 & w1 & w2 & ... &
wk`, where `&` denotes the bitwise `AND` operator.

You are also given a 2D array `query`, where `query[i] = [si, ti]`. For each
query, you need to find the minimum cost of the walk starting at vertex `si`
and ending at vertex `ti`. If there exists no such walk, the answer is `-1`.

Return the array `answer`, where `answer[i]` denotes the minimum cost of a
walk for query `i`.

","def __init__(self, n: int):","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class UnionFind:
  def __init__(self, n: int):
    self.id = list(range(n))
    self.rank = [0] * n
    self.weight = [(1 << 17) - 1] * n

  def unionByRank(self, u: int, v: int, w: int) -> None:
    i = self._find(u)
    j = self._find(v)
    newWeight = self.weight[i] & self.weight[j] & w
    self.weight[i] = newWeight
    self.weight[j] = newWeight
    if i == j:
      return
    if self.rank[i] < self.rank[j]:
      self.id[i] = j
    elif self.rank[i] > self.rank[j]:
      self.id[j] = i
    else:
      self.id[i] = j
      self.rank[j] += 1

  def getMinCost(self, u: int, v: int) -> int:
    if u == v:
      return 0
    i = self._find(u)
    j = self._find(v)
    if i == j:
      return self.weight[i]
    else:
      return -1

  def _find(self, u: int) -> int:
    if self.id[u] != u:
      self.id[u] = self._find(self.id[u])
    return self.id[u]


class Solution:
  def minimumCost(self, n: int, edges: List[List[int]], query: List[List[int]]) -> List[int]:
    uf = UnionFind(n)

    for u, v, w in edges:
      uf.unionByRank(u, v, w)

    return [uf.getMinCost(u, v) for u, v in query]
"
3112,"There is an undirected graph of `n` nodes. You are given a 2D array `edges`,
where `edges[i] = [ui, vi, lengthi]` describes an edge between node `ui` and
node `vi` with a traversal time of `lengthi` units.

Additionally, you are given an array `disappear`, where `disappear[i]` denotes
the time when the node `i` disappears from the graph and you won't be able to
visit it.

Notice that the graph might be disconnected and might contain multiple edges.

Return the array `answer`, with `answer[i]` denoting the minimum units of time
required to reach node `i` from node 0. If node `i` is unreachable from node 0
then `answer[i]` is `-1`.

","def minimumTime(self, n: int, edges: List[List[int]], disappear: List[int]) -> List[int]:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def minimumTime(self, n: int, edges: List[List[int]], disappear: List[int]) -> List[int]:
    graph = [[] for _ in range(n)]

    for u, v, w in edges:
      graph[u].append((v, w))
      graph[v].append((u, w))

    return self._dijkstra(graph, 0, disappear)

  def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, disappear: List[int]) -> List[int]:
    dist = [math.inf] * len(graph)

    dist[src] = 0
    minHeap = [(dist[src], src)]

    while minHeap:
      d, u = heapq.heappop(minHeap)
      if d > dist[u]:
        continue
      for v, w in graph[u]:
        if d + w < disappear[v] and d + w < dist[v]:
          dist[v] = d + w
          heapq.heappush(minHeap, (dist[v], v))

    res=[]
    for d in dist:
      if d != math.inf:
        res.append(d)
      else:
        res.append(-1)
    return res
"
2901,"You are given a string array `words`, and an array `groups`, both arrays
having length `n`.

The hamming distance between two strings of equal length is the number of
positions at which the corresponding characters are different.

You need to select the longest subsequence from an array of indices `[0, 1,
..., n - 1]`, such that for the subsequence denoted as `[i0, i1, ..., ik-1]`
having length `k`, the following holds:

* For adjacent indices in the subsequence, their corresponding groups are unequal, i.e., `groups[ij] != groups[ij+1]`, for each `j` where `0 < j + 1 < k`.
* `words[ij]` and `words[ij+1]` are equal in length, and the hamming distance between them is `1`, where `0 < j + 1 < k`, for all indices in the subsequence.

Return a string array containing the words corresponding to the indices (in
order) in the selected subsequence. If there are multiple answers, return any
of them.

Note: strings in `words` may be unequal in length.

","def getWordsInLongestSubsequence(self, words: List[str], groups: List[int]) -> List[str]:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def getWordsInLongestSubsequence(self, words: List[str], groups: List[int]) -> List[str]:
    ans = []
    n=len(words)
    dp = [1] * n
    prev = [-1] * n

    for i in range(1, n):
      for j in range(i):
        if groups[i] == groups[j]:
          continue
        if len(words[i]) != len(words[j]):
          continue
        if sum(a != b for a, b in zip(words[i], words[j])) != 1:
          continue
        if dp[i] < dp[j] + 1:
          dp[i] = dp[j] + 1
          prev[i] = j

    index = dp.index(max(dp))
    while index != -1:
      ans.append(words[index])
      index = prev[index]

    return ans[::-1]
"
2876,"There is a directed graph consisting of `n` nodes numbered from `0` to `n - 1`
and `n` directed edges.

You are given a 0-indexed array `edges` where `edges[i]` indicates that there
is an edge from node `i` to node `edges[i]`.

Consider the following process on the graph:

* You start from a node `x` and keep visiting other nodes through edges until you reach a node that you have already visited before on this same process.

Return an array `answer` where `answer[i]` is the number of different nodes
that you will visit if you perform the process starting from node `i`.

","def countVisitedNodes(self, edges: List[int]) -> List[int]:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def countVisitedNodes(self, edges: List[int]) -> List[int]:
    n = len(edges)
    ans = [0] * n
    inDegrees = [0] * n
    seen = [False] * n
    stack = []

    for v in edges:
      inDegrees[v] += 1

    q = collections.deque([i for i, d in enumerate(inDegrees) if d == 0])

    while q:
      u = q.popleft()
      inDegrees[edges[u]] -= 1
      if inDegrees[edges[u]] == 0:
        q.append(edges[u])
      stack.append(u)
      seen[u] = True

    for i in range(n):
      if not seen[i]:
        self._fillCycle(edges, i, seen, ans)

    while stack:
      u = stack.pop()
      ans[u] = ans[edges[u]] + 1

    return ans

  def _fillCycle(self, edges: List[int], start: int, seen: List[bool], ans: List[int]) -> None:
    cycleLength = 0
    u = start
    while not seen[u]:
      cycleLength += 1
      seen[u] = True
      u = edges[u]
    ans[start] = cycleLength
    u = edges[start]
    while u != start:
      ans[u] = cycleLength
      u = edges[u]
"
2851,"You are given two strings `s` and `t` of equal length `n`. You can perform the
following operation on the string `s`:

* Remove a suffix of `s` of length `l` where `0 < l < n` and append it at the start of `s`.  
For example, let `s = 'abcd'` then in one operation you can remove the suffix
`'cd'` and append it in front of `s` making `s = 'cdab'`.

You are also given an integer `k`. Return the number of ways in which `s` can
be transformed into `t` in exactly `k` operations.

Since the answer can be large, return it modulo `109 + 7`.

","def numberOfWays(self, s: str, t: str, k: int) -> int:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def numberOfWays(self, s: str, t: str, k: int) -> int:
    kMod = 1_000_000_007
    n = len(s)
    negOnePowK = 1 if k % 2 == 0 else -1  # (-1)^k
    z = self._zFunction(s + t + t)

    indices = [i - n for i in range(n, n + n) if z[i] >= n]
    dp = [0] * 2
    dp[1] = (pow(n - 1, k, kMod) - negOnePowK) * pow(n, kMod - 2, kMod)
    dp[0] = dp[1] + negOnePowK
    res = 0
    for index in indices:
      if index == 0:
        res += dp[0]
      else: 
        res += dp[1]
    return res % kMod


  def _zFunction(self, s: str) -> List[int]:
    n = len(s)
    z = [0] * n
    l = 0
    r = 0
    for i in range(1, n):
      if i < r:
        z[i] = min(r - i, z[i - l])
      while i + z[i] < n and s[z[i]] == s[i + z[i]]:
        z[i] += 1
      if i + z[i] > r:
        l = i
        r = i + z[i]
    return z
"
2850,"You are given a 0-indexed 2D integer matrix `grid` of size `3 * 3`,
representing the number of stones in each cell. The grid contains exactly `9`
stones, and there can be multiple stones in a single cell.

In one move, you can move a single stone from its current cell to any other
cell if the two cells share a side.

Return the minimum number of moves required to place one stone in each cell.

","def minimumMoves(self, grid: List[List[int]]) -> int:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def minimumMoves(self, grid: List[List[int]]) -> int:
    if sum(row.count(0) for row in grid) == 0:
      return 0

    ans = math.inf

    for i in range(3):
      for j in range(3):
        if grid[i][j] == 0:
          for x in range(3):
            for y in range(3):
              if grid[x][y] > 1:
                grid[x][y] -= 1
                grid[i][j] += 1
                ans = min(ans, abs(x - i) + abs(y - j) + self.minimumMoves(grid))
                grid[x][y] += 1
                grid[i][j] -= 1

    return ans
"
2508,"There is an undirected graph consisting of `n` nodes numbered from `1` to `n`.
You are given the integer `n` and a 2D array `edges` where `edges[i] = [ai,
bi]` indicates that there is an edge between nodes `ai` and `bi`. The graph
can be disconnected.

You can add at most two additional edges (possibly none) to this graph so that
there are no repeated edges and no self-loops.

Return `true` if it is possible to make the degree of each node in the graph
even, otherwise return `false`.

The degree of a node is the number of edges connected to it.

","def isPossible(self, n: int, edges: List[List[int]]) -> bool:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def isPossible(self, n: int, edges: List[List[int]]) -> bool:
    graph = [set() for _ in range(n)]

    for u, v in edges:
      graph[u - 1].add(v - 1)
      graph[v - 1].add(u - 1)

    oddNodes = [i for i, neighbor in enumerate(graph) if len(neighbor) & 1]
    if not oddNodes:
      return True
    if len(oddNodes) == 2:
      a, b = oddNodes
      return any(a not in graph[i] and b not in graph[i] for i in range(n))
    if len(oddNodes) == 4:
      a, b, c, d = oddNodes
      return (b not in graph[a] and d not in graph[c]) or (c not in graph[a] and d not in graph[b]) or (d not in graph[a] and c not in graph[b])
    return False
"
2523,"Given two positive integers `left` and `right`, find the two integers `num1`
and `num2` such that:

* `left <= num1 < num2 <= right `.
* `num1` and `num2` are both prime numbers.
* `num2 - num1` is the minimum amongst all other pairs satisfying the above conditions.

Return the positive integer array `ans = [num1, num2]`. If there are multiple
pairs satisfying these conditions, return the one with the minimum `num1`
value or `[-1, -1]` if such numbers do not exist.

A number greater than `1` is called prime if it is only divisible by `1` and
itself.

","def closestPrimes(self, left: int, right: int) -> List[int]:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def closestPrimes(self, left: int, right: int) -> List[int]:
    isPrime = self._sieveEratosthenes(right + 1)
    primes=[]
    for i in range(left, right+1):
      if isPrime[i]:
        primes.append(i)

    if len(primes) < 2:
      return [-1, -1]

    minDiff = math.inf
    num1 = -1
    num2 = -1

    for a, b in zip(primes, primes[1:]):
      diff = b - a
      if diff < minDiff:
        minDiff = diff
        num1 = a
        num2 = b

    return [num1, num2]

  def _sieveEratosthenes(self, n: int) -> List[bool]:
    isPrime = [True] * n
    isPrime[0] = False
    isPrime[1] = False
    for i in range(2, int(n**0.5) + 1):
      if isPrime[i]:
        for j in range(i * i, n, i):
          isPrime[j] = False
    return isPrime
"
1793,"You are given an array of integers `nums` (0-indexed) and an integer `k`.

The score of a subarray `(i, j)` is defined as `min(nums[i], nums[i+1], ...,
nums[j]) * (j - i + 1)`. A good subarray is a subarray where `i <= k <= j`.

Return the maximum possible score of a good subarray.

","def maximumScore(self, nums: List[int], k: int) -> int:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def maximumScore(self, nums: List[int], k: int) -> int:
    ans = 0
    stack = []

    for i in range(len(nums) + 1):
      while stack and (i == len(nums) or nums[stack[-1]] > nums[i]):
        h = nums[stack.pop()]
        w = i - stack[-1] - 1 if stack else i
        if (not stack or stack[-1] + 1 <= k) and i - 1 >= k:
          ans = max(ans, h * w)
      stack.append(i)

    return ans
"
2577,"You are given a `m x n` matrix `grid` consisting of non-negative integers
where `grid[row][col]` represents the minimum time required to be able to
visit the cell `(row, col)`, which means you can visit the cell `(row, col)`
only when the time you visit it is greater than or equal to `grid[row][col]`.

You are standing in the top-left cell of the matrix in the `0th` second, and
you must move to any adjacent cell in the four directions: up, down, left, and
right. Each move you make takes 1 second.

Return the minimum time required in which you can visit the bottom-right cell
of the matrix. If you cannot visit the bottom-right cell, then return `-1`.

","def minimumTime(self, grid: List[List[int]]) -> int:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def minimumTime(self, grid: List[List[int]]) -> int:
    if grid[0][1] > 1 and grid[1][0] > 1:
      return -1

    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))
    m = len(grid)
    n = len(grid[0])
    minHeap = [(0, 0, 0)]
    seen = {(0, 0)}

    while minHeap:
      time, i, j = heapq.heappop(minHeap)
      if i == m - 1 and j == n - 1:
        return time
      for dx, dy in dirs:
        x = i + dx
        y = j + dy
        if x < 0 or x == m or y < 0 or y == n:
          continue
        if (x, y) in seen:
          continue
        if (grid[x][y] - time) % 2 == 0:
          extraWait = 1
        else:
          extraWait = 0
        nextTime = max(time + 1, grid[x][y] + extraWait)
        heapq.heappush(minHeap, (nextTime, x, y))
        seen.add((x, y))
"
2601,"You are given a 0-indexed integer array `nums` of length `n`.

You can perform the following operation as many times as you want:

* Pick an index `i` that you haven’t picked before, and pick a prime `p` strictly less than `nums[i]`, then subtract `p` from `nums[i]`.

Return true if you can make `nums` a strictly increasing array using the above
operation and false otherwise.

A strictly increasing array is an array whose each element is strictly greater
than its preceding element.

","def primeSubOperation(self, nums: List[int]) -> bool:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def primeSubOperation(self, nums: List[int]) -> bool:
    kMax = 1000
    primes = self._sieveEratosthenes(kMax)

    prevNum = 0
    for num in nums:
      i = bisect.bisect_left(primes, num - prevNum)
      if i > 0:
        num -= primes[i - 1]
      if num <= prevNum:
        return False
      prevNum = num

    return True

  def _sieveEratosthenes(self, n: int) -> List[int]:
    isPrime = [True] * n
    isPrime[0] = False
    isPrime[1] = False
    for i in range(2, int(n**0.5) + 1):
      if isPrime[i]:
        for j in range(i * i, n, i):
          isPrime[j] = False
    return [i for i in range(n) if isPrime[i]]
"
2603,"There exists an undirected and unrooted tree with `n` nodes indexed from `0`
to `n - 1`. You are given an integer `n` and a 2D integer array edges of
length `n - 1`, where `edges[i] = [ai, bi]` indicates that there is an edge
between nodes `ai` and `bi` in the tree. You are also given an array `coins`
of size `n` where `coins[i]` can be either `0` or `1`, where `1` indicates the
presence of a coin in the vertex `i`.

Initially, you choose to start at any vertex in the tree. Then, you can
perform the following operations any number of times:

* Collect all the coins that are at a distance of at most `2` from the current vertex, or
* Move to any adjacent vertex in the tree.

Find the minimum number of edges you need to go through to collect all the
coins and go back to the initial vertex.

Note that if you pass an edge several times, you need to count it into the
answer several times.

","def collectTheCoins(self, coins: List[int], edges: List[List[int]]) -> int:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def collectTheCoins(self, coins: List[int], edges: List[List[int]]) -> int:
    n = len(coins)
    tree = [set() for _ in range(n)]
    leavesToBeRemoved = collections.deque()

    for u, v in edges:
      tree[u].add(v)
      tree[v].add(u)

    for u in range(n):
      while len(tree[u]) == 1 and coins[u] == 0:
        v = tree[u].pop()
        tree[v].remove(u)
        u = v
      if len(tree[u]) == 1:
        leavesToBeRemoved.append(u)

    for _ in range(2):
      for _ in range(len(leavesToBeRemoved)):
        u = leavesToBeRemoved.popleft()
        if tree[u]:
          v = tree[u].pop()
          tree[v].remove(u)
          if len(tree[v]) == 1:
            leavesToBeRemoved.append(v)

    return sum(len(children) for children in tree)
"
2663,"A string is beautiful if:

* It consists of the first `k` letters of the English lowercase alphabet.
* It does not contain any substring of length `2` or more which is a palindrome.

You are given a beautiful string `s` of length `n` and a positive integer `k`.

Return the lexicographically smallest string of length `n`, which is larger
than `s` and is beautiful. If there is no such string, return an empty string.

A string `a` is lexicographically larger than a string `b` (of the same
length) if in the first position where `a` and `b` differ, `a` has a character
strictly larger than the corresponding character in `b`.

* For example, `""abcd""` is lexicographically larger than `""abcc""` because the first position they differ is at the fourth character, and `d` is greater than `c`.

","def smallestBeautifulString(self, s: str, k: int) -> str:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def smallestBeautifulString(self, s: str, k: int) -> str:
    chars = list(s)

    for i in reversed(range(len(chars))):
      chars[i] = chr(ord(chars[i]) + 1)
      while self._containsPalindrome(chars, i):
        chars[i] = chr(ord(chars[i]) + 1)
      if chars[i] < chr(ord('a') + k):
        return self._changeSuffix(chars, i + 1)

    return ''

  def _containsPalindrome(self, chars: List[str], i: int) -> bool:
    return (i > 0 and chars[i] == chars[i - 1]) or (i > 1 and chars[i] == chars[i - 2])

  def _changeSuffix(self, chars: List[str], i: int) -> str:
    for j in range(i, len(chars)):
      chars[j] = 'a'
      while self._containsPalindrome(chars, j):
        chars[j] = chr(ord(chars[j]) + 1)
    return ''.join(chars)
"
2672,"There is a 0-indexed array `nums` of length `n`. Initially, all elements are
uncolored (has a value of `0`).

You are given a 2D integer array `queries` where `queries[i] = [indexi,
colori]`.

For each query, you color the index `indexi` with the color `colori` in the
array `nums`.

Return an array `answer` of the same length as `queries` where `answer[i]` is
the number of adjacent elements with the same color after the `ith` query.

More formally, `answer[i]` is the number of indices `j`, such that `0 <= j < n
- 1` and `nums[j] == nums[j + 1]` and `nums[j] != 0` after the `ith` query.

","def colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:
    ans = []
    arr = [0] * n
    sameColors = 0

    for i, color in queries:
      if i + 1 < n:
        if arr[i + 1] > 0 and arr[i + 1] == arr[i]:
          sameColors -= 1
        if arr[i + 1] == color:
          sameColors += 1
      if i > 0:
        if arr[i - 1] > 0 and arr[i - 1] == arr[i]:
          sameColors -= 1
        if arr[i - 1] == color:
          sameColors += 1
      arr[i] = color
      ans.append(sameColors)

    return ans
"
2684,"You are given a 0-indexed `m x n` matrix `grid` consisting of positive
integers.

You can start at any cell in the first column of the matrix, and traverse the
grid in the following way:

* From a cell `(row, col)`, you can move to any of the cells: `(row - 1, col + 1)`, `(row, col + 1)` and `(row + 1, col + 1)` such that the value of the cell you move to, should be strictly bigger than the value of the current cell.

Return the maximum number of moves that you can perform.

","def maxMoves(self, grid: List[List[int]]) -> int:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def maxMoves(self, grid: List[List[int]]) -> int:
    m = len(grid)
    n = len(grid[0])
    dp = [[0] * n for _ in range(m)]

    for j in range(n - 2, -1, -1):
      for i in range(m):
        if grid[i][j + 1] > grid[i][j]:
          dp[i][j] = 1 + dp[i][j + 1]
        if i > 0 and grid[i - 1][j + 1] > grid[i][j]:
          dp[i][j] = max(dp[i][j], 1 + dp[i - 1][j + 1])
        if i + 1 < m and grid[i + 1][j + 1] > grid[i][j]:
          dp[i][j] = max(dp[i][j], 1 + dp[i + 1][j + 1])

    return max(dp[i][0] for i in range(m))
"
2685,"You are given an integer `n`. There is an undirected graph with `n` vertices,
numbered from `0` to `n - 1`. You are given a 2D integer array `edges` where
`edges[i] = [ai, bi]` denotes that there exists an undirected edge connecting
vertices `ai` and `bi`.

Return the number of complete connected components of the graph.

A connected component is a subgraph of a graph in which there exists a path
between any two vertices, and no vertex of the subgraph shares an edge with a
vertex outside of the subgraph.

A connected component is said to be complete if there exists an edge between
every pair of its vertices.

","def __init__(self, n: int):","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class UnionFind:
  def __init__(self, n: int):
    self.id = list(range(n))
    self.rank = [0] * n
    self.nodeCount = [1] * n
    self.edgeCount = [0] * n

  def unionByRank(self, u: int, v: int) -> None:
    i = self.find(u)
    j = self.find(v)
    self.edgeCount[i] += 1
    if i == j:
      return
    if self.rank[i] < self.rank[j]:
      self.id[i] = j
      self.edgeCount[j] += self.edgeCount[i]
      self.nodeCount[j] += self.nodeCount[i]
    elif self.rank[i] > self.rank[j]:
      self.id[j] = i
      self.edgeCount[i] += self.edgeCount[j]
      self.nodeCount[i] += self.nodeCount[j]
    else:
      self.id[i] = j
      self.edgeCount[j] += self.edgeCount[i]
      self.nodeCount[j] += self.nodeCount[i]
      self.rank[j] += 1

  def find(self, u: int) -> int:
    if self.id[u] != u:
      self.id[u] = self.find(self.id[u])
    return self.id[u]

  def isComplete(self, u):
    return self.nodeCount[u] * (self.nodeCount[u] - 1) // 2 == self.edgeCount[u]


class Solution:
  def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:
    ans = 0
    uf = UnionFind(n)
    parents = set()

    for u, v in edges:
      uf.unionByRank(u, v)

    for i in range(n):
      parent = uf.find(i)
      if parent not in parents and uf.isComplete(parent):
        ans += 1
        parents.add(parent)

    return ans
"
2699,"You are given an undirected weighted connected graph containing `n` nodes
labeled from `0` to `n - 1`, and an integer array `edges` where `edges[i] =
[ai, bi, wi]` indicates that there is an edge between nodes `ai` and `bi` with
weight `wi`.

Some edges have a weight of `-1` (`wi = -1`), while others have a positive
weight (`wi > 0`).

Your task is to modify all edges with a weight of `-1` by assigning them
positive integer values in the range `[1, 2 * 109]` so that the shortest
distance between the nodes `source` and `destination` becomes equal to an
integer `target`. If there are multiple modifications that make the shortest
distance between `source` and `destination` equal to `target`, any of them
will be considered correct.

Return an array containing all edges (even unmodified ones) in any order if it
is possible to make the shortest distance from `source` to `destination` equal
to `target`, or an empty array if it's impossible.

Note: You are not allowed to modify the weights of edges with initial positive
weights.

","def modifiedGraphEdges(self, n: int, edges: List[List[int]], source: int, destination: int, target: int) -> List[List[int]]:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator


class Solution:
  def modifiedGraphEdges(self, n: int, edges: List[List[int]], source: int, destination: int, target: int) -> List[List[int]]:
    kMax = 2_000_000_000
    graph = [[] for _ in range(n)]

    for u, v, w in edges:
      if w == -1:
        continue
      graph[u].append((v, w))
      graph[v].append((u, w))

    distToDestination = self._dijkstra(graph, source, destination)
    if distToDestination < target:
      return []
    if distToDestination == target:
      for edge in edges:
        if edge[2] == -1:
          edge[2] = kMax
      return edges

    for i, (u, v, w) in enumerate(edges):
      if w != -1:
        continue
      edges[i][2] = 1
      graph[u].append((v, 1))
      graph[v].append((u, 1))
      distToDestination = self._dijkstra(graph, source, destination)
      if distToDestination <= target:
        edges[i][2] += target - distToDestination
        for j in range(i + 1, len(edges)):
          if edges[j][2] == -1:
            edges[j][2] = kMax
        return edges

    return []

  def _dijkstra(self, graph: List[List[int]], src: int, dst: int) -> int:
    dist = [math.inf] * len(graph)
    minHeap = []
    dist[src] = 0
    heapq.heappush(minHeap, (dist[src], src))

    while minHeap:
      d, u = heapq.heappop(minHeap)
      if d > dist[u]:
        continue
      for v, w in graph[u]:
        if d + w < dist[v]:
          dist[v] = d + w
          heapq.heappush(minHeap, (dist[v], v))

    return dist[dst]
"
2708,"You are given a 0-indexed integer array `nums` representing the score of
students in an exam. The teacher would like to form one non-empty group of
students with maximal strength, where the strength of a group of students of
indices `i0`, `i1`, `i2`, ... , `ik` is defined as `nums[i0] * nums[i1] *
nums[i2] * ... * nums[ik​]`.

Return the maximum strength of a group the teacher can create.

","def maxStrength(self, nums: List[int]) -> int:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def maxStrength(self, nums: List[int]) -> int:
    posProd = 1
    negProd = 1
    maxNeg = -math.inf
    negCount = 0
    hasPos = False
    hasZero = False

    for num in nums:
      if num > 0:
        posProd *= num
        hasPos = True
      elif num < 0:
        negProd *= num
        maxNeg = max(maxNeg, num)
        negCount += 1
      else:
        hasZero = True

    if negCount == 0 and not hasPos:
      return 0
    if negCount % 2 == 0:
      return negProd * posProd
    if negCount >= 3:
      return negProd // maxNeg * posProd
    if hasPos:
      return posProd
    if hasZero:
      return 0
    return maxNeg
"
2709,"You are given a 0-indexed integer array `nums`, and you are allowed to
traverse between its indices. You can traverse between index `i` and index
`j`, `i != j`, if and only if `gcd(nums[i], nums[j]) > 1`, where `gcd` is the
greatest common divisor.

Your task is to determine if for every pair of indices `i` and `j` in nums,
where `i < j`, there exists a sequence of traversals that can take us from `i`
to `j`.

Return `true` if it is possible to traverse between all such pairs of indices,
or `false` otherwise.

","def __init__(self, n: int):","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class UnionFind:
  def __init__(self, n: int):
    self.id = list(range(n))
    self.sz = [1] * n

  def unionBySize(self, u: int, v: int) -> None:
    i = self._find(u)
    j = self._find(v)
    if i == j:
      return
    if self.sz[i] < self.sz[j]:
      self.sz[j] += self.sz[i]
      self.id[i] = j
    else:
      self.sz[i] += self.sz[j]
      self.id[j] = i

  def getSize(self, i: int) -> int:
    return self.sz[i]

  def _find(self, u: int) -> int:
    if self.id[u] != u:
      self.id[u] = self._find(self.id[u])
    return self.id[u]


class Solution:
  def canTraverseAllPairs(self, nums: List[int]) -> bool:
    n = len(nums)
    max_num = max(nums)
    maxPrimeFactor = self._sieveEratosthenes(max_num + 1)
    primeToFirstIndex = collections.defaultdict(int)
    uf = UnionFind(n)

    for i, num in enumerate(nums):
      for prime_factor in self._getPrimeFactors(num, maxPrimeFactor):
        if prime_factor in primeToFirstIndex:
          uf.unionBySize(primeToFirstIndex[prime_factor], i)
        else:
          primeToFirstIndex[prime_factor] = i

    return any(uf.getSize(i) == n for i in range(n))

  def _sieveEratosthenes(self, n: int) -> List[int]:
    minPrimeFactors = [i for i in range(n + 1)]
    for i in range(2, int(n**0.5) + 1):
      if minPrimeFactors[i] == i:
        for j in range(i * i, n, i):
          minPrimeFactors[j] = min(minPrimeFactors[j], i)
    return minPrimeFactors

  def _getPrimeFactors(self, num: int, minPrimeFactors: List[int]) -> List[int]:
    primeFactors = []
    while num > 1:
      divisor = minPrimeFactors[num]
      primeFactors.append(divisor)
      while num % divisor == 0:
        num //= divisor
    return primeFactors
"
2736,"You are given two 0-indexed integer arrays `nums1` and `nums2`, each of length
`n`, and a 1-indexed 2D array `queries` where `queries[i] = [xi, yi]`.

For the `ith` query, find the maximum value of `nums1[j] + nums2[j]` among all
indices `j` `(0 <= j < n)`, where `nums1[j] >= xi` and `nums2[j] >= yi`, or -1
if there is no `j` satisfying the constraints.

Return an array `answer` where `answer[i]` is the answer to the `ith` query.

","def __init__(self, x: int, y: int):","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Pair:
  def __init__(self, x: int, y: int):
    self.x = x
    self.y = y

  def __iter__(self):
    yield self.x
    yield self.y


class IndexedQuery:
  def __init__(self, queryIndex: int, minX: int, minY: int):
    self.queryIndex = queryIndex
    self.minX = minX
    self.minY = minY

  def __iter__(self):
    yield self.queryIndex
    yield self.minX
    yield self.minY


class Solution:
  def maximumSumQueries(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:
    pairs = sorted([Pair(nums1[i], nums2[i])
                   for i in range(len(nums1))], key=lambda p: p.x, reverse=True)
    ans = [0] * len(queries)
    stack = []  # [(y, x + y)]

    pairsIndex = 0
    for queryIndex, minX, minY in sorted([IndexedQuery(i, query[0], query[1]) for i, query in enumerate(queries)], key=lambda iq: -iq.minX):
      while pairsIndex < len(pairs) and pairs[pairsIndex].x >= minX:
        x, y = pairs[pairsIndex]
        while stack and x + y >= stack[-1][1]:
          stack.pop()
        if not stack or y > stack[-1][0]:
          stack.append((y, x + y))
        pairsIndex += 1
      j = self._firstGreaterEqual(stack, minY)
      if j == len(stack):
        ans[queryIndex] = -1
      else:
        ans[queryIndex] = stack[j][1]

    return ans

  def _firstGreaterEqual(self, A: List[Tuple[int, int]], target: int) -> int:
    l = 0
    r = len(A)
    while l < r:
      m = (l + r) // 2
      if A[m][0] >= target:
        r = m
      else:
        l = m + 1
    return l
"
2747,"You are given an integer `n` denoting the total number of servers and a 2D
0-indexed integer array `logs`, where `logs[i] = [server_id, time]` denotes
that the server with id `server_id` received a request at time `time`.

You are also given an integer `x` and a 0-indexed integer array `queries`.

Return a 0-indexed integer array `arr` of length `queries.length` where
`arr[i]` represents the number of servers that did not receive any requests
during the time interval `[queries[i] - x, queries[i]]`.

Note that the time intervals are inclusive.

","def __init__(self, queryIndex: int, query: int):","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class IndexedQuery:
  def __init__(self, queryIndex: int, query: int):
    self.queryIndex = queryIndex
    self.query = query

  def __iter__(self):
    yield self.queryIndex
    yield self.query


class Solution:
  def countServers(self, n: int, logs: List[List[int]], x: int, queries: List[int]) -> List[int]:
    ans = [0] * len(queries)
    count = [0] * (n + 1)

    logs.sort(key=lambda log: log[1])

    i = 0
    j = 0
    servers = 0

    for queryIndex, query in sorted([IndexedQuery(i, query) for i, query in enumerate(queries)], key=lambda iq: iq.query):
      while j < len(logs) and logs[j][1] <= query:
        count[logs[j][0]] += 1
        if count[logs[j][0]] == 1:
          servers += 1
        j += 1
      while i < len(logs) and logs[i][1] < query - x:
        count[logs[i][0]] -= 1
        if count[logs[i][0]] == 0:
          servers -= 1
        i += 1
      ans[queryIndex] = n - servers

    return ans
"
2751,"There are `n` 1-indexed robots, each having a position on a line, health, and
movement direction.

You are given 0-indexed integer arrays `positions`, `healths`, and a string
`directions` (`directions[i]` is either 'L' for left or 'R' for right). All
integers in `positions` are unique.

All robots start moving on the line simultaneously at the same speed in their
given directions. If two robots ever share the same position while moving,
they will collide.

If two robots collide, the robot with lower health is removed from the line,
and the health of the other robot decreases by one. The surviving robot
continues in the same direction it was going. If both robots have the same
health, they are both removed from the line.

Your task is to determine the health of the robots that survive the
collisions, in the same order that the robots were given, i.e. final heath of
robot 1 (if survived), final health of robot 2 (if survived), and so on. If
there are no survivors, return an empty array.

Return an array containing the health of the remaining robots (in the order
they were given in the input), after no further collisions can occur.

Note: The positions may be unsorted.

","def survivedRobotsHealths(self, positions: List[int], healths: List[int], directions: str) -> List[int]:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator
from dataclasses import dataclass

@dataclass
class Robot:
  index: int
  position: int
  health: int
  direction: str


class Solution:
  def survivedRobotsHealths(self, positions: List[int], healths: List[int], directions: str) -> List[int]:
    robots = sorted([Robot(index, position, health, direction) for index, (position, health, direction) in enumerate(zip(positions, healths, directions))], key=lambda robot: robot.position)
    stack: List[Robot] = []

    for robot in robots:
      if robot.direction == 'R':
        stack.append(robot)
        continue
      while stack and stack[-1].direction == 'R' and robot.health > 0:
        if stack[-1].health == robot.health:
          stack.pop()
          robot.health = 0
        elif stack[-1].health < robot.health:
          stack.pop()
          robot.health -= 1
        else:
          stack[-1].health -= 1
          robot.health = 0
      if robot.health > 0:
        stack.append(robot)

    stack.sort(key=lambda robot: robot.index)
    return [robot.health for robot in stack]
"
2812,"You are given a 0-indexed 2D matrix `grid` of size `n x n`, where `(r, c)`
represents:

* A cell containing a thief if `grid[r][c] = 1`
* An empty cell if `grid[r][c] = 0`

You are initially positioned at cell `(0, 0)`. In one move, you can move to
any adjacent cell in the grid, including cells containing thieves.

The safeness factor of a path on the grid is defined as the minimum manhattan
distance from any cell in the path to any thief in the grid.

Return the maximum safeness factor of all paths leading to cell `(n - 1, n -
1)`.

An adjacent cell of cell `(r, c)`, is one of the cells `(r, c + 1)`, `(r, c -
1)`, `(r + 1, c)` and `(r - 1, c)` if it exists.

The Manhattan distance between two cells `(a, b)` and `(x, y)` is equal to `|a
- x| + |b - y|`, where `|val|` denotes the absolute value of val.

","def maximumSafenessFactor(self, grid: List[List[int]]) -> int:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def maximumSafenessFactor(self, grid: List[List[int]]) -> int:
    self.dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))
    n = len(grid)
    distToThief = self._getDistToThief(grid)

    def hasValidPath(safeness: int) -> bool:
      if distToThief[0][0] < safeness:
        return False

      q = collections.deque([(0, 0)])
      seen = {(0, 0)}

      while q:
        i, j = q.popleft()
        if distToThief[i][j] < safeness:
          continue
        if i == n - 1 and j == n - 1:
          return True
        for dx, dy in self.dirs:
          x = i + dx
          y = j + dy
          if x < 0 or x == n or y < 0 or y == n:
            continue
          if (x, y) in seen:
            continue
          q.append((x, y))
          seen.add((x, y))

      return False

    return bisect.bisect_left(range(n * 2), True, key=lambda m: not hasValidPath(m)) - 1

  def _getDistToThief(self, grid: List[List[int]]) -> List[List[int]]:
    n = len(grid)
    distToThief = [[0] * n for _ in range(n)]
    q = collections.deque()
    seen = set()

    for i in range(n):
      for j in range(n):
        if grid[i][j] == 1:
          q.append((i, j))
          seen.add((i, j))

    dist = 0
    while q:
      for _ in range(len(q)):
        i, j = q.popleft()
        distToThief[i][j] = dist
        for dx, dy in self.dirs:
          x = i + dx
          y = j + dy
          if x < 0 or x == n or y < 0 or y == n:
            continue
          if (x, y) in seen:
            continue
          q.append((x, y))
          seen.add((x, y))
      dist += 1

    return distToThief
"
2818,"You are given an array `nums` of `n` positive integers and an integer `k`.

Initially, you start with a score of `1`. You have to maximize your score by
applying the following operation at most `k` times:

* Choose any non-empty subarray `nums[l, ..., r]` that you haven't chosen previously.
* Choose an element `x` of `nums[l, ..., r]` with the highest prime score. If multiple such elements exist, choose the one with the smallest index.
* Multiply your score by `x`.

Here, `nums[l, ..., r]` denotes the subarray of `nums` starting at index `l`
and ending at the index `r`, both ends being inclusive.

The prime score of an integer `x` is equal to the number of distinct prime
factors of `x`. For example, the prime score of `300` is `3` since `300 = 2 *
2 * 3 * 5 * 5`.

Return the maximum possible score after applying at most `k` operations.

Since the answer may be large, return it modulo `109 + 7`.

","def maximumScore(self, nums: List[int], k: int) -> int:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def maximumScore(self, nums: List[int], k: int) -> int:
    kMod = 1_000_000_007
    n = len(nums)
    ans = 1
    minPrimeFactors = self._sieveEratosthenes(max(nums) + 1)
    primeScores = [self._getPrimeScore(num, minPrimeFactors) for num in nums]
    left = [-1] * n
    right = [n] * n
    stack = []

    for i in reversed(range(n)):
      while stack and primeScores[stack[-1]] <= primeScores[i]:
        left[stack.pop()] = i
      stack.append(i)

    stack = []

    for i in range(n):
      while stack and primeScores[stack[-1]] < primeScores[i]:
        right[stack.pop()] = i
      stack.append(i)

    numAndIndexes = [(num, i) for i, num in enumerate(nums)]

    def modPow(x: int, n: int) -> int:
      if n == 0:
        return 1
      if n & 1:
        return x * modPow(x, n - 1) % kMod
      return modPow(x * x % kMod, n // 2)

    for num, i in sorted(numAndIndexes, key=lambda x: (-x[0], x[1])):
      rangeCount = (i - left[i]) * (right[i] - i)
      actualCount = min(rangeCount, k)
      k -= actualCount
      ans *= modPow(num, actualCount)
      ans %= kMod

    return ans

  def _sieveEratosthenes(self, n: int) -> List[int]:
    minPrimeFactors = [i for i in range(n + 1)]
    for i in range(2, int(n**0.5) + 1):
      if minPrimeFactors[i] == i:
        for j in range(i * i, n, i):
          minPrimeFactors[j] = min(minPrimeFactors[j], i)
    return minPrimeFactors

  def _getPrimeScore(self, num: int, minPrimeFactors: List[int]) -> int:
    primeFactors = set()
    while num > 1:
      divisor = minPrimeFactors[num]
      primeFactors.add(divisor)
      while num % divisor == 0:
        num //= divisor
    return len(primeFactors)
"
2836,"You are given an integer array `receiver` of length `n` and an integer `k`.
`n` players are playing a ball-passing game.

You choose the starting player, `i`. The game proceeds as follows: player `i`
passes the ball to player `receiver[i]`, who then passes it to
`receiver[receiver[i]]`, and so on, for `k` passes in total. The game's score
is the sum of the indices of the players who touched the ball, including
repetitions, i.e. `i + receiver[i] + receiver[receiver[i]] + ... +
receiver(k)[i]`.

Return the maximum possible score.

Notes:

* `receiver` may contain duplicates.
* `receiver[i]` may be equal to `i`.

","def getMaxFunctionValue(self, receiver: List[int], k: int) -> int:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def getMaxFunctionValue(self, receiver: List[int], k: int) -> int:
    n = len(receiver)
    m = int(math.log2(k)) + 1
    ans = 0
    jump = [[0] * m for _ in range(n)]
    summ = [[0] * m for _ in range(n)]

    for i in range(n):
      jump[i][0] = receiver[i]
      summ[i][0] = receiver[i]

    for j in range(1, m):
      for i in range(n):
        midNode = jump[i][j - 1]
        jump[i][j] = jump[midNode][j - 1]
        summ[i][j] = summ[i][j - 1] + summ[midNode][j - 1]

    for i in range(n):
      currSum = i
      currPos = i
      for j in range(m):
        if (k >> j) & 1 == 1:
          currSum += summ[currPos][j]
          currPos = jump[currPos][j]
      ans = max(ans, currSum)

    return ans
"
2844,"You are given a 0-indexed string `num` representing a non-negative integer.

In one operation, you can pick any digit of `num` and delete it. Note that if
you delete all the digits of `num`, `num` becomes `0`.

Return the minimum number of operations required to make `num` special.

An integer `x` is considered special if it is divisible by `25`.

","def minimumOperations(self, num: str) -> int:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def minimumOperations(self, num: str) -> int:
    n = len(num)
    seenFive = False
    seenZero = False

    for i in range(n - 1, -1, -1):
      if seenZero and num[i] == '0':
        return n - i - 2
      if seenZero and num[i] == '5':
        return n - i - 2
      if seenFive and num[i] == '2':
        return n - i - 2
      if seenFive and num[i] == '7':
        return n - i - 2
      seenZero = seenZero or num[i] == '0'
      seenFive = seenFive or num[i] == '5'

    if seenZero:
      return n - 1
    else:
      return n
"
2846,"There is an undirected tree with `n` nodes labeled from `0` to `n - 1`. You
are given the integer `n` and a 2D integer array `edges` of length `n - 1`,
where `edges[i] = [ui, vi, wi]` indicates that there is an edge between nodes
`ui` and `vi` with weight `wi` in the tree.

You are also given a 2D integer array `queries` of length `m`, where
`queries[i] = [ai, bi]`. For each query, find the minimum number of operations
required to make the weight of every edge on the path from `ai` to `bi` equal.
In one operation, you can choose any edge of the tree and change its weight to
any value.

Note that:

* Queries are independent of each other, meaning that the tree returns to its initial state on each new query.
* The path from `ai` to `bi` is a sequence of distinct nodes starting with node `ai` and ending with node `bi` such that every two adjacent nodes in the sequence share an edge in the tree.

Return an array `answer` of length `m` where `answer[i]` is the answer to the
`ith` query.

","def minOperationsQueries(self, n: int, edges: List[List[int]], queries: List[List[int]]) -> List[int]:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def minOperationsQueries(self, n: int, edges: List[List[int]], queries: List[List[int]]) -> List[int]:
    kMax = 26
    m = int(math.log2(n)) + 1
    ans = []
    graph = [[] for _ in range(n)]
    jump = [[0] * m for _ in range(n)]
    count = [[] for _ in range(n)]
    depth = [0] * n

    for u, v, w in edges:
      graph[u].append((v, w))
      graph[v].append((u, w))

    def dfs(u: int, prev: int, d: int):
      if prev != -1:
        jump[u][0] = prev
      depth[u] = d
      for v, w in graph[u]:
        if v == prev:
          continue
        count[v] = count[u][:]
        count[v][w] += 1
        dfs(v, u, d + 1)

    count[0] = [0] * (kMax + 1)
    dfs(0, -1, 0)

    for j in range(1, m):
      for i in range(n):
        jump[i][j] = jump[jump[i][j - 1]][j - 1]

    def getLCA(u: int, v: int) -> int:
      if depth[u] > depth[v]:
        return getLCA(v, u)
      for j in range(m):
        if depth[v] - depth[u] >> j & 1:
          v = jump[v][j]
      if u == v:
        return u
      for j in range(m - 1, -1, -1):
        if jump[u][j] != jump[v][j]:
          u = jump[u][j]
          v = jump[v][j]
      return jump[v][0]

    for u, v in queries:
      lca = getLCA(u, v)
      numEdges = depth[u] + depth[v] - 2 * depth[lca]
      maxFreq = max(count[u][j] + count[v][j] - 2 * count[lca][j] for j in range(1, kMax + 1))
      ans.append(numEdges - maxFreq)

    return ans
"
1805,"You are given a string `word` that consists of digits and lowercase English
letters.

You will replace every non-digit character with a space. For example,
`""a123bc34d8ef34""` will become `"" 123 34 8 34""`. Notice that you are left with
some integers that are separated by at least one space: `""123""`, `""34""`,
`""8""`, and `""34""`.

Return the number of different integers after performing the replacement
operations on `word`.

Two integers are considered different if their decimal representations without
any leading zeros are different.

","def numDifferentIntegers(self, word: str) -> int:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def numDifferentIntegers(self, word: str) -> int:
    nums = set()
    curr = []

    for c in word:
      if c.isdigit():
        curr.append(c)
      elif curr:
        nums.add(''.join(self._removeLeadingZeros(curr)))
        curr = []

    if curr:
      nums.add(''.join(self._removeLeadingZeros(curr)))

    return len(nums)

  def _removeLeadingZeros(self, s: str) -> str:
    index = next((i for i, c in enumerate(s) if c != '0'), -1)
    if index == -1:
      return ['0']
    else:
      return s[index:]
"
1707,"You are given an array `nums` consisting of non-negative integers. You are
also given a `queries` array, where `queries[i] = [xi, mi]`.

The answer to the `ith` query is the maximum bitwise `XOR` value of `xi` and
any element of `nums` that does not exceed `mi`. In other words, the answer is
`max(nums[j] XOR xi)` for all `j` such that `nums[j] <= mi`. If all elements
in `nums` are larger than `mi`, then the answer is `-1`.

Return an integer array `answer` where `answer.length == queries.length` and
`answer[i]` is the answer to the `ith` query.

",def __init__(self):,"import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator, Optional

class TrieNode:
  def __init__(self):
    self.children: List[Optional[TrieNode]] = [None] * 2


class BitTrie:
  def __init__(self, maxBit: int):
    self.maxBit = maxBit
    self.root = TrieNode()

  def insert(self, num: int) -> None:
    node = self.root
    for i in range(self.maxBit, -1, -1):
      bit = num >> i & 1
      if not node.children[bit]:
        node.children[bit] = TrieNode()
      node = node.children[bit]

  def getMaxXor(self, num: int) -> int:
    maxXor = 0
    node = self.root
    for i in range(self.maxBit, -1, -1):
      bit = num >> i & 1
      toggleBit = bit ^ 1
      if node.children[toggleBit]:
        maxXor = maxXor | 1 << i
        node = node.children[toggleBit]
      elif node.children[bit]:
        node = node.children[bit]
      else:
        return 0
    return maxXor


class IndexedQuery:
  def __init__(self, queryIndex: int, x: int, m: int):
    self.queryIndex = queryIndex
    self.x = x
    self.m = m

  def __iter__(self):
    yield self.queryIndex
    yield self.x
    yield self.m


class Solution:
  def maximizeXor(self, nums: List[int], queries: List[List[int]]) -> List[int]:
    ans = [-1] * len(queries)
    maxBit = int(math.log2(max(max(nums), max(x for x, _ in queries))))
    bitTrie = BitTrie(maxBit)

    nums.sort()

    i = 0
    for queryIndex, x, m in sorted([IndexedQuery(i, x, m) for i, (x, m) in enumerate(queries)], key=lambda iq: iq.m):
      while i < len(nums) and nums[i] <= m:
        bitTrie.insert(nums[i])
        i += 1
      if i > 0 and nums[i - 1] <= m:
        ans[queryIndex] = bitTrie.getMaxXor(x)

    return ans
"
1786,"There is an undirected weighted connected graph. You are given a positive
integer `n` which denotes that the graph has `n` nodes labeled from `1` to
`n`, and an array `edges` where each `edges[i] = [ui, vi, weighti]` denotes
that there is an edge between nodes `ui` and `vi` with weight equal to
`weighti`.

A path from node `start` to node `end` is a sequence of nodes `[z0, z1, z2,
..., zk]` such that `z0 = start` and `zk = end` and there is an edge between
`zi` and `zi+1` where `0 <= i <= k-1`.

The distance of a path is the sum of the weights on the edges of the path. Let
`distanceToLastNode(x)` denote the shortest distance of a path between node
`n` and node `x`. A restricted path is a path that also satisfies that
`distanceToLastNode(zi) > distanceToLastNode(zi+1)` where `0 <= i <= k-1`.

Return the number of restricted paths from node `1` to node `n`. Since that
number may be too large, return it modulo `109 + 7`.

","def countRestrictedPaths(self, n: int, edges: List[List[int]]) -> int:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def countRestrictedPaths(self, n: int, edges: List[List[int]]) -> int:
    graph = [[] for _ in range(n)]

    for u, v, w in edges:
      graph[u - 1].append((v - 1, w))
      graph[v - 1].append((u - 1, w))

    return self._dijkstra(graph, 0, n - 1)

  def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, dst: int) -> int:
    kMod = 10**9 + 7
    ways = [0] * len(graph)
    dist = [math.inf] * len(graph)

    ways[dst] = 1
    dist[dst] = 0
    minHeap = [(dist[dst], dst)]

    while minHeap:
      d, u = heapq.heappop(minHeap)
      if d > dist[u]:
        continue
      for v, w in graph[u]:
        if d + w < dist[v]:
          dist[v] = d + w
          heapq.heappush(minHeap, (dist[v], v))
        if dist[v] < dist[u]:
          ways[u] += ways[v]
          ways[u] %= kMod

    return ways[src]
"
913,"A game on an undirected graph is played by two players, Mouse and Cat, who
alternate turns.

The graph is given as follows: `graph[a]` is a list of all nodes `b` such that
`ab` is an edge of the graph.

The mouse starts at node `1` and goes first, the cat starts at node `2` and
goes second, and there is a hole at node `0`.

During each player's turn, they must travel along one edge of the graph that
meets where they are. For example, if the Mouse is at node 1, it must travel
to any node in `graph[1]`.

Additionally, it is not allowed for the Cat to travel to the Hole (node `0`).

Then, the game can end in three ways:

* If ever the Cat occupies the same node as the Mouse, the Cat wins.
* If ever the Mouse reaches the Hole, the Mouse wins.
* If ever a position is repeated (i.e., the players are in the same position as a previous turn, and it is the same player's turn to move), the game is a draw.

Given a `graph`, and assuming both players play optimally, return

* `1` if the mouse wins the game,
* `2` if the cat wins the game, or
* `0` if the game is a draw.

","def catMouseGame(self, graph: List[List[int]]) -> int:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

from enum import IntEnum


class State(IntEnum):
  kDraw = 0
  kMouseWin = 1
  kCatWin = 2


class Solution:
  def catMouseGame(self, graph: List[List[int]]) -> int:
    n = len(graph)
    states = [[[0] * 2 for i in range(n)] for j in range(n)]
    outDegree = [[[0] * 2 for i in range(n)] for j in range(n)]
    q = collections.deque()

    for cat in range(n):
      for mouse in range(n):
        outDegree[cat][mouse][0] = len(graph[mouse])
        outDegree[cat][mouse][1] = len(graph[cat]) - graph[cat].count(0)

    for cat in range(1, n):
      for move in range(2):
        states[cat][0][move] = int(State.kMouseWin)
        q.append((cat, 0, move, int(State.kMouseWin)))
        states[cat][cat][move] = int(State.kCatWin)
        q.append((cat, cat, move, int(State.kCatWin)))

    while q:
      cat, mouse, move, state = q.popleft()
      if cat == 2 and mouse == 1 and move == 0:
        return state
      prevMove = move ^ 1
      for prev in graph[cat if prevMove else mouse]:
        prevCat = prev if prevMove else cat
        if prevCat == 0:
          continue
        prevMouse = mouse if prevMove else prev
        if states[prevCat][prevMouse][prevMove]:
          continue
        if prevMove == 0 and state == int(State.kMouseWin) or \
                prevMove == 1 and state == int(State.kCatWin):
          states[prevCat][prevMouse][prevMove] = state
          q.append((prevCat, prevMouse, prevMove, state))
        else:
          outDegree[prevCat][prevMouse][prevMove] -= 1
          if outDegree[prevCat][prevMouse][prevMove] == 0:
            states[prevCat][prevMouse][prevMove] = state
            q.append((prevCat, prevMouse, prevMove, state))

    return states[2][1][0]
"
673,"Given an integer array `nums`, return the number of longest increasing
subsequences.

Notice that the sequence has to be strictly increasing.

","def findNumberOfLIS(self, nums: List[int]) -> int:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def findNumberOfLIS(self, nums: List[int]) -> int:
    ans = 0
    maxLength = 0
    length = [1] * len(nums)
    count = [1] * len(nums)

    for i, num in enumerate(nums):
      for j in range(i):
        if nums[j] < num:
          if length[i] < length[j] + 1:
            length[i] = length[j] + 1
            count[i] = count[j]
          elif length[i] == length[j] + 1:
            count[i] += count[j]

    for i, l in enumerate(length):
      if l > maxLength:
        maxLength = l
        ans = count[i]
      elif l == maxLength:
        ans += count[i]

    return ans
"
684,"In this problem, a tree is an undirected graph that is connected and has no
cycles.

You are given a graph that started as a tree with `n` nodes labeled from `1`
to `n`, with one additional edge added. The added edge has two different
vertices chosen from `1` to `n`, and was not an edge that already existed. The
graph is represented as an array `edges` of length `n` where `edges[i] = [ai,
bi]` indicates that there is an edge between nodes `ai` and `bi` in the graph.

Return an edge that can be removed so that the resulting graph is a tree of
`n` nodes. If there are multiple answers, return the answer that occurs last
in the input.

","def __init__(self, n: int):","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class UnionFind:
  def __init__(self, n: int):
    self.id = list(range(n))
    self.rank = [0] * n

  def unionByRank(self, u: int, v: int) -> bool:
    i = self._find(u)
    j = self._find(v)
    if i == j:
      return False
    if self.rank[i] < self.rank[j]:
      self.id[i] = j
    elif self.rank[i] > self.rank[j]:
      self.id[j] = i
    else:
      self.id[i] = j
      self.rank[j] += 1
    return True

  def _find(self, u: int) -> int:
    if self.id[u] != u:
      self.id[u] = self._find(self.id[u])
    return self.id[u]


class Solution:
  def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:
    uf = UnionFind(len(edges) + 1)

    for edge in edges:
      u, v = edge
      if not uf.unionByRank(u, v):
        return edge
"
685,"In this problem, a rooted tree is a directed graph such that, there is exactly
one node (the root) for which all other nodes are descendants of this node,
plus every node has exactly one parent, except for the root node which has no
parents.

The given input is a directed graph that started as a rooted tree with `n`
nodes (with distinct values from `1` to `n`), with one additional directed
edge added. The added edge has two different vertices chosen from `1` to `n`,
and was not an edge that already existed.

The resulting graph is given as a 2D-array of `edges`. Each element of `edges`
is a pair `[ui, vi]` that represents a directed edge connecting nodes `ui` and
`vi`, where `ui` is a parent of child `vi`.

Return an edge that can be removed so that the resulting graph is a rooted
tree of `n` nodes. If there are multiple answers, return the answer that
occurs last in the given 2D-array.

","def __init__(self, n: int):","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class UnionFind:
  def __init__(self, n: int):
    self.id = list(range(n))
    self.rank = [0] * n

  def unionByRank(self, u: int, v: int) -> bool:
    i = self._find(u)
    j = self._find(v)
    if i == j:
      return False
    if self.rank[i] < self.rank[j]:
      self.id[i] = j
    elif self.rank[i] > self.rank[j]:
      self.id[j] = i
    else:
      self.id[i] = j
      self.rank[j] += 1
    return True

  def _find(self, u: int) -> int:
    if self.id[u] != u:
      self.id[u] = self._find(self.id[u])
    return self.id[u]


class Solution:
  def findRedundantDirectedConnection(self, edges: List[List[int]]) -> List[int]:
    ids = [0] * (len(edges) + 1)
    nodeWithTwoParents = 0

    for _, v in edges:
      ids[v] += 1
      if ids[v] == 2:
        nodeWithTwoParents = v

    def findRedundantDirectedConnection(skippedEdgeIndex: int) -> List[int]:
      uf = UnionFind(len(edges) + 1)

      for i, edge in enumerate(edges):
        if i == skippedEdgeIndex:
          continue
        if not uf.unionByRank(edge[0], edge[1]):
          return edge

      return []

    if nodeWithTwoParents == 0:
      return findRedundantDirectedConnection(-1)

    for i in reversed(range(len(edges))):
      _, v = edges[i]
      if v == nodeWithTwoParents:
        if not findRedundantDirectedConnection(i):
          return edges[i]
"
689,"Given an integer array `nums` and an integer `k`, find three non-overlapping
subarrays of length `k` with maximum sum and return them.

Return the result as a list of indices representing the starting position of
each interval (0-indexed). If there are multiple answers, return the
lexicographically smallest one.

","def maxSumOfThreeSubarrays(self, nums: List[int], k: int) -> List[int]:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def maxSumOfThreeSubarrays(self, nums: List[int], k: int) -> List[int]:
    n = len(nums) - k + 1
    sums = [0] * n
    l = [0] * n
    r = [0] * n

    summ = 0
    for i, num in enumerate(nums):
      summ += num
      if i >= k:
        summ -= nums[i - k]
      if i >= k - 1:
        sums[i - k + 1] = summ

    maxIndex = 0
    for i in range(n):
      if sums[i] > sums[maxIndex]:
        maxIndex = i
      l[i] = maxIndex

    maxIndex = n - 1
    for i in range(n - 1, -1, -1):
      if sums[i] >= sums[maxIndex]:
        maxIndex = i
      r[i] = maxIndex

    ans = [-1, -1, -1]

    for i in range(k, n - k):
      if ans[0] == -1 or sums[ans[0]] + sums[ans[1]] + sums[ans[2]] < sums[l[i - k]] + sums[i] + sums[r[i + k]]:
        ans[0] = l[i - k]
        ans[1] = i
        ans[2] = r[i + k]

    return ans
"
691,"We are given `n` different types of `stickers`. Each sticker has a lowercase
English word on it.

You would like to spell out the given string `target` by cutting individual
letters from your collection of stickers and rearranging them. You can use
each sticker more than once if you want, and you have infinite quantities of
each sticker.

Return the minimum number of stickers that you need to spell out `target`. If
the task is impossible, return `-1`.

Note: In all test cases, all words were chosen randomly from the `1000` most
common US English words, and `target` was chosen as a concatenation of two
random words.

","def minStickers(self, stickers: List[str], target: str) -> int:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def minStickers(self, stickers: List[str], target: str) -> int:
    maxMask = 1 << len(target)
    dp = [math.inf] * maxMask
    dp[0] = 0

    for mask in range(maxMask):
      if dp[mask] == math.inf:
        continue
      for sticker in stickers:
        superMask = mask
        for c in sticker:
          for i, t in enumerate(target):
            if c == t and not (superMask >> i & 1):
              superMask |= 1 << i
              break
        dp[superMask] = min(dp[superMask], dp[mask] + 1)

    return -1 if dp[-1] == math.inf else dp[-1]
"
722,"Given a C++ program, remove comments from it. The program source is an array
of strings `source` where `source[i]` is the `ith` line of the source code.
This represents the result of splitting the original source code string by the
newline character `'\n'`.

In C++, there are two types of comments, line comments, and block comments.

* The string `""//""` denotes a line comment, which represents that it and the rest of the characters to the right of it in the same line should be ignored.
* The string `""/*""` denotes a block comment, which represents that all characters until the next (non-overlapping) occurrence of `""*/""` should be ignored. (Here, occurrences happen in reading order: line by line from left to right.) To be clear, the string `""/*/""` does not yet end the block comment, as the ending would be overlapping the beginning.

The first effective comment takes precedence over others.

* For example, if the string `""//""` occurs in a block comment, it is ignored.
* Similarly, if the string `""/*""` occurs in a line or block comment, it is also ignored.

If a certain line of code is empty after removing comments, you must not
output that line: each string in the answer list will be non-empty.

There will be no control characters, single quote, or double quote characters.

* For example, `source = ""string s = ""/* Not a comment. */"";""` will not be a test case.

Also, nothing else such as defines or macros will interfere with the comments.

It is guaranteed that every open block comment will eventually be closed, so
`""/*""` outside of a line or block comment always starts a new comment.

Finally, implicit newline characters can be deleted by block comments. Please
see the examples below for details.

After removing the comments from the source code, return the source code in
the same format.

","def removeComments(self, source: List[str]) -> List[str]:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def removeComments(self, source: List[str]) -> List[str]:
    ans = []
    commenting = False
    modified = ''

    for line in source:
      i = 0
      while i < len(line):
        if i + 1 == len(line):
          if not commenting:
            modified += line[i]
          i += 1
          break
        twoChars = line[i:i + 2]
        if twoChars == '/*' and not commenting:
          commenting = True
          i += 2
        elif twoChars == '*/' and commenting:
          commenting = False
          i += 2
        elif twoChars == '//':
          if not commenting:
            break
          else:
            i += 2
        else:
          if not commenting:
            modified += line[i]
          i += 1
      if modified and not commenting:
        ans.append(modified)
        modified = ''

    return ans
"
730,"Given a string s, return the number of different non-empty palindromic
subsequences in `s`. Since the answer may be very large, return it modulo `109
+ 7`.

A subsequence of a string is obtained by deleting zero or more characters from
the string.

A sequence is palindromic if it is equal to the sequence reversed.

Two sequences `a1, a2, ...` and `b1, b2, ...` are different if there is some
`i` for which `ai != bi`.

","def countPalindromicSubsequences(self, s: str) -> int:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def countPalindromicSubsequences(self, s: str) -> int:
    kMod = 1_000_000_007
    n = len(s)
    dp = [[0] * n for _ in range(n)]

    for i in range(n):
      dp[i][i] = 1

    for d in range(1, n):
      for i in range(n - d):
        j = i + d
        if s[i] == s[j]:
          lo = i + 1
          hi = j - 1
          while lo <= hi and s[lo] != s[i]:
            lo += 1
          while lo <= hi and s[hi] != s[i]:
            hi -= 1
          if lo > hi:
            dp[i][j] = dp[i + 1][j - 1] * 2 + 2
          elif lo == hi:
            dp[i][j] = dp[i + 1][j - 1] * 2 + 1
          else:
            dp[i][j] = dp[i + 1][j - 1] * 2 - dp[lo + 1][hi - 1]
        else:
          dp[i][j] = dp[i][j - 1] + dp[i + 1][j] - dp[i + 1][j - 1]
        dp[i][j] = (dp[i][j] + kMod) % kMod

    return dp[0][n - 1]
"
735,"We are given an array `asteroids` of integers representing asteroids in a row.

For each asteroid, the absolute value represents its size, and the sign
represents its direction (positive meaning right, negative meaning left). Each
asteroid moves at the same speed.

Find out the state of the asteroids after all collisions. If two asteroids
meet, the smaller one will explode. If both are the same size, both will
explode. Two asteroids moving in the same direction will never meet.

","def asteroidCollision(self, asteroids: List[int]) -> List[int]:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def asteroidCollision(self, asteroids: List[int]) -> List[int]:
    stack = []

    for a in asteroids:
      if a > 0:
        stack.append(a)
      else:
        while stack and stack[-1] > 0 and stack[-1] < -a:
          stack.pop()
        if not stack or stack[-1] < 0:
          stack.append(a)
        elif stack[-1] == -a:
          stack.pop()
        else:
          pass

    return stack
"
743,"You are given a network of `n` nodes, labeled from `1` to `n`. You are also
given `times`, a list of travel times as directed edges `times[i] = (ui, vi,
wi)`, where `ui` is the source node, `vi` is the target node, and `wi` is the
time it takes for a signal to travel from source to target.

We will send a signal from a given node `k`. Return the minimum time it takes
for all the `n` nodes to receive the signal. If it is impossible for all the
`n` nodes to receive the signal, return `-1`.

","def networkDelayTime(self, times: List[List[int]], n: int, k: int) -> int:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def networkDelayTime(self, times: List[List[int]], n: int, k: int) -> int:
    graph = [[] for _ in range(n)]

    for u, v, w in times:
      graph[u - 1].append((v - 1, w))

    return self._dijkstra(graph, k - 1)

  def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int) -> int:
    dist = [math.inf] * len(graph)

    dist[src] = 0
    minHeap = [(dist[src], src)]

    while minHeap:
      d, u = heapq.heappop(minHeap)
      if d > dist[u]:
        continue
      for v, w in graph[u]:
        if d + w < dist[v]:
          dist[v] = d + w
          heapq.heappush(minHeap, (dist[v], v))

    maxDist = max(dist)
    return maxDist if maxDist != math.inf else -1
"
770,"Given an expression such as `expression = ""e + 8 - a + 5""` and an evaluation
map such as `{""e"": 1}` (given in terms of `evalvars = [""e""]` and `evalints =
[1]`), return a list of tokens representing the simplified expression, such as
`[""-1*a"",""14""]`

* An expression alternates chunks and symbols, with a space separating each chunk and symbol.
* A chunk is either an expression in parentheses, a variable, or a non-negative integer.
* A variable is a string of lowercase letters (not including digits.) Note that variables can be multiple letters, and note that variables never have a leading coefficient or unary operator like `""2x""` or `""-x""`.

Expressions are evaluated in the usual order: brackets first, then
multiplication, then addition and subtraction.

* For example, `expression = ""1 + 2 * 3""` has an answer of `[""7""]`.

The format of the output is as follows:

* For each term of free variables with a non-zero coefficient, we write the free variables within a term in sorted order lexicographically. 
* For example, we would never write a term like `""b*a*c""`, only `""a*b*c""`.
* Terms have degrees equal to the number of free variables being multiplied, counting multiplicity. We write the largest degree terms of our answer first, breaking ties by lexicographic order ignoring the leading coefficient of the term. 
* For example, `""a*a*b*c""` has degree `4`.
* The leading coefficient of the term is placed directly to the left with an asterisk separating it from the variables (if they exist.) A leading coefficient of 1 is still printed.
* An example of a well-formatted answer is `[""-2*a*a*a"", ""3*a*a*b"", ""3*b*b"", ""4*a"", ""5*c"", ""-6""]`.
* Terms (including constant terms) with coefficient `0` are not included. 
* For example, an expression of `""0""` has an output of `[]`.

Note: You may assume that the given expression is always valid. All
intermediate results will be in the range of `[-231, 231 - 1]`.

","def __init__(self, term: str = None, coef: int = None):","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Poly:
  def __init__(self, term: str = None, coef: int = None):
    if term and coef:
      self.terms = collections.Counter({term: coef})
    else:
      self.terms = collections.Counter()

  def __add__(self, other):
    for term, coef in other.terms.items():
      self.terms[term] += coef
    return self

  def __sub__(self, other):
    for term, coef in other.terms.items():
      self.terms[term] -= coef
    return self

  def __mul__(self, other):
    res = Poly()
    for a, aCoef in self.terms.items():
      for b, bCoef in other.terms.items():
        res.terms[self._merge(a, b)] += aCoef * bCoef
    return res

  def toList(self) -> List[str]:
    for term in list(self.terms.keys()):
      if not self.terms[term]:
        del self.terms[term]

    def cmp(term: str) -> tuple:
      if term == '1':
        return (0,)
      var = term.split('*')
      return (-len(var), term)

    def concat(term: str) -> str:
      if term == '1':
        return str(self.terms[term])
      return str(self.terms[term]) + '*' + term

    terms = list(self.terms.keys())
    terms.sort(key=cmp)
    return [concat(term) for term in terms]

  def _merge(self, a: str, b: str) -> str:
    if a == '1':
      return b
    if b == '1':
      return a
    res = []
    A = a.split('*')
    B = b.split('*')
    i = 0
    j = 0
    while i < len(A) and j < len(B):
      if A[i] < B[j]:
        res.append(A[i])
        i += 1
      else:
        res.append(B[j])
        j += 1
    return '*'.join(res + A[i:] + B[j:])


class Solution:
  def basicCalculatorIV(self, expression: str, evalvars: List[str], evalints: List[int]) -> List[str]:
    tokens = list(self._getTokens(expression))
    evalMap = {a: b for a, b in zip(evalvars, evalints)}

    for i, token in enumerate(tokens):
      if token in evalMap:
        tokens[i] = str(evalMap[token])

    postfix = self._infixToPostfix(tokens)
    return self._evaluate(postfix).toList()

  def _getTokens(self, s: str) -> Iterator[str]:
    i = 0
    for j, c in enumerate(s):
      if c == ' ':
        if i < j:
          yield s[i:j]
        i = j + 1
      elif c in '()+-*':
        if i < j:
          yield s[i:j]
        yield c
        i = j + 1
    if i < len(s):
      yield s[i:]

  def _infixToPostfix(self, tokens: List[str]) -> List[str]:
    postfix = []
    ops = []

    def precedes(prevOp: str, currOp: str) -> bool:
      if prevOp == '(':
        return False
      return prevOp == '*' or currOp in '+-'

    for token in tokens:
      if token == '(':
        ops.append(token)
      elif token == ')':
        while ops[-1] != '(':
          postfix.append(ops.pop())
        ops.pop()
      elif token in '+-*':
        while ops and precedes(ops[-1], token):
          postfix.append(ops.pop())
        ops.append(token)
      else:
        postfix.append(token)
    return postfix + ops[::-1]

  def _evaluate(self, postfix: List[str]) -> Poly:
    polys: List[Poly] = []
    for token in postfix:
      if token in '+-*':
        b = polys.pop()
        a = polys.pop()
        if token == '+':
          polys.append(a + b)
        elif token == '-':
          polys.append(a - b)
        else:
          polys.append(a * b)
      elif token.lstrip('-').isnumeric():
        polys.append(Poly(""1"", int(token)))
      else:
        polys.append(Poly(token, 1))
    return polys[0]
"
777,"In a string composed of `'L'`, `'R'`, and `'X'` characters, like
`""RXXLRXRXL""`, a move consists of either replacing one occurrence of `""XL""`
with `""LX""`, or replacing one occurrence of `""RX""` with `""XR""`. Given the
starting string `start` and the ending string `end`, return `True` if and only
if there exists a sequence of moves to transform one string to the other.

","def canTransform(self, start: str, end: str) -> bool:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def canTransform(self, start: str, end: str) -> bool:
    if start.replace('X', '') != end.replace('X', ''):
      return False

    i = 0
    j = 0

    while i < len(start) and j < len(end):
      while i < len(start) and start[i] == 'X':
        i += 1
      while j < len(end) and end[j] == 'X':
        j += 1
      if i == len(start) and j == len(end):
        return True
      if i == len(start) or j == len(end):
        return False
      if start[i] == 'L' and i < j:
        return False
      if start[i] == 'R' and i > j:
        return False
      i += 1
      j += 1

    return True
"
782,"You are given an `n x n` binary grid `board`. In each move, you can swap any
two rows with each other, or any two columns with each other.

Return the minimum number of moves to transform the board into a chessboard
board. If the task is impossible, return `-1`.

A chessboard board is a board where no `0`'s and no `1`'s are 4-directionally
adjacent.

","def movesToChessboard(self, board: List[List[int]]) -> int:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def movesToChessboard(self, board: List[List[int]]) -> int:
    n = len(board)

    for i in range(n):
      for j in range(n):
        if board[0][0] ^ board[i][0] ^ board[0][j] ^ board[i][j]:
          return -1

    rowSum = sum(board[0])
    colSum = sum(board[i][0] for i in range(n))

    if rowSum != n // 2 and rowSum != (n + 1) // 2:
      return -1
    if colSum != n // 2 and colSum != (n + 1) // 2:
      return -1

    rowSwaps = sum(board[i][0] == (i & 1) for i in range(n))
    colSwaps = sum(board[0][i] == (i & 1) for i in range(n))

    if n & 1:
      if rowSwaps & 1:
        rowSwaps = n - rowSwaps
      if colSwaps & 1:
        colSwaps = n - colSwaps
    else:
      rowSwaps = min(rowSwaps, n - rowSwaps)
      colSwaps = min(colSwaps, n - colSwaps)

    return (rowSwaps + colSwaps) // 2
"
786,"You are given a sorted integer array `arr` containing `1` and prime numbers,
where all the integers of `arr` are unique. You are also given an integer `k`.

For every `i` and `j` where `0 <= i < j < arr.length`, we consider the
fraction `arr[i] / arr[j]`.

Return the `kth` smallest fraction considered. Return your answer as an array
of integers of size `2`, where `answer[0] == arr[i]` and `answer[1] ==
arr[j]`.

","def kthSmallestPrimeFraction(self, arr: List[int], k: int) -> List[int]:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def kthSmallestPrimeFraction(self, arr: List[int], k: int) -> List[int]:
    n = len(arr)
    ans = [0, 1]
    l = 0
    r = 1

    while True:
      m = (l + r) / 2
      ans[0] = 0
      count = 0
      j = 1

      for i in range(n):
        while j < n and arr[i] > m * arr[j]:
          j += 1
        count += n - j
        if j == n:
          break
        if ans[0] * arr[j] < ans[1] * arr[i]:
          ans[0] = arr[i]
          ans[1] = arr[j]

      if count < k:
        l = m
      elif count > k:
        r = m
      else:
        return ans
"
794,"Given a Tic-Tac-Toe board as a string array `board`, return `true` if and only
if it is possible to reach this board position during the course of a valid
tic-tac-toe game.

The board is a `3 x 3` array that consists of characters `' '`, `'X'`, and
`'O'`. The `' '` character represents an empty square.

Here are the rules of Tic-Tac-Toe:

* Players take turns placing characters into empty squares `' '`.
* The first player always places `'X'` characters, while the second player always places `'O'` characters.
* `'X'` and `'O'` characters are always placed into empty squares, never filled ones.
* The game ends when there are three of the same (non-empty) character filling any row, column, or diagonal.
* The game also ends if all squares are non-empty.
* No more moves can be played if the game is over.

","def validTicTacToe(self, board: List[str]) -> bool:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def validTicTacToe(self, board: List[str]) -> bool:
    def isWin(c: str) -> bool:
      return any(row.count(c) == 3 for row in board) or any(row.count(c) == 3 for row in list(zip(*board))) or all(board[i][i] == c for i in range(3)) or all(board[i][2 - i] == c for i in range(3))

    countX = sum(row.count('X') for row in board)
    countO = sum(row.count('O') for row in board)

    if countX < countO or countX - countO > 1:
      return False
    if isWin('X') and countX == countO or isWin('O') and countX != countO:
      return False

    return True
"
805,"You are given an integer array `nums`.

You should move each element of `nums` into one of the two arrays `A` and `B`
such that `A` and `B` are non-empty, and `average(A) == average(B)`.

Return `true` if it is possible to achieve that and `false` otherwise.

Note that for an array `arr`, `average(arr)` is the sum of all the elements of
`arr` over the length of `arr`.

","def splitArraySameAverage(self, nums: List[int]) -> bool:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def splitArraySameAverage(self, nums: List[int]) -> bool:
    n = len(nums)
    summ = sum(nums)
    if not any(i * summ % n == 0 for i in range(1, n // 2 + 1)):
      return False

    sums = [set() for _ in range(n // 2 + 1)]
    sums[0].add(0)

    for num in nums:
      for i in range(n // 2, 0, -1):
        for val in sums[i - 1]:
          sums[i].add(num + val)

    for i in range(1, n // 2 + 1):
      if i * summ % n == 0 and i * summ // n in sums[i]:
        return True

    return False
"
815,"You are given an array `routes` representing bus routes where `routes[i]` is a
bus route that the `ith` bus repeats forever.

* For example, if `routes[0] = [1, 5, 7]`, this means that the `0th` bus travels in the sequence `1 -> 5 -> 7 -> 1 -> 5 -> 7 -> 1 -> ...` forever.

You will start at the bus stop `source` (You are not on any bus initially),
and you want to go to the bus stop `target`. You can travel between bus stops
by buses only.

Return the least number of buses you must take to travel from `source` to
`target`. Return `-1` if it is not possible.

","def numBusesToDestination(self, routes: List[List[int]], source: int, target: int) -> int:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def numBusesToDestination(self, routes: List[List[int]], source: int, target: int) -> int:
    if source == target:
      return 0

    graph = collections.defaultdict(list)
    usedBuses = set()

    for i in range(len(routes)):
      for route in routes[i]:
        graph[route].append(i)

    ans = 0
    q = collections.deque([source])

    while q:
      ans += 1
      for _ in range(len(q)):
        for bus in graph[q.popleft()]:
          if bus in usedBuses:
            continue
          usedBuses.add(bus)
          for nextRoute in routes[bus]:
            if nextRoute == target:
              return ans
            q.append(nextRoute)

    return -1
"
838,"There are `n` dominoes in a line, and we place each domino vertically upright.
In the beginning, we simultaneously push some of the dominoes either to the
left or to the right.

After each second, each domino that is falling to the left pushes the adjacent
domino on the left. Similarly, the dominoes falling to the right push their
adjacent dominoes standing on the right.

When a vertical domino has dominoes falling on it from both sides, it stays
still due to the balance of the forces.

For the purposes of this question, we will consider that a falling domino
expends no additional force to a falling or already fallen domino.

You are given a string `dominoes` representing the initial state where:

* `dominoes[i] = 'L'`, if the `ith` domino has been pushed to the left,
* `dominoes[i] = 'R'`, if the `ith` domino has been pushed to the right, and
* `dominoes[i] = '.'`, if the `ith` domino has not been pushed.

Return a string representing the final state.

","def pushDominoes(self, dominoes: str) -> str:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def pushDominoes(self, dominoes: str) -> str:
    ans = list(dominoes)
    L = -1
    R = -1

    for i in range(len(dominoes) + 1):
      if i == len(dominoes) or dominoes[i] == 'R':
        if L < R:
          while R < i:
            ans[R] = 'R'
            R += 1
        R = i
      elif dominoes[i] == 'L':
        if R < L or (L, R) == (-1, -1):
          if (L, R) == (-1, -1):
            L += 1
          while L < i:
            ans[L] = 'L'
            L += 1
        else:
          l = R + 1
          r = i - 1
          while l < r:
            ans[l] = 'R'
            ans[r] = 'L'
            l += 1
            r -= 1
        L = i

    return ''.join(ans)
"
845,"You may recall that an array `arr` is a mountain array if and only if:

* `arr.length >= 3`
* There exists some index `i` (0-indexed) with `0 < i < arr.length - 1` such that: 
* `arr[0] < arr[1] < ... < arr[i - 1] < arr[i]`
* `arr[i] > arr[i + 1] > ... > arr[arr.length - 1]`

Given an integer array `arr`, return the length of the longest subarray, which
is a mountain. Return `0` if there is no mountain subarray.

","def longestMountain(self, arr: List[int]) -> int:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def longestMountain(self, arr: List[int]) -> int:
    ans = 0
    i = 0

    while i + 1 < len(arr):
      while i + 1 < len(arr) and arr[i] == arr[i + 1]:
        i += 1

      increasing = 0
      decreasing = 0

      while i + 1 < len(arr) and arr[i] < arr[i + 1]:
        increasing += 1
        i += 1

      while i + 1 < len(arr) and arr[i] > arr[i + 1]:
        decreasing += 1
        i += 1

      if increasing > 0 and decreasing > 0:
        ans = max(ans, increasing + decreasing + 1)

    return ans
"
861,"You are given an `m x n` binary matrix `grid`.

A move consists of choosing any row or column and toggling each value in that
row or column (i.e., changing all `0`'s to `1`'s, and all `1`'s to `0`'s).

Every row of the matrix is interpreted as a binary number, and the score of
the matrix is the sum of these numbers.

Return the highest possible score after making any number of moves (including
zero moves).

","def matrixScore(self, grid: List[List[int]]) -> int:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def matrixScore(self, grid: List[List[int]]) -> int:
    for row in grid:
      if row[0] == 0:
        self._flip(row)

    for j, col in enumerate(list(zip(*grid))):
      if sum(col) * 2 < len(grid):
        self._flipCol(grid, j)

    return sum(self._binary(row) for row in grid)

  def _flip(self, row: List[int]) -> None:
    for i in range(len(row)):
      row[i] ^= 1

  def _flipCol(self, grid: List[List[int]], j: int) -> None:
    for i in range(len(grid)):
      grid[i][j] ^= 1

  def _binary(self, row: List[int]) -> int:
    res = row[0]
    for j in range(1, len(row)):
      res = res * 2 + row[j]
    return res
"
866,"Given an integer n, return the smallest prime palindrome greater than or equal
to `n`.

An integer is prime if it has exactly two divisors: `1` and itself. Note that
`1` is not a prime number.

* For example, `2`, `3`, `5`, `7`, `11`, and `13` are all primes.

An integer is a palindrome if it reads the same from left to right as it does
from right to left.

* For example, `101` and `12321` are palindromes.

The test cases are generated so that the answer always exists and is in the
range `[2, 2 * 108]`.

","def primePalindrome(self, n: int) -> int:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def primePalindrome(self, n: int) -> int:
    def getPalindromes(n: int):
      length = n // 2
      for i in range(10**(length - 1), 10**length):
        s = str(i)
        for j in range(10):
          yield int(s + str(j) + s[::-1])

    def isPrime(num: int) -> bool:
      for i in range(2, int(num**0.5 + 1)):
        if num % i == 0:
          return False
      return True

    if n <= 2:
      return 2
    if n == 3:
      return 3
    if n <= 5:
      return 5
    if n <= 7:
      return 7
    if n <= 11:
      return 11

    nLength = len(str(n))

    while True:
      for num in getPalindromes(nLength):
        if num >= n and isPrime(num):
          return num
      nLength += 1
"
882,"You are given an undirected graph (the ""original graph"") with `n` nodes
labeled from `0` to `n - 1`. You decide to subdivide each edge in the graph
into a chain of nodes, with the number of new nodes varying between each edge.

The graph is given as a 2D array of `edges` where `edges[i] = [ui, vi, cnti]`
indicates that there is an edge between nodes `ui` and `vi` in the original
graph, and `cnti` is the total number of new nodes that you will subdivide the
edge into. Note that `cnti == 0` means you will not subdivide the edge.

To subdivide the edge `[ui, vi]`, replace it with `(cnti + 1)` new edges and
`cnti` new nodes. The new nodes are `x1`, `x2`, ..., `xcnti`, and the new
edges are `[ui, x1]`, `[x1, x2]`, `[x2, x3]`, ..., `[xcnti-1, xcnti]`,
`[xcnti, vi]`.

In this new graph, you want to know how many nodes are reachable from the node
`0`, where a node is reachable if the distance is `maxMoves` or less.

Given the original graph and `maxMoves`, return the number of nodes that are
reachable from node `0` in the new graph.

","def reachableNodes(self, edges: List[List[int]], maxMoves: int, n: int) -> int:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def reachableNodes(self, edges: List[List[int]], maxMoves: int, n: int) -> int:
    graph = [[] for _ in range(n)]
    dist = [maxMoves + 1] * n

    for u, v, cnt in edges:
      graph[u].append((v, cnt))
      graph[v].append((u, cnt))

    reachableNodes = self._dijkstra(graph, 0, maxMoves, dist)
    reachableSubnodes = 0

    for u, v, cnt in edges:
      a = 0 if dist[u] > maxMoves else min(maxMoves - dist[u], cnt)
      b = 0 if dist[v] > maxMoves else min(maxMoves - dist[v], cnt)
      reachableSubnodes += min(a + b, cnt)

    return reachableNodes + reachableSubnodes

  def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int, maxMoves: int, dist: List[int]) -> int:
    dist[src] = 0
    minHeap = [(dist[src], src)]

    while minHeap:
      d, u = heapq.heappop(minHeap)
      if dist[u] >= maxMoves:
        break
      if d > dist[u]:
        continue
      for v, w in graph[u]:
        newDist = d + w + 1
        if newDist < dist[v]:
          dist[v] = newDist
          heapq.heappush(minHeap, (newDist, v))

    return sum(d <= maxMoves for d in dist)
"
648,"In English, we have a concept called root, which can be followed by some other
word to form another longer word - let's call this word successor. For
example, when the root `""help""` is followed by the successor word `""ful""`, we
can form a new word `""helpful""`.

Given a `dictionary` consisting of many roots and a `sentence` consisting of
words separated by spaces, replace all the successors in the sentence with the
root forming it. If a successor can be replaced by more than one root, replace
it with the root that has the shortest length.

Return the `sentence` after the replacement.

",def __init__(self):,"import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def __init__(self):
    self.root = {}

  def insert(self, word: str) -> None:
    node = self.root
    for c in word:
      if c not in node:
        node[c] = {}
      node = node[c]
    node['word'] = word

  def search(self, word: str) -> str:
    node = self.root
    for c in word:
      if 'word' in node:
        return node['word']
      if c not in node:
        return word
      node = node[c]
    return word

  def replaceWords(self, dictionary: List[str], sentence: str) -> str:
    for word in dictionary:
      self.insert(word)

    words = sentence.split(' ')
    return ' '.join([self.search(word) for word in words])
"
591,"Given a string representing a code snippet, implement a tag validator to parse
the code and return whether it is valid.

A code snippet is valid if all the following rules hold:

1. The code must be wrapped in a valid closed tag. Otherwise, the code is invalid.
2. A closed tag (not necessarily valid) has exactly the following format : `<TAG_NAME>TAG_CONTENT</TAG_NAME>`. Among them, `<TAG_NAME>` is the start tag, and `</TAG_NAME>` is the end tag. The TAG_NAME in start and end tags should be the same. A closed tag is valid if and only if the TAG_NAME and TAG_CONTENT are valid.
3. A valid `TAG_NAME` only contain upper-case letters, and has length in range [1,9]. Otherwise, the `TAG_NAME` is invalid.
4. A valid `TAG_CONTENT` may contain other valid closed tags, cdata and any characters (see note1) EXCEPT unmatched `<`, unmatched start and end tag, and unmatched or closed tags with invalid TAG_NAME. Otherwise, the `TAG_CONTENT` is invalid.
5. A start tag is unmatched if no end tag exists with the same TAG_NAME, and vice versa. However, you also need to consider the issue of unbalanced when tags are nested.
6. A `<` is unmatched if you cannot find a subsequent `>`. And when you find a `<` or `</`, all the subsequent characters until the next `>` should be parsed as TAG_NAME (not necessarily valid).
7. The cdata has the following format : `<![CDATA[CDATA_CONTENT]]>`. The range of `CDATA_CONTENT` is defined as the characters between `<![CDATA[` and the first subsequent `]]>`.
8. `CDATA_CONTENT` may contain any characters. The function of cdata is to forbid the validator to parse `CDATA_CONTENT`, so even it has some characters that can be parsed as tag (no matter valid or invalid), you should treat it as regular characters.

","def isValid(self, code: str) -> bool:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def isValid(self, code: str) -> bool:
    if code[0] != '<' or code[-1] != '>':
      return False

    containsTag = False
    stack = []

    def isValidCdata(s: str) -> bool:
      return s.find('[CDATA[') == 0

    def isValidTagName(tagName: str, isEndTag: bool) -> bool:
      nonlocal containsTag
      if not tagName or len(tagName) > 9:
        return False
      if any(not c.isupper() for c in tagName):
        return False

      if isEndTag:
        return stack and stack.pop() == tagName

      containsTag = True
      stack.append(tagName)
      return True

    i = 0
    while i < len(code):
      if not stack and containsTag:
        return False
      if code[i] == '<':
        if stack and code[i + 1] == '!':
          closeIndex = code.find(']]>', i + 2)
          if closeIndex == -1 or not isValidCdata(code[i + 2:closeIndex]):
            return False
        elif code[i + 1] == '/':
          closeIndex = code.find('>', i + 2)
          if closeIndex == -1 or not isValidTagName(code[i + 2:closeIndex], True):
            return False
        else:
          closeIndex = code.find('>', i + 1)
          if closeIndex == -1 or not isValidTagName(code[i + 1:closeIndex], False):
            return False
        i = closeIndex
      i += 1

    return not stack and containsTag
"
581,"Given an integer array `nums`, you need to find one continuous subarray such
that if you only sort this subarray in non-decreasing order, then the whole
array will be sorted in non-decreasing order.

Return the shortest such subarray and output its length.

","def findUnsortedSubarray(self, nums: List[int]) -> int:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def findUnsortedSubarray(self, nums: List[int]) -> int:
    mini = math.inf
    maxi = -math.inf
    flag = False

    for i in range(1, len(nums)):
      if nums[i] < nums[i - 1]:
        flag = True
      if flag:
        mini = min(mini, nums[i])

    flag = False

    for i in reversed(range(len(nums) - 1)):
      if nums[i] > nums[i + 1]:
        flag = True
      if flag:
        maxi = max(maxi, nums[i])

    for l in range(len(nums)):
      if nums[l] > mini:
        break

    for r, num in reversed(list(enumerate(nums))):
      if num < maxi:
        break

    return 0 if l >= r else r - l + 1
"
327,"Given an integer array `nums` and two integers `lower` and `upper`, return the
number of range sums that lie in `[lower, upper]` inclusive.

Range sum `S(i, j)` is defined as the sum of the elements in `nums` between
indices `i` and `j` inclusive, where `i <= j`.

","def countRangeSum(self, nums: List[int], lower: int, upper: int) -> int:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def countRangeSum(self, nums: List[int], lower: int, upper: int) -> int:
    n = len(nums)
    self.ans = 0
    prefix = [0] + list(itertools.accumulate(nums))

    self._mergeSort(prefix, 0, n, lower, upper)
    return self.ans

  def _mergeSort(self, prefix: List[int], l: int, r: int, lower: int, upper: int) -> None:
    if l >= r:
      return

    m = (l + r) // 2
    self._mergeSort(prefix, l, m, lower, upper)
    self._mergeSort(prefix, m + 1, r, lower, upper)
    self._merge(prefix, l, m, r, lower, upper)

  def _merge(self, prefix: List[int], l: int, m: int, r: int, lower: int, upper: int) -> None:
    lo = m + 1
    hi = m + 1

    for i in range(l, m + 1):
      while lo <= r and prefix[lo] - prefix[i] < lower:
        lo += 1
      while hi <= r and prefix[hi] - prefix[i] <= upper:
        hi += 1
      self.ans += hi - lo

    sorted = [0] * (r - l + 1)
    k = 0
    i = l
    j = m + 1

    while i <= m and j <= r:
      if prefix[i] < prefix[j]:
        sorted[k] = prefix[i]
        k += 1
        i += 1
      else:
        sorted[k] = prefix[j]
        k += 1
        j += 1

    while i <= m:
      sorted[k] = prefix[i]
      k += 1
      i += 1

    while j <= r:
      sorted[k] = prefix[j]
      k += 1
      j += 1

    prefix[l:l + len(sorted)] = sorted
"
15,"Given an integer array nums, return all the triplets `[nums[i], nums[j],
nums[k]]` such that `i != j`, `i != k`, and `j != k`, and `nums[i] + nums[j] +
nums[k] == 0`.

Notice that the solution set must not contain duplicate triplets.

","def threeSum(self, nums: List[int]) -> List[List[int]]:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def threeSum(self, nums: List[int]) -> List[List[int]]:
    if len(nums) < 3:
      return []

    ans = []

    nums.sort()

    for i in range(len(nums) - 2):
      if i > 0 and nums[i] == nums[i - 1]:
        continue

      l = i + 1
      r = len(nums) - 1
      while l < r:
        summ = nums[i] + nums[l] + nums[r]
        if summ == 0:
          ans.append((nums[i], nums[l], nums[r]))
          l += 1
          r -= 1
          while nums[l] == nums[l - 1] and l < r:
            l += 1
          while nums[r] == nums[r + 1] and l < r:
            r -= 1
        elif summ < 0:
          l += 1
        else:
          r -= 1

    return ans
"
44,"Given an input string (`s`) and a pattern (`p`), implement wildcard pattern
matching with support for `'?'` and `'*'` where:

* `'?'` Matches any single character.
* `'*'` Matches any sequence of characters (including the empty sequence).

The matching should cover the entire input string (not partial).

","def isMatch(self, s: str, p: str) -> bool:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def isMatch(self, s: str, p: str) -> bool:
    m = len(s)
    n = len(p)
    dp = [[False] * (n + 1) for _ in range(m + 1)]
    dp[0][0] = True

    def isMatch(i: int, j: int) -> bool:
      return i >= 0 and p[j] == '?' or s[i] == p[j]

    for j, c in enumerate(p):
      if c == '*':
        dp[0][j + 1] = dp[0][j]

    for i in range(m):
      for j in range(n):
        if p[j] == '*':
          matchEmpty = dp[i + 1][j]
          matchSome = dp[i][j + 1]
          dp[i + 1][j + 1] = matchEmpty or matchSome
        elif isMatch(i, j):
          dp[i + 1][j + 1] = dp[i][j]

    return dp[m][n]
"
65,"A valid number can be split up into these components (in order):

1. A decimal number or an integer.
2. (Optional) An `'e'` or `'E'`, followed by an integer.

A decimal number can be split up into these components (in order):

1. (Optional) A sign character (either `'+'` or `'-'`).
2. One of the following formats: 
1. One or more digits, followed by a dot `'.'`.
2. One or more digits, followed by a dot `'.'`, followed by one or more digits.
3. A dot `'.'`, followed by one or more digits.

An integer can be split up into these components (in order):

1. (Optional) A sign character (either `'+'` or `'-'`).
2. One or more digits.

For example, all the following are valid numbers: `[""2"", ""0089"", ""-0.1"",
""+3.14"", ""4."", ""-.9"", ""2e10"", ""-90E3"", ""3e+7"", ""+6e-1"", ""53.5e93"",
""-123.456e789""]`, while the following are not valid numbers: `[""abc"", ""1a"",
""1e"", ""e3"", ""99e2.5"", ""--6"", ""-+3"", ""95a54e53""]`.

Given a string `s`, return `true` if `s` is a valid number.

","def isNumber(self, s: str) -> bool:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def isNumber(self, s: str) -> bool:
    s = s.strip()
    if not s:
      return False

    seenNum = False
    seenDot = False
    seenE = False

    for i, c in enumerate(s):
      if c == '.':
        if seenDot or seenE:
          return False
        seenDot = True
      elif c == 'e' or c == 'E':
        if seenE or not seenNum:
          return False
        seenE = True
        seenNum = False
      elif c in '+-':
        if i > 0 and s[i - 1] not in 'eE':
          return False
        seenNum = False
      else:
        if not c.isdigit():
          return False
        seenNum = True

    return seenNum
"
97,"Given strings `s1`, `s2`, and `s3`, find whether `s3` is formed by an
interleaving of `s1` and `s2`.

An interleaving of two strings `s` and `t` is a configuration where `s` and
`t` are divided into `n` and `m` substrings respectively, such that:

* `s = s1 + s2 + ... + sn`
* `t = t1 + t2 + ... + tm`
* `|n - m| <= 1`
* The interleaving is `s1 + t1 + s2 + t2 + s3 + t3 + ...` or `t1 + s1 + t2 + s2 + t3 + s3 + ...`

Note: `a + b` is the concatenation of strings `a` and `b`.

","def isInterleave(self, s1: str, s2: str, s3: str) -> bool:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def isInterleave(self, s1: str, s2: str, s3: str) -> bool:
    m = len(s1)
    n = len(s2)
    if m + n != len(s3):
      return False

    dp=[]
    for _ in range(m + 1):
      dp.append([False] * (n + 1))
    dp[0][0] = True

    for i in range(1, m + 1):
      dp[i][0] = dp[i - 1][0] and s1[i - 1] == s3[i - 1]

    for j in range(1, n + 1):
      dp[0][j] = dp[0][j - 1] and s2[j - 1] == s3[j - 1]

    for i in range(1, m + 1):
      for j in range(1, n + 1):
        dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])

    return dp[m][n]
"
126,"A transformation sequence from word `beginWord` to word `endWord` using a
dictionary `wordList` is a sequence of words `beginWord -> s1 -> s2 -> ... ->
sk` such that:

* Every adjacent pair of words differs by a single letter.
* Every `si` for `1 <= i <= k` is in `wordList`. Note that `beginWord` does not need to be in `wordList`.
* `sk == endWord`

Given two words, `beginWord` and `endWord`, and a dictionary `wordList`,
return all the shortest transformation sequences from `beginWord` to
`endWord`, or an empty list if no such sequence exists. Each sequence should
be returned as a list of the words `[beginWord, s1, s2, ..., sk]`.

","def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator, Set

class Solution:
  def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:
    from collections import deque
    def connected(a: str, b: str) -> bool:
      k = 0
      for i in range(len(a)):
        if a[i] != b[i]:
          k += 1
      return k == 1

    if endWord not in wordList:
      return []

    visited = set([beginWord])

    q = deque([beginWord])
    nodes = []
    find = False

    while q and not find:
      nodes.append(q.copy())
      n = len(q)
      for _ in range(n):
        word = q.popleft()
        for item in wordList:
          if item in visited:
            continue
          if not connected(word, item):
            continue
          if item == endWord:
            find = True
            break
          visited.add(item)
          q.append(item)
        if find:
          break

    if not find:
      return []

    ans = []

    def backtracking(word, level: int, steps: List[str]):
      if word == beginWord:
        ans.append(steps[::-1])
        return
      if level < 0:
        return
      for item in nodes[level]:
        if connected(item, word):
          steps.append(item)
          backtracking(item, level-1, steps)
          steps.pop()

    backtracking(endWord, len(nodes)-1, [endWord])
    return ans
"
132,"Given a string `s`, partition `s` such that every substring of the partition
is a palindrome.

Return the minimum cuts needed for a palindrome partitioning of `s`.

","def minCut(self, s: str) -> int:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def minCut(self, s: str) -> int:
    n = len(s)
    isPalindrome=[]
    for _ in range(n):
      isPalindrome.append([True] * n)
    dp = [n] * n

    for l in range(2, n + 1):
      i = 0
      for j in range(l - 1, n):
        isPalindrome[i][j] = s[i] == s[j] and isPalindrome[i + 1][j - 1]
        i += 1

    for i in range(n):
      if isPalindrome[0][i]:
        dp[i] = 0
        continue

      for j in range(i):
        if isPalindrome[j + 1][i]:
          dp[i] = min(dp[i], dp[j] + 1)

    return dp[-1]
"
218,"A city's skyline is the outer contour of the silhouette formed by all the
buildings in that city when viewed from a distance. Given the locations and
heights of all the buildings, return the skyline formed by these buildings
collectively.

The geometric information of each building is given in the array `buildings`
where `buildings[i] = [lefti, righti, heighti]`:

* `lefti` is the x coordinate of the left edge of the `ith` building.
* `righti` is the x coordinate of the right edge of the `ith` building.
* `heighti` is the height of the `ith` building.

You may assume all buildings are perfect rectangles grounded on an absolutely
flat surface at height `0`.

The skyline should be represented as a list of ""key points"" sorted by their
x-coordinate in the form `[[x1,y1],[x2,y2],...]`. Each key point is the left
endpoint of some horizontal segment in the skyline except the last point in
the list, which always has a y-coordinate `0` and is used to mark the
skyline's termination where the rightmost building ends. Any ground between
the leftmost and rightmost buildings should be part of the skyline's contour.

Note: There must be no consecutive horizontal lines of equal height in the
output skyline. For instance, `[...,[2 3],[4 5],[7 5],[11 5],[12 7],...]` is
not acceptable; the three lines of height 5 should be merged into one in the
final output as such: `[...,[2 3],[4 5],[12 7],...]`

","def getSkyline(self, buildings: List[List[int]]) -> List[List[int]]:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def getSkyline(self, buildings: List[List[int]]) -> List[List[int]]:
    n = len(buildings)
    if n == 0:
      return []
    if n == 1:
      left, right, height = buildings[0]
      return [[left, height], [right, 0]]

    left = self.getSkyline(buildings[:n // 2])
    right = self.getSkyline(buildings[n // 2:])
    return self._merge(left, right)

  def _merge(self, left: List[List[int]], right: List[List[int]]) -> List[List[int]]:
    ans = []
    i = 0
    j = 0
    leftY = 0
    rightY = 0

    while i < len(left) and j < len(right):
      if left[i][0] < right[j][0]:
        leftY = left[i][1]
        self._addPoint(ans, left[i][0], max(left[i][1], rightY))
        i += 1
      else:
        rightY = right[j][1]
        self._addPoint(ans, right[j][0], max(right[j][1], leftY))
        j += 1

    while i < len(left):
      self._addPoint(ans, left[i][0], left[i][1])
      i += 1

    while j < len(right):
      self._addPoint(ans, right[j][0], right[j][1])
      j += 1

    return ans

  def _addPoint(self, ans: List[List[int]], x: int, y: int) -> None:
    if ans and ans[-1][0] == x:
      ans[-1][1] = y
      return
    if ans and ans[-1][1] == y:
      return
    ans.append([x, y])
"
227,"Given a string `s` which represents an expression, evaluate this expression
and return its value.

The integer division should truncate toward zero.

You may assume that the given expression is always valid. All intermediate
results will be in the range of `[-231, 231 - 1]`.

Note: You are not allowed to use any built-in function which evaluates strings
as mathematical expressions, such as `eval()`.

","def calculate(self, s: str) -> int:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def calculate(self, s: str) -> int:
    ans = 0
    prevNum = 0
    currNum = 0
    op = '+'

    for i, c in enumerate(s):
      if c.isdigit():
        currNum = currNum * 10 + int(c)
      if not c.isdigit() and c != ' ' or i == len(s) - 1:
        if op == '+' or op == '-':
          ans += prevNum
          prevNum = currNum if op == '+' else -currNum
        elif op == '*':
          prevNum = prevNum * currNum
        elif op == '/':
          if prevNum < 0:
            prevNum = math.ceil(prevNum / currNum)
          else:
            prevNum = prevNum // currNum
        op = c
        currNum = 0

    return ans + prevNum
"
310,"A tree is an undirected graph in which any two vertices are connected by
exactly one path. In other words, any connected graph without simple cycles is
a tree.

Given a tree of `n` nodes labelled from `0` to `n - 1`, and an array of `n -
1` `edges` where `edges[i] = [ai, bi]` indicates that there is an undirected
edge between the two nodes `ai` and `bi` in the tree, you can choose any node
of the tree as the root. When you select a node `x` as the root, the result
tree has height `h`. Among all possible rooted trees, those with minimum
height (i.e. `min(h)`) are called minimum height trees (MHTs).

Return a list of all MHTs' root labels. You can return the answer in any
order.

The height of a rooted tree is the number of edges on the longest downward
path between the root and a leaf.

","def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:
    if n == 1 or not edges:
      return [0]

    ans = []
    graph = collections.defaultdict(set)

    for u, v in edges:
      graph[u].add(v)
      graph[v].add(u)

    for label, children in graph.items():
      if len(children) == 1:
        ans.append(label)

    while n > 2:
      n -= len(ans)
      nextLeaves = []
      for leaf in ans:
        u = next(iter(graph[leaf]))
        graph[u].remove(leaf)
        if len(graph[u]) == 1:
          nextLeaves.append(u)
      ans = nextLeaves

    return ans
"
335,"You are given an array of integers `distance`.

You start at the point `(0, 0)` on an X-Y plane, and you move `distance[0]`
meters to the north, then `distance[1]` meters to the west, `distance[2]`
meters to the south, `distance[3]` meters to the east, and so on. In other
words, after each move, your direction changes counter-clockwise.

Return `true` if your path crosses itself or `false` if it does not.

","def isSelfCrossing(self, x: List[int]) -> bool:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def isSelfCrossing(self, x: List[int]) -> bool:
    if len(x) <= 3:
      return False

    for i in range(3, len(x)):
      if x[i - 2] <= x[i] and x[i - 1] <= x[i - 3]:
        return True
      if i >= 4 and x[i - 1] == x[i - 3] and x[i - 2] <= x[i] + x[i - 4]:
        return True
      if i >= 5 and x[i - 4] <= x[i - 2] and x[i - 2] <= x[i] + x[i - 4] and x[i - 1] <= x[i - 3] and x[i - 3] <= x[i - 1] + x[i - 5]:
        return True

    return False
"
542,"Given an `m x n` binary matrix `mat`, return the distance of the nearest `0`
for each cell.

The distance between two adjacent cells is `1`.

","def updateMatrix(self, mat: List[List[int]]) -> List[List[int]]:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def updateMatrix(self, mat: List[List[int]]) -> List[List[int]]:
    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))
    m = len(mat)
    n = len(mat[0])
    q = collections.deque()
    seen = [[False] * n for _ in range(m)]

    for i in range(m):
      for j in range(n):
        if mat[i][j] == 0:
          q.append((i, j))
          seen[i][j] = True

    while q:
      i, j = q.popleft()
      for dx, dy in dirs:
        x = i + dx
        y = j + dy
        if x < 0 or x == m or y < 0 or y == n:
          continue
        if seen[x][y]:
          continue
        mat[x][y] = mat[i][j] + 1
        q.append((x, y))
        seen[x][y] = True

    return mat
"
336,"You are given a 0-indexed array of unique strings `words`.

A palindrome pair is a pair of integers `(i, j)` such that:

* `0 <= i, j < words.length`,
* `i != j`, and
* `words[i] + words[j]` (the concatenation of the two strings) is a palindrome.

Return an array of all the palindrome pairs of `words`.

You must write an algorithm with `O(sum of words[i].length)` runtime
complexity.

","def palindromePairs(self, words: List[str]) -> List[List[int]]:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def palindromePairs(self, words: List[str]) -> List[List[int]]:
    ans = []
    dict = {word[::-1]: i for i, word in enumerate(words)}

    for i, word in enumerate(words):
      if """" in dict and dict[""""] != i and word == word[::-1]:
        ans.append([i, dict[""""]])

      for j in range(1, len(word) + 1):
        l = word[:j]
        r = word[j:]
        if l in dict and dict[l] != i and r == r[::-1]:
          ans.append([i, dict[l]])
        if r in dict and dict[r] != i and l == l[::-1]:
          ans.append([dict[r], i])

    return ans
"
391,"Given an array `rectangles` where `rectangles[i] = [xi, yi, ai, bi]`
represents an axis-aligned rectangle. The bottom-left point of the rectangle
is `(xi, yi)` and the top-right point of it is `(ai, bi)`.

Return `true` if all the rectangles together form an exact cover of a
rectangular region.

","def isRectangleCover(self, rectangles: List[List[int]]) -> bool:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator, Set

class Solution:
  def isRectangleCover(self, rectangles: List[List[int]]) -> bool:
    area = 0
    x1 = math.inf
    y1 = math.inf
    x2 = -math.inf
    y2 = -math.inf
    corners: Set[Tuple[int, int]] = set()

    for x, y, a, b in rectangles:
      area += (a - x) * (b - y)
      x1 = min(x1, x)
      y1 = min(y1, y)
      x2 = max(x2, a)
      y2 = max(y2, b)

      for point in [(x, y), (x, b), (a, y), (a, b)]:
        if point in corners:
          corners.remove(point)
        else:
          corners.add(point)

    if len(corners) != 4:
      return False
    if (x1, y1) not in corners or (x1, y2) not in corners or (x2, y1) not in corners or (x2, y2) not in corners:
      return False
    return area == (x2 - x1) * (y2 - y1)
"
402,"Given string num representing a non-negative integer `num`, and an integer
`k`, return the smallest possible integer after removing `k` digits from
`num`.

","def removeKdigits(self, num: str, k: int) -> str:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def removeKdigits(self, num: str, k: int) -> str:
    if len(num) == k:
      return '0'

    ans = []
    stack = []

    for i, digit in enumerate(num):
      while k > 0 and stack and stack[-1] > digit:
        stack.pop()
        k -= 1
      stack.append(digit)

    for _ in range(k):
      stack.pop()

    for c in stack:
      if c == '0' and not ans:
        continue
      ans.append(c)

    return ''.join(ans) if ans else '0'
"
407,"Given an `m x n` integer matrix `heightMap` representing the height of each
unit cell in a 2D elevation map, return the volume of water it can trap after
raining.

","def trapRainWater(self, heightMap: List[List[int]]) -> int:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def trapRainWater(self, heightMap: List[List[int]]) -> int:
    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))
    m = len(heightMap)
    n = len(heightMap[0])
    ans = 0
    minHeap = []
    seen = set()

    for i in range(m):
      heapq.heappush(minHeap, (heightMap[i][0], i, 0))
      heapq.heappush(minHeap, (heightMap[i][n - 1], i, n - 1))
      seen.add((i, 0))
      seen.add((i, n - 1))

    for j in range(1, n - 1):
      heapq.heappush(minHeap, (heightMap[0][j], 0, j))
      heapq.heappush(minHeap, (heightMap[m - 1][j], m - 1, j))
      seen.add((0, j))
      seen.add((m - 1, j))

    while minHeap:
      h, i, j = heapq.heappop(minHeap)
      for dx, dy in dirs:
        x = i + dx
        y = j + dy
        if x < 0 or x == m or y < 0 or y == n:
          continue
        if (x, y) in seen:
          continue
        if heightMap[x][y] < h:
          ans += h - heightMap[x][y]
          heapq.heappush(minHeap, (h, x, y))
        else:
          heapq.heappush(minHeap, (heightMap[x][y], x, y))
        seen.add((x, y))

    return ans
"
417,"There is an `m x n` rectangular island that borders both the Pacific Ocean and
Atlantic Ocean. The Pacific Ocean touches the island's left and top edges, and
the Atlantic Ocean touches the island's right and bottom edges.

The island is partitioned into a grid of square cells. You are given an `m x
n` integer matrix `heights` where `heights[r][c]` represents the height above
sea level of the cell at coordinate `(r, c)`.

The island receives a lot of rain, and the rain water can flow to neighboring
cells directly north, south, east, and west if the neighboring cell's height
is less than or equal to the current cell's height. Water can flow from any
cell adjacent to an ocean into the ocean.

Return a 2D list of grid coordinates `result` where `result[i] = [ri, ci]`
denotes that rain water can flow from cell `(ri, ci)` to both the Pacific and
Atlantic oceans.

","def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:
    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))
    m = len(heights)
    n = len(heights[0])
    qP = collections.deque()
    qA = collections.deque()
    seenP = [[False] * n for _ in range(m)]
    seenA = [[False] * n for _ in range(m)]

    for i in range(m):
      qP.append((i, 0))
      qA.append((i, n - 1))
      seenP[i][0] = True
      seenA[i][n - 1] = True

    for j in range(n):
      qP.append((0, j))
      qA.append((m - 1, j))
      seenP[0][j] = True
      seenA[m - 1][j] = True

    def bfs(q: collections.deque, seen: List[List[bool]]):
      while q:
        i, j = q.popleft()
        h = heights[i][j]
        for dx, dy in dirs:
          x = i + dx
          y = j + dy
          if x < 0 or x == m or y < 0 or y == n:
            continue
          if seen[x][y] or heights[x][y] < h:
            continue
          q.append((x, y))
          seen[x][y] = True

    bfs(qP, seenP)
    bfs(qA, seenA)

    res=[]
    for i in range(m):
      for j in range(n):
        if seenP[i][j] and seenA[i][j]:
          res.append([i, j])
    return res
"
420,"A password is considered strong if the below conditions are all met:

* It has at least `6` characters and at most `20` characters.
* It contains at least one lowercase letter, at least one uppercase letter, and at least one digit.
* It does not contain three repeating characters in a row (i.e., `""Baaabb0""` is weak, but `""Baaba0""` is strong).

Given a string `password`, return the minimum number of steps required to make
`password` strong. if `password` is already strong, return `0`.

In one step, you can:

* Insert one character to `password`,
* Delete one character from `password`, or
* Replace one character of `password` with another character.

","def strongPasswordChecker(self, password: str) -> int:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def strongPasswordChecker(self, password: str) -> int:
    n = len(password)
    missing = self._getMissing(password)
    replaces = 0
    oneSeq = 0
    twoSeq = 0

    i = 2
    while i < n:
      if password[i] == password[i - 1] and password[i - 1] == password[i - 2]:
        length = 2
        while i < n and password[i] == password[i - 1]:
          length += 1
          i += 1
        replaces += length // 3
        if length % 3 == 0:
          oneSeq += 1
        if length % 3 == 1:
          twoSeq += 1
      else:
        i += 1

    if n < 6:
      return max(6 - n, missing)
    if n <= 20:
      return max(replaces, missing)

    deletes = n - 20
    replaces -= min(oneSeq, deletes)
    replaces -= min(max(deletes - oneSeq, 0), twoSeq * 2) // 2
    replaces -= max(deletes - oneSeq - twoSeq * 2, 0) // 3
    return deletes + max(replaces, missing)

  def _getMissing(self, password: str) -> int:
    return 3 - any(c.isupper() for c in password) - any(c.islower() for c in password) - any(c.isdigit() for c in password)
"
423,"Given a string `s` containing an out-of-order English representation of digits
`0-9`, return the digits in ascending order.

","def originalDigits(self, s: str) -> str:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def originalDigits(self, s: str) -> str:
    count = [0] * 10

    for c in s:
      if c == 'z':
        count[0] += 1
      if c == 'o':
        count[1] += 1
      if c == 'w':
        count[2] += 1
      if c == 'h':
        count[3] += 1
      if c == 'u':
        count[4] += 1
      if c == 'f':
        count[5] += 1
      if c == 'x':
        count[6] += 1
      if c == 's':
        count[7] += 1
      if c == 'g':
        count[8] += 1
      if c == 'i':
        count[9] += 1

    count[1] -= count[0] + count[2] + count[4]
    count[3] -= count[8]
    count[5] -= count[4]
    count[7] -= count[6]
    count[9] -= count[5] + count[6] + count[8]

    return ''.join(chr(i + ord('0')) for i, c in enumerate(count) for j in range(c))
"
457,"You are playing a game involving a circular array of non-zero integers `nums`.
Each `nums[i]` denotes the number of indices forward/backward you must move if
you are located at index `i`:

* If `nums[i]` is positive, move `nums[i]` steps forward, and
* If `nums[i]` is negative, move `nums[i]` steps backward.

Since the array is circular, you may assume that moving forward from the last
element puts you on the first element, and moving backwards from the first
element puts you on the last element.

A cycle in the array consists of a sequence of indices `seq` of length `k`
where:

* Following the movement rules above results in the repeating index sequence `seq[0] -> seq[1] -> ... -> seq[k - 1] -> seq[0] -> ...`
* Every `nums[seq[j]]` is either all positive or all negative.
* `k > 1`

Return `true` if there is a cycle in `nums`, or `false` otherwise.

","def circularArrayLoop(self, nums: List[int]) -> bool:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def circularArrayLoop(self, nums: List[int]) -> bool:
    def advance(i: int) -> int:
      return (i + nums[i]) % len(nums)

    if len(nums) < 2:
      return False

    for i, num in enumerate(nums):
      if num == 0:
        continue

      slow = i
      fast = advance(slow)
      while num * nums[fast] > 0 and num * nums[advance(fast)] > 0:
        if slow == fast:
          if slow == advance(slow):
            break
          return True
        slow = advance(slow)
        fast = advance(advance(fast))

      slow = i
      sign = num
      while sign * nums[slow] > 0:
        next = advance(slow)
        nums[slow] = 0
        slow = next

    return False
"
524,"Given a string `s` and a string array `dictionary`, return the longest string
in the dictionary that can be formed by deleting some of the given string
characters. If there is more than one possible result, return the longest word
with the smallest lexicographical order. If there is no possible result,
return the empty string.

","def findLongestWord(self, s: str, d: List[str]) -> str:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def findLongestWord(self, s: str, d: List[str]) -> str:
    ans = ''

    for word in d:
      i = 0
      for c in s:
        if i < len(word) and c == word[i]:
          i += 1
      if i == len(word):
        if len(word) > len(ans) or len(word) == len(ans) and word < ans:
          ans = word

    return ans
"
909,"You are given an `n x n` integer matrix `board` where the cells are labeled
from `1` to `n2` in a Boustrophedon style starting from the bottom left of the
board (i.e. `board[n - 1][0]`) and alternating direction each row.

You start on square `1` of the board. In each move, starting from square
`curr`, do the following:

* Choose a destination square `next` with a label in the range `[curr + 1, min(curr + 6, n2)]`. 
* This choice simulates the result of a standard 6-sided die roll: i.e., there are always at most 6 destinations, regardless of the size of the board.
* If `next` has a snake or ladder, you must move to the destination of that snake or ladder. Otherwise, you move to `next`.
* The game ends when you reach the square `n2`.

A board square on row `r` and column `c` has a snake or ladder if `board[r][c]
!= -1`. The destination of that snake or ladder is `board[r][c]`. Squares `1`
and `n2` do not have a snake or ladder.

Note that you only take a snake or ladder at most once per move. If the
destination to a snake or ladder is the start of another snake or ladder, you
do not follow the subsequent snake or ladder.

* For example, suppose the board is `[[-1,4],[-1,3]]`, and on the first move, your destination square is `2`. You follow the ladder to square `3`, but do not follow the subsequent ladder to `4`.

Return the least number of moves required to reach the square `n2`. If it is
not possible to reach the square, return `-1`.

","def snakesAndLadders(self, board: List[List[int]]) -> int:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def snakesAndLadders(self, board: List[List[int]]) -> int:
    n = len(board)
    ans = 0
    q = collections.deque([1])
    seen = set()
    A = [0] * (1 + n * n)

    for i in range(n):
      for j in range(n):
        if n - i & 1 :
          A[(n - 1 - i) * n + (j + 1)] = board[i][j]
        else:
          A[(n - 1 - i) * n + (n - j)] = board[i][j]

    while q:
      ans += 1
      for _ in range(len(q)):
        curr = q.popleft()
        for next in range(curr + 1, min(curr + 6, n * n) + 1):
          dest = A[next] if A[next] > 0 else next
          if dest == n * n:
            return ans
          if dest in seen:
            continue
          q.append(dest)
          seen.add(dest)

    return -1
"
923,"Given an integer array `arr`, and an integer `target`, return the number of
tuples `i, j, k` such that `i < j < k` and `arr[i] + arr[j] + arr[k] ==
target`.

As the answer can be very large, return it modulo `109 + 7`.

","def threeSumMulti(self, arr: List[int], target: int) -> int:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def threeSumMulti(self, arr: List[int], target: int) -> int:
    kMod = 1_000_000_007
    ans = 0
    count = collections.Counter(arr)

    for i, x in count.items():
      for j, y in count.items():
        k = target - i - j
        if k not in count:
          continue
        if i == j and j == k:
          ans = (ans + x * (x - 1) * (x - 2) // 6) % kMod
        elif i == j and j != k:
          ans = (ans + x * (x - 1) // 2 * count[k]) % kMod
        elif i < j and j < k:
          ans = (ans + x * y * count[k]) % kMod

    return ans % kMod
"
1782,"You are given an undirected graph defined by an integer `n`, the number of
nodes, and a 2D integer array `edges`, the edges in the graph, where `edges[i]
= [ui, vi]` indicates that there is an undirected edge between `ui` and `vi`.
You are also given an integer array `queries`.

Let `incident(a, b)` be defined as the number of edges that are connected to
either node `a` or `b`.

The answer to the `jth` query is the number of pairs of nodes `(a, b)` that
satisfy both of the following conditions:

* `a < b`
* `incident(a, b) > queries[j]`

Return an array `answers` such that `answers.length == queries.length` and
`answers[j]` is the answer of the `jth` query.

Note that there can be multiple edges between the same two nodes.

","def countPairs(self, n: int, edges: List[List[int]], queries: List[int]) -> List[int]:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def countPairs(self, n: int, edges: List[List[int]], queries: List[int]) -> List[int]:
    ans = [0] * len(queries)

    count = [0] * (n + 1)

    shared = [collections.Counter() for _ in range(n + 1)]

    for u, v in edges:
      count[u] += 1
      count[v] += 1
      shared[min(u, v)][max(u, v)] += 1

    sortedCount = sorted(count)

    for k, query in enumerate(queries):
      i = 1
      j = n
      while i < j:
        if sortedCount[i] + sortedCount[j] > query:
          ans[k] += j - i
          j -= 1
        else:
          i += 1
      for i in range(1, n + 1):
        for j, sh in shared[i].items():
          if count[i] + count[j] > query and count[i] + count[j] - sh <= query:
            ans[k] -= 1

    return ans
"
927,"You are given an array `arr` which consists of only zeros and ones, divide the
array into three non-empty parts such that all of these parts represent the
same binary value.

If it is possible, return any `[i, j]` with `i + 1 < j`, such that:

* `arr[0], arr[1], ..., arr[i]` is the first part,
* `arr[i + 1], arr[i + 2], ..., arr[j - 1]` is the second part, and
* `arr[j], arr[j + 1], ..., arr[arr.length - 1]` is the third part.
* All three parts have equal binary values.

If it is not possible, return `[-1, -1]`.

Note that the entire part is used when considering what binary value it
represents. For example, `[1,1,0]` represents `6` in decimal, not `3`. Also,
leading zeros are allowed, so `[0,1,1]` and `[1,1]` represent the same value.

","def threeEqualParts(self, arr: List[int]) -> List[int]:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def threeEqualParts(self, arr: List[int]) -> List[int]:
    ones = sum(a == 1 for a in arr)

    if ones == 0:
      return [0, len(arr) - 1]
    if ones % 3 != 0:
      return [-1, -1]

    k = ones // 3
    i = 0

    for i in range(len(arr)):
      if arr[i] == 1:
        first = i
        break

    gapOnes = k

    for j in range(i + 1, len(arr)):
      if arr[j] == 1:
        gapOnes -= 1
        if gapOnes == 0:
          second = j
          break

    gapOnes = k

    for i in range(j + 1, len(arr)):
      if arr[i] == 1:
        gapOnes -= 1
        if gapOnes == 0:
          third = i
          break

    while third < len(arr) and arr[first] == arr[second] == arr[third]:
      first += 1
      second += 1
      third += 1

    if third == len(arr):
      return [first - 1, second]
    return [-1, -1]
"
1582,"Given an `m x n` binary matrix `mat`, return the number of special positions
in `mat`.

A position `(i, j)` is called special if `mat[i][j] == 1` and all other
elements in row `i` and column `j` are `0` (rows and columns are 0-indexed).

","def numSpecial(self, mat: List[List[int]]) -> int:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def numSpecial(self, mat: List[List[int]]) -> int:
    m = len(mat)
    n = len(mat[0])
    ans = 0
    rowOnes = [0] * m
    colOnes = [0] * n

    for i in range(m):
      for j in range(n):
        if mat[i][j] == 1:
          rowOnes[i] += 1
          colOnes[j] += 1

    for i in range(m):
      for j in range(n):
        if mat[i][j] == 1 and rowOnes[i] == 1 and colOnes[j] == 1:
          ans += 1

    return ans
"
1583,"You are given a list of `preferences` for `n` friends, where `n` is always
even.

For each person `i`, `preferences[i]` contains a list of friends sorted in the
order of preference. In other words, a friend earlier in the list is more
preferred than a friend later in the list. Friends in each list are denoted by
integers from `0` to `n-1`.

All the friends are divided into pairs. The pairings are given in a list
`pairs`, where `pairs[i] = [xi, yi]` denotes `xi` is paired with `yi` and `yi`
is paired with `xi`.

However, this pairing may cause some of the friends to be unhappy. A friend
`x` is unhappy if `x` is paired with `y` and there exists a friend `u` who is
paired with `v` but:

* `x` prefers `u` over `y`, and
* `u` prefers `x` over `v`.

Return the number of unhappy friends.

","def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:
    ans = 0
    matches = [0] * n
    prefer = [{} for _ in range(n)]

    for x, y in pairs:
      matches[x] = y
      matches[y] = x

    for i in range(n):
      for j in range(n - 1):
        prefer[i][preferences[i][j]] = j

    for x in range(n):
      for u in prefer[x].keys():
        y = matches[x]
        v = matches[u]
        if prefer[x][u] < prefer[x][y] and prefer[u][x] < prefer[u][v]:
          ans += 1
          break

    return ans
"
1591,"There is a strange printer with the following two special requirements:

* On each turn, the printer will print a solid rectangular pattern of a single color on the grid. This will cover up the existing colors in the rectangle.
* Once the printer has used a color for the above operation, the same color cannot be used again.

You are given a `m x n` matrix `targetGrid`, where `targetGrid[row][col]` is
the color in the position `(row, col)` of the grid.

Return `true` if it is possible to print the matrix `targetGrid`, otherwise,
return `false`.

","def isPrintable(self, targetGrid: List[List[int]]) -> bool:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

from enum import Enum


class State(Enum):
  kInit = 0
  kVisiting = 1
  kVisited = 2


class Solution:
  def isPrintable(self, targetGrid: List[List[int]]) -> bool:
    kMaxColor = 60
    m = len(targetGrid)
    n = len(targetGrid[0])

    graph = [set() for _ in range(kMaxColor + 1)]

    for color in range(1, kMaxColor + 1):
      minI = m
      minJ = n
      maxI = -1
      maxJ = -1
      for i in range(m):
        for j in range(n):
          if targetGrid[i][j] == color:
            minI = min(minI, i)
            minJ = min(minJ, j)
            maxI = max(maxI, i)
            maxJ = max(maxJ, j)

      for i in range(minI, maxI + 1):
        for j in range(minJ, maxJ + 1):
          if targetGrid[i][j] != color:
            graph[color].add(targetGrid[i][j])

    states = [State.kInit] * (kMaxColor + 1)

    def hasCycle(u: int) -> bool:
      if states[u] == State.kVisiting:
        return True
      if states[u] == State.kVisited:
        return False

      states[u] = State.kVisiting
      if any(hasCycle(v) for v in graph[u]):
        return True
      states[u] = State.kVisited

      return False

    for i in range(1, kMaxColor + 1):
      if hasCycle(i):
        return False
    return True
"
1604,"LeetCode company workers use key-cards to unlock office doors. Each time a
worker uses their key-card, the security system saves the worker's name and
the time when it was used. The system emits an alert if any worker uses the
key-card three or more times in a one-hour period.

You are given a list of strings `keyName` and `keyTime` where `[keyName[i],
keyTime[i]]` corresponds to a person's name and the time when their key-card
was used in a single day.

Access times are given in the 24-hour time format ""HH:MM"", such as `""23:51""`
and `""09:49""`.

Return a list of unique worker names who received an alert for frequent
keycard use. Sort the names in ascending order alphabetically.

Notice that `""10:00""` \- `""11:00""` is considered to be within a one-hour
period, while `""22:51""` \- `""23:52""` is not considered to be within a one-hour
period.

","def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:
    nameToMinutes = collections.defaultdict(list)

    for name, time in zip(keyName, keyTime):
      minutes = self._getMinutes(time)
      nameToMinutes[name].append(minutes)

    res=[]
    for name, minutes in nameToMinutes.items():
      if self._hasAlert(minutes):
        res.append(name)
    return sorted(res)

  def _hasAlert(self, minutes: List[int]) -> bool:
    if len(minutes) > 70:
      return True
    minutes.sort()
    for i in range(2, len(minutes)):
      if minutes[i - 2] + 60 >= minutes[i]:
        return True
    return False

  def _getMinutes(self, time: str) -> int:
    h, m = map(int, time.split(':'))
    return 60 * h + m
"
1615,"There is an infrastructure of `n` cities with some number of `roads`
connecting these cities. Each `roads[i] = [ai, bi]` indicates that there is a
bidirectional road between cities `ai` and `bi`.

The network rank of two different cities is defined as the total number of
directly connected roads to either city. If a road is directly connected to
both cities, it is only counted once.

The maximal network rank of the infrastructure is the maximum network rank of
all pairs of different cities.

Given the integer `n` and the array `roads`, return the maximal network rank
of the entire infrastructure.

","def maximalNetworkRank(self, n: int, roads: List[List[int]]) -> int:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def maximalNetworkRank(self, n: int, roads: List[List[int]]) -> int:
    degrees = [0] * n

    for u, v in roads:
      degrees[u] += 1
      degrees[v] += 1

    maxDegree1 = 0
    maxDegree2 = 0
    for degree in degrees:
      if degree > maxDegree1:
        maxDegree2 = maxDegree1
        maxDegree1 = degree
      elif degree > maxDegree2:
        maxDegree2 = degree

    countMaxDegree1 = 0
    countMaxDegree2 = 0
    for degree in degrees:
      if degree == maxDegree1:
        countMaxDegree1 += 1
      elif degree == maxDegree2:
        countMaxDegree2 += 1

    if countMaxDegree1 == 1:
      edgeCount = self._getEdgeCount(roads, degrees, maxDegree1, maxDegree2) + self._getEdgeCount(roads, degrees, maxDegree2, maxDegree1)
      return maxDegree1 + maxDegree2 - (countMaxDegree2 == edgeCount)
    else:
      edgeCount = self._getEdgeCount(roads, degrees, maxDegree1, maxDegree1)
      maxPossibleEdgeCount = countMaxDegree1 * (countMaxDegree1 - 1) // 2
      return 2 * maxDegree1 - (maxPossibleEdgeCount == edgeCount)

  def _getEdgeCount(self, roads: List[List[int]], degrees: List[int], degreeU: int, degreeV: int) -> int:
    edgeCount = 0
    for u, v in roads:
      if degrees[u] == degreeU and degrees[v] == degreeV:
        edgeCount += 1
    return edgeCount
"
1616,"You are given two strings `a` and `b` of the same length. Choose an index and
split both strings at the same index, splitting `a` into two strings:
`aprefix` and `asuffix` where `a = aprefix + asuffix`, and splitting `b` into
two strings: `bprefix` and `bsuffix` where `b = bprefix + bsuffix`. Check if
`aprefix + bsuffix` or `bprefix + asuffix` forms a palindrome.

When you split a string `s` into `sprefix` and `ssuffix`, either `ssuffix` or
`sprefix` is allowed to be empty. For example, if `s = ""abc""`, then `"""" +
""abc""`, `""a"" + ""bc""`, `""ab"" + ""c""` , and `""abc"" + """"` are valid splits.

Return `true` if it is possible to form a palindrome string, otherwise return
`false`.

Notice that `x + y` denotes the concatenation of strings `x` and `y`.

","def checkPalindromeFormation(self, a: str, b: str) -> bool:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def checkPalindromeFormation(self, a: str, b: str) -> bool:
    return self._check(a, b) or self._check(b, a)

  def _check(self, a: str, b: str) -> bool:
    i, j = 0, len(a) - 1
    while i < j:
      if a[i] != b[j]:
        return self._isPalindrome(a, i, j) or self._isPalindrome(b, i, j)
      i += 1
      j -= 1
    return True

  def _isPalindrome(self, s: str, i: int, j: int) -> bool:
    while i < j:
      if s[i] != s[j]:
        return False
      i += 1
      j -= 1
    return True
"
1617,"There are `n` cities numbered from `1` to `n`. You are given an array `edges`
of size `n-1`, where `edges[i] = [ui, vi]` represents a bidirectional edge
between cities `ui` and `vi`. There exists a unique path between each pair of
cities. In other words, the cities form a tree.

A subtree is a subset of cities where every city is reachable from every other
city in the subset, where the path between each pair passes through only the
cities from the subset. Two subtrees are different if there is a city in one
subtree that is not present in the other.

For each `d` from `1` to `n-1`, find the number of subtrees in which the
maximum distance between any two cities in the subtree is equal to `d`.

Return an array of size `n-1` where the `dth` element (1-indexed) is the
number of subtrees in which the maximum distance between any two cities is
equal to `d`.

Notice that the distance between the two cities is the number of edges in the
path between them.

","def countSubgraphsForEachDiameter(self, n: int, edges: List[List[int]]) -> List[int]:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def countSubgraphsForEachDiameter(self, n: int, edges: List[List[int]]) -> List[int]:
    maxMask = 1 << n
    dist = self._floydWarshall(n, edges)
    ans = [0] * (n - 1)

    for mask in range(maxMask):
      maxDist = self._getMaxDist(mask, dist, n)
      if maxDist > 0:
        ans[maxDist - 1] += 1

    return ans

  def _floydWarshall(self, n: int, edges: List[List[int]]) -> List[List[int]]:
    dist = [[n] * n for _ in range(n)]

    for i in range(n):
      dist[i][i] = 0

    for u, v in edges:
      dist[u - 1][v - 1] = 1
      dist[v - 1][u - 1] = 1

    for k in range(n):
      for i in range(n):
        for j in range(n):
          dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])

    return dist

  def _getMaxDist(self, mask: int, dist: List[List[int]], n: int) -> int:
    maxDist = 0
    edgeCount = 0
    cityCount = 0
    for u in range(n):
      if (mask >> u) & 1 == 0:
        continue
      cityCount += 1
      for v in range(u + 1, n):
        if (mask >> v) & 1 == 0:
          continue
        if dist[u][v] == 1:
          edgeCount += 1
        maxDist = max(maxDist, dist[u][v])

    if edgeCount == cityCount - 1:
      return maxDist
    else:
      return 0
"
1627,"We have `n` cities labeled from `1` to `n`. Two different cities with labels
`x` and `y` are directly connected by a bidirectional road if and only if `x`
and `y` share a common divisor strictly greater than some `threshold`. More
formally, cities with labels `x` and `y` have a road between them if there
exists an integer `z` such that all of the following are true:

* `x % z == 0`,
* `y % z == 0`, and
* `z > threshold`.

Given the two integers, `n` and `threshold`, and an array of `queries`, you
must determine for each `queries[i] = [ai, bi]` if cities `ai` and `bi` are
connected directly or indirectly. (i.e. there is some path between them).

Return an array `answer`, where `answer.length == queries.length` and
`answer[i]` is `true` if for the `ith` query, there is a path between `ai` and
`bi`, or `answer[i]` is `false` if there is no path.

","def __init__(self, n: int):","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class UnionFind:
  def __init__(self, n: int):
    self.id = list(range(n))
    self.rank = [0] * n

  def unionByRank(self, u: int, v: int) -> bool:
    i = self.find(u)
    j = self.find(v)
    if i == j:
      return False
    if self.rank[i] < self.rank[j]:
      self.id[i] = j
    elif self.rank[i] > self.rank[j]:
      self.id[j] = i
    else:
      self.id[i] = j
      self.rank[j] += 1
    return True

  def find(self, u: int) -> int:
    if self.id[u] != u:
      self.id[u] = self.find(self.id[u])
    return self.id[u]


class Solution:
  def areConnected(self, n: int, threshold: int, queries: List[List[int]]) -> List[bool]:
    uf = UnionFind(n + 1)

    for z in range(threshold + 1, n + 1):
      for x in range(z * 2, n + 1, z):
        uf.unionByRank(z, x)

    return [uf.find(a) == uf.find(b) for a, b in queries]
"
1631,"You are a hiker preparing for an upcoming hike. You are given `heights`, a 2D
array of size `rows x columns`, where `heights[row][col]` represents the
height of cell `(row, col)`. You are situated in the top-left cell, `(0, 0)`,
and you hope to travel to the bottom-right cell, `(rows-1, columns-1)` (i.e.,
0-indexed). You can move up, down, left, or right, and you wish to find a
route that requires the minimum effort.

A route's effort is the maximum absolute difference in heights between two
consecutive cells of the route.

Return the minimum effort required to travel from the top-left cell to the
bottom-right cell.

","def minimumEffortPath(self, heights: List[List[int]]) -> int:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def minimumEffortPath(self, heights: List[List[int]]) -> int:
    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))
    m = len(heights)
    n = len(heights[0])
    diff = [[math.inf] * n for _ in range(m)]
    seen = set()

    minHeap = [(0, 0, 0)]
    diff[0][0] = 0

    while minHeap:
      d, i, j = heapq.heappop(minHeap)
      if i == m - 1 and j == n - 1:
        return d
      seen.add((i, j))
      for dx, dy in dirs:
        x = i + dx
        y = j + dy
        if x < 0 or x == m or y < 0 or y == n:
          continue
        if (x, y) in seen:
          continue
        newDiff = abs(heights[i][j] - heights[x][y])
        maxDiff = max(diff[i][j], newDiff)
        if diff[x][y] > maxDiff:
          diff[x][y] = maxDiff
          heapq.heappush(minHeap, (diff[x][y], x, y))
"
1632,"Given an `m x n` `matrix`, return a new matrix `answer` where
`answer[row][col]` is the rank of `matrix[row][col]`.

The rank is an integer that represents how large an element is compared to
other elements. It is calculated using the following rules:

* The rank is an integer starting from `1`.
* If two elements `p` and `q` are in the same row or column, then: 
* If `p < q` then `rank(p) < rank(q)`
* If `p == q` then `rank(p) == rank(q)`
* If `p > q` then `rank(p) > rank(q)`
* The rank should be as small as possible.

The test cases are generated so that `answer` is unique under the given rules.

",def __init__(self):,"import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class UnionFind:
  def __init__(self):
    self.id = {}

  def union(self, u: int, v: int) -> None:
    self.id.setdefault(u, u)
    self.id.setdefault(v, v)
    i = self._find(u)
    j = self._find(v)
    if i != j:
      self.id[i] = j

  def getGroupIdToValues(self) -> Dict[int, List[int]]:
    groupIdToValues = collections.defaultdict(list)
    for u in self.id.keys():
      groupIdToValues[self._find(u)].append(u)
    return groupIdToValues

  def _find(self, u: int) -> int:
    if self.id[u] != u:
      self.id[u] = self._find(self.id[u])
    return self.id[u]


class Solution:
  def matrixRankTransform(self, matrix: List[List[int]]) -> List[List[int]]:
    m = len(matrix)
    n = len(matrix[0])
    ans = [[0] * n for _ in range(m)]
    valToGrids = collections.defaultdict(list)
    maxRankSoFar = [0] * (m + n)

    for i, row in enumerate(matrix):
      for j, val in enumerate(row):
        valToGrids[val].append((i, j))

    for _, grids in sorted(valToGrids.items()):
      uf = UnionFind()
      for i, j in grids:
        uf.union(i, j + m)
      for values in uf.getGroupIdToValues().values():
        maxRank = max(maxRankSoFar[i] for i in values)
        for i in values:
          maxRankSoFar[i] = maxRank + 1
      for i, j in grids:
        ans[i][j] = maxRankSoFar[i]

    return ans
"
1654,"A certain bug's home is on the x-axis at position `x`. Help them get there
from position `0`.

The bug jumps according to the following rules:

* It can jump exactly `a` positions forward (to the right).
* It can jump exactly `b` positions backward (to the left).
* It cannot jump backward twice in a row.
* It cannot jump to any `forbidden` positions.

The bug may jump forward beyond its home, but it cannot jump to positions
numbered with negative integers.

Given an array of integers `forbidden`, where `forbidden[i]` means that the
bug cannot jump to the position `forbidden[i]`, and integers `a`, `b`, and
`x`, return the minimum number of jumps needed for the bug to reach its home.
If there is no possible sequence of jumps that lands the bug on position `x`,
return `-1.`

","def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

from enum import Enum


class Direction(Enum):
  kForward = 0
  kBackward = 1


class Solution:
  def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:
    furthest = max(x + a + b, max(pos + a + b for pos in forbidden))
    seenForward = {pos for pos in forbidden}
    seenBackward = {pos for pos in forbidden}

    q = collections.deque([(Direction.kForward, 0)])

    ans = 0
    while q:
      for _ in range(len(q)):
        dir, pos = q.popleft()
        if pos == x:
          return ans
        forward = pos + a
        backward = pos - b
        if forward <= furthest and forward not in seenForward:
          seenForward.add(forward)
          q.append((Direction.kForward, forward))
        if dir == Direction.kForward and backward >= 0 and backward not in seenBackward:
          seenBackward.add(backward)
          q.append((Direction.kBackward, backward))
      ans += 1

    return -1
"
1655,"You are given an array of `n` integers, `nums`, where there are at most `50`
unique values in the array. You are also given an array of `m` customer order
quantities, `quantity`, where `quantity[i]` is the amount of integers the
`ith` customer ordered. Determine if it is possible to distribute `nums` such
that:

* The `ith` customer gets exactly `quantity[i]` integers,
* The integers the `ith` customer gets are all equal, and
* Every customer is satisfied.

Return `true` if it is possible to distribute `nums` according to the above
conditions.

","def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:
    freqs = list(collections.Counter(nums).values())
    validDistribution = self._getValidDistribution(freqs, quantity)
    n = len(freqs)
    m = len(quantity)
    maxMask = 1 << m
    dp = [[False] * maxMask for _ in range(n + 1)]
    dp[n][maxMask - 1] = True

    for i in range(n - 1, -1, -1):
      for mask in range(maxMask):
        dp[i][mask] = dp[i + 1][mask]
        availableMask = ~mask & (maxMask - 1)
        submask = availableMask
        while submask > 0:
          if validDistribution[i][submask]:
            dp[i][mask] = dp[i][mask] or dp[i + 1][mask | submask]
          submask = (submask - 1) & availableMask

    return dp[0][0]

  def _getValidDistribution(self, freqs: List[int], quantity: List[int]) -> List[List[bool]]:
    maxMask = 1 << len(quantity)
    validDistribution = [[False] * maxMask for _ in range(len(freqs))]
    for i, freq in enumerate(freqs):
      for mask in range(maxMask):
        if freq >= self._getQuantitySum(quantity, mask):
          validDistribution[i][mask] = True
    return validDistribution

  def _getQuantitySum(self, quantity: List[int], mask: int) -> int:
    res=[]
    for i, q in enumerate(quantity):
      if mask >> i & 1:
        res.append(q)
    return sum(res)
"
1681,"You are given an integer array `nums`​​​ and an integer `k`. You are asked to
distribute this array into `k` subsets of equal size such that there are no
two equal elements in the same subset.

A subset's incompatibility is the difference between the maximum and minimum
elements in that array.

Return the minimum possible sum of incompatibilities of the `k` subsets after
distributing the array optimally, or return `-1` if it is not possible.

A subset is a group integers that appear in the array with no particular
order.

",def __init__(self):,"import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def __init__(self):
    self.kMaxNum = 16

  def minimumIncompatibility(self, nums: List[int], k: int) -> int:
    kMaxCompatibility = (16 - 1) * (16 // 2)
    n = len(nums)
    subsetSize = n // k
    maxMask = 1 << n
    incompatibilities = self._getIncompatibilities(nums, subsetSize)

    dp = [kMaxCompatibility] * maxMask
    dp[0] = 0

    for mask in range(1, maxMask):
      if mask.bit_count() % subsetSize != 0:
        continue
      submask = mask
      while submask > 0:
        if incompatibilities[submask] != -1:
          dp[mask] = min(dp[mask], dp[mask - submask] + incompatibilities[submask])
        submask = (submask - 1) & mask

    if dp[-1] != kMaxCompatibility:
      return dp[-1]
    else:
      return -1

  def _getIncompatibilities(self, nums: List[int], subsetSize: int) -> List[int]:
    maxMask = 1 << len(nums)
    incompatibilities = [-1] * maxMask
    for mask in range(maxMask):
      if mask.bit_count() == subsetSize and self._isUnique(nums, mask, subsetSize):
        incompatibilities[mask] = self._getIncompatibility(nums, mask)
    return incompatibilities

  def _isUnique(self, nums: List[int], mask: int, subsetSize: int) -> bool:
    used = 0
    for i, num in enumerate(nums):
      if mask >> i & 1:
        used |= 1 << num
    return used.bit_count() == subsetSize

  def _getIncompatibility(self, nums: List[int], mask: int) -> int:
    mini = self.kMaxNum
    maxi = 0
    for i, num in enumerate(nums):
      if mask >> i & 1:
        maxi = max(maxi, num)
        mini = min(mini, num)
    return maxi - mini
"
1687,"You have the task of delivering some boxes from storage to their ports using
only one ship. However, this ship has a limit on the number of boxes and the
total weight that it can carry.

You are given an array `boxes`, where `boxes[i] = [ports​​i​, weighti]`, and
three integers `portsCount`, `maxBoxes`, and `maxWeight`.

* `ports​​i` is the port where you need to deliver the `ith` box and `weightsi` is the weight of the `ith` box.
* `portsCount` is the number of ports.
* `maxBoxes` and `maxWeight` are the respective box and weight limits of the ship.

The boxes need to be delivered in the order they are given. The ship will
follow these steps:

* The ship will take some number of boxes from the `boxes` queue, not violating the `maxBoxes` and `maxWeight` constraints.
* For each loaded box in order, the ship will make a trip to the port the box needs to be delivered to and deliver it. If the ship is already at the correct port, no trip is needed, and the box can immediately be delivered.
* The ship then makes a return trip to storage to take more boxes from the queue.

The ship must end at storage after all the boxes have been delivered.

Return the minimum number of trips the ship needs to make to deliver all boxes
to their respective ports.

","def boxDelivering(self, boxes: List[List[int]], portsCount: int, maxBoxes: int, maxWeight: int) -> int:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def boxDelivering(self, boxes: List[List[int]], portsCount: int, maxBoxes: int, maxWeight: int) -> int:
    n = len(boxes)
    dp = [0] * (n + 1)
    trips = 2
    weight = 0

    l = 0
    for r in range(n):
      weight += boxes[r][1]

      if r > 0 and boxes[r][0] != boxes[r - 1][0]:
        trips += 1

      while r - l + 1 > maxBoxes or weight > maxWeight or (l < r and dp[l + 1] == dp[l]):
        weight -= boxes[l][1]
        if boxes[l][0] != boxes[l + 1][0]:
          trips -= 1
        l += 1

      dp[r + 1] = dp[l] + trips

    return dp[n]
"
1705,"There is a special kind of apple tree that grows apples every day for `n`
days. On the `ith` day, the tree grows `apples[i]` apples that will rot after
`days[i]` days, that is on day `i + days[i]` the apples will be rotten and
cannot be eaten. On some days, the apple tree does not grow any apples, which
are denoted by `apples[i] == 0` and `days[i] == 0`.

You decided to eat at most one apple a day (to keep the doctors away). Note
that you can keep eating after the first `n` days.

Given two integer arrays `days` and `apples` of length `n`, return the maximum
number of apples you can eat.

","def eatenApples(self, apples: List[int], days: List[int]) -> int:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def eatenApples(self, apples: List[int], days: List[int]) -> int:
    n = len(apples)
    ans = 0
    minHeap = []

    i = 0
    while i < n or minHeap:
      while minHeap and minHeap[0][0] <= i:
        heapq.heappop(minHeap)
      if i < n and apples[i] > 0:
        heapq.heappush(minHeap, (i + days[i], apples[i]))
      if minHeap:
        rottenDay, numApples = heapq.heappop(minHeap)
        if numApples > 1:
          heapq.heappush(minHeap, (rottenDay, numApples - 1))
        ans += 1
      i += 1

    return ans
"
1706,"You have a 2-D `grid` of size `m x n` representing a box, and you have `n`
balls. The box is open on the top and bottom sides.

Each cell in the box has a diagonal board spanning two corners of the cell
that can redirect a ball to the right or to the left.

* A board that redirects the ball to the right spans the top-left corner to the bottom-right corner and is represented in the grid as `1`.
* A board that redirects the ball to the left spans the top-right corner to the bottom-left corner and is represented in the grid as `-1`.

We drop one ball at the top of each column of the box. Each ball can get stuck
in the box or fall out of the bottom. A ball gets stuck if it hits a ""V""
shaped pattern between two boards or if a board redirects the ball into either
wall of the box.

Return an array `answer` of size `n` where `answer[i]` is the column that the
ball falls out of at the bottom after dropping the ball from the `ith` column
at the top, or `-1` if the ball gets stuck in the box.

","def findBall(self, grid: List[List[int]]) -> List[int]:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def findBall(self, grid: List[List[int]]) -> List[int]:
    m = len(grid)
    n = len(grid[0])
    dp = [i for i in range(n)]
    ans = [-1] * n

    for i in range(m):
      newDp = [-1] * n
      for j in range(n):
        if j + grid[i][j] < 0 or j + grid[i][j] == n:
          continue
        if grid[i][j] == 1 and grid[i][j + 1] == -1 or grid[i][j] == -1 and grid[i][j - 1] == 1:
          continue
        newDp[j + grid[i][j]] = dp[j]
      dp = newDp

    for i, ball in enumerate(dp):
      if ball != -1:
        ans[ball] = i

    return ans
"
1717,"You are given a string `s` and two integers `x` and `y`. You can perform two
types of operations any number of times.

* Remove substring `""ab""` and gain `x` points. 
* For example, when removing `""ab""` from `""cabxbae""` it becomes `""cxbae""`.
* Remove substring `""ba""` and gain `y` points. 
* For example, when removing `""ba""` from `""cabxbae""` it becomes `""cabxe""`.

Return the maximum points you can gain after applying the above operations on
`s`.

","def maximumGain(self, s: str, x: int, y: int) -> int:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def maximumGain(self, s: str, x: int, y: int) -> int:
    if x > y:
      return self._gain(s, 'ab', x, 'ba', y)
    else:
      return self._gain(s, 'ba', y, 'ab', x)

  def _gain(self, s: str, sub1: str, point1: int, sub2: str, point2: int) -> int:
    points = 0
    stack1 = []
    stack2 = []

    for c in s:
      if stack1 and stack1[-1] == sub1[0] and c == sub1[1]:
        stack1.pop()
        points += point1
      else:
        stack1.append(c)

    for c in stack1:
      if stack2 and stack2[-1] == sub2[0] and c == sub2[1]:
        stack2.pop()
        points += point2
      else:
        stack2.append(c)

    return points
"
1719,"You are given an array `pairs`, where `pairs[i] = [xi, yi]`, and:

* There are no duplicates.
* `xi < yi`

Let `ways` be the number of rooted trees that satisfy the following
conditions:

* The tree consists of nodes whose values appeared in `pairs`.
* A pair `[xi, yi]` exists in `pairs` if and only if `xi` is an ancestor of `yi` or `yi` is an ancestor of `xi`.
* Note: the tree does not have to be a binary tree.

Two ways are considered to be different if there is at least one node that has
different parents in both ways.

Return:

* `0` if `ways == 0`
* `1` if `ways == 1`
* `2` if `ways > 1`

A rooted tree is a tree that has a single root node, and all edges are
oriented to be outgoing from the root.

An ancestor of a node is any node on the path from the root to that node
(excluding the node itself). The root has no ancestors.

","def checkWays(self, pairs: List[List[int]]) -> int:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def checkWays(self, pairs: List[List[int]]) -> int:
    kMax = 501
    graph = collections.defaultdict(list)
    degrees = [0] * kMax
    connected = [[False] * kMax for _ in range(kMax)]

    for u, v in pairs:
      graph[u].append(v)
      graph[v].append(u)
      degrees[u] += 1
      degrees[v] += 1
      connected[u][v] = True
      connected[v][u] = True

    for _, children in graph.items():
      children.sort(key=lambda a: degrees[a], reverse=True)

    root = next((i for i, d in enumerate(degrees) if d == len(graph) - 1), -1)
    if root == -1:
      return 0

    hasMoreThanOneWay = False

    def dfs(u: int, ancestors: List[int], seen: List[bool]) -> bool:
      nonlocal hasMoreThanOneWay
      seen[u] = True
      for ancestor in ancestors:
        if not connected[u][ancestor]:
          return False
      ancestors.append(u)
      for v in graph[u]:
        if seen[v]:
          continue
        if degrees[v] == degrees[u]:
          hasMoreThanOneWay = True
        if not dfs(v, ancestors, seen):
          return False
      ancestors.pop()
      return True

    if not dfs(root, [], [False] * kMax):
      return 0
    if hasMoreThanOneWay:
      return 2
    else:
      return 1
"
1722,"You are given two integer arrays, `source` and `target`, both of length `n`.
You are also given an array `allowedSwaps` where each `allowedSwaps[i] = [ai,
bi]` indicates that you are allowed to swap the elements at index `ai` and
index `bi` (0-indexed) of array `source`. Note that you can swap elements at a
specific pair of indices multiple times and in any order.

The Hamming distance of two arrays of the same length, `source` and `target`,
is the number of positions where the elements are different. Formally, it is
the number of indices `i` for `0 <= i <= n-1` where `source[i] != target[i]`
(0-indexed).

Return the minimum Hamming distance of `source` and `target` after performing
any amount of swap operations on array `source`.

","def __init__(self, n: int):","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class UnionFind:
  def __init__(self, n: int):
    self.id = list(range(n))
    self.rank = [0] * n

  def unionByRank(self, u: int, v: int) -> None:
    i = self.find(u)
    j = self.find(v)
    if i == j:
      return
    if self.rank[i] < self.rank[j]:
      self.id[i] = j
    elif self.rank[i] > self.rank[j]:
      self.id[j] = i
    else:
      self.id[i] = j
      self.rank[j] += 1

  def find(self, u: int) -> int:
    if self.id[u] != u:
      self.id[u] = self.find(self.id[u])
    return self.id[u]


class Solution:
  def minimumHammingDistance(self, source: List[int], target: List[int], allowedSwaps: List[List[int]]) -> int:
    n = len(source)
    ans = 0
    uf = UnionFind(n)
    groupIdToCount = [collections.Counter() for _ in range(n)]

    for a, b in allowedSwaps:
      uf.unionByRank(a, b)

    for i in range(n):
      groupIdToCount[uf.find(i)][source[i]] += 1

    for i in range(n):
      groupId = uf.find(i)
      count = groupIdToCount[groupId]
      if target[i] not in count:
        ans += 1
      else:
        count[target[i]] -= 1
        if count[target[i]] == 0:
          del count[target[i]]

    return ans
"
1735,"You are given a 2D integer array, `queries`. For each `queries[i]`, where
`queries[i] = [ni, ki]`, find the number of different ways you can place
positive integers into an array of size `ni` such that the product of the
integers is `ki`. As the number of ways may be too large, the answer to the
`ith` query is the number of ways modulo `109 + 7`.

Return an integer array `answer` where `answer.length == queries.length`, and
`answer[i]` is the answer to the `ith` query.

","def waysToFillArray(self, queries: List[List[int]]) -> List[int]:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def waysToFillArray(self, queries: List[List[int]]) -> List[int]:
    kMod = 1_000_000_007
    kMax = 10_000
    minPrimeFactors = self._sieveEratosthenes(kMax + 1)

    @functools.lru_cache(None)
    def fact(i: int) -> int:
      return 1 if i <= 1 else i * fact(i - 1) % kMod

    @functools.lru_cache(None)
    def inv(i: int) -> int:
      return pow(i, kMod - 2, kMod)

    @functools.lru_cache(None)
    def nCk(n: int, k: int) -> int:
      return fact(n) * inv(fact(k)) * inv(fact(n - k)) % kMod

    ans = []

    for n, k in queries:
      res = 1
      for freq in self._getPrimeFactorsCount(k, minPrimeFactors).values():
        res = res * nCk(n - 1 + freq, freq) % kMod
      ans.append(res)

    return ans

  def _sieveEratosthenes(self, n: int) -> List[int]:
    minPrimeFactors = [i for i in range(n + 1)]
    for i in range(2, int(n**0.5) + 1):
      if minPrimeFactors[i] == i:
        for j in range(i * i, n, i):
          minPrimeFactors[j] = min(minPrimeFactors[j], i)
    return minPrimeFactors

  def _getPrimeFactorsCount(self, num: int, minPrimeFactors: List[int]) -> Dict[int, int]:
    count = collections.Counter()
    while num > 1:
      divisor = minPrimeFactors[num]
      while num % divisor == 0:
        num //= divisor
        count[divisor] += 1
    return count
"
1765,"You are given an integer matrix `isWater` of size `m x n` that represents a
map of land and water cells.

* If `isWater[i][j] == 0`, cell `(i, j)` is a land cell.
* If `isWater[i][j] == 1`, cell `(i, j)` is a water cell.

You must assign each cell a height in a way that follows these rules:

* The height of each cell must be non-negative.
* If the cell is a water cell, its height must be `0`.
* Any two adjacent cells must have an absolute height difference of at most `1`. A cell is adjacent to another cell if the former is directly north, east, south, or west of the latter (i.e., their sides are touching).

Find an assignment of heights such that the maximum height in the matrix is
maximized.

Return an integer matrix `height` of size `m x n` where `height[i][j]` is cell
`(i, j)`'s height. If there are multiple solutions, return any of them.

","def highestPeak(self, isWater: List[List[int]]) -> List[List[int]]:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def highestPeak(self, isWater: List[List[int]]) -> List[List[int]]:
    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))
    m = len(isWater)
    n = len(isWater[0])
    ans = [[-1] * n for _ in range(m)]
    q = collections.deque()

    for i in range(m):
      for j in range(n):
        if isWater[i][j] == 1:
          q.append((i, j))
          ans[i][j] = 0

    while q:
      i, j = q.popleft()
      for dx, dy in dirs:
        x = i + dx
        y = j + dy
        if x < 0 or x == m or y < 0 or y == n:
          continue
        if ans[x][y] != -1:
          continue
        ans[x][y] = ans[i][j] + 1
        q.append((x, y))

    return ans
"
1579,"Alice and Bob have an undirected graph of `n` nodes and three types of edges:

* Type 1: Can be traversed by Alice only.
* Type 2: Can be traversed by Bob only.
* Type 3: Can be traversed by both Alice and Bob.

Given an array `edges` where `edges[i] = [typei, ui, vi]` represents a
bidirectional edge of type `typei` between nodes `ui` and `vi`, find the
maximum number of edges you can remove so that after removing the edges, the
graph can still be fully traversed by both Alice and Bob. The graph is fully
traversed by Alice and Bob if starting from any node, they can reach all other
nodes.

Return the maximum number of edges you can remove, or return `-1` if Alice and
Bob cannot fully traverse the graph.

","def __init__(self, n: int):","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class UnionFind:
  def __init__(self, n: int):
    self.count = n
    self.id = list(range(n))
    self.rank = [0] * n

  def unionByRank(self, u: int, v: int) -> bool:
    i = self._find(u)
    j = self._find(v)
    if i == j:
      return False
    if self.rank[i] < self.rank[j]:
      self.id[i] = j
    elif self.rank[i] > self.rank[j]:
      self.id[j] = i
    else:
      self.id[i] = j
      self.rank[j] += 1
    self.count -= 1
    return True

  def _find(self, u: int) -> int:
    if self.id[u] != u:
      self.id[u] = self._find(self.id[u])
    return self.id[u]


class Solution:
  def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:
    alice = UnionFind(n)
    bob = UnionFind(n)
    requiredEdges = 0

    for type, u, v in sorted(edges, reverse=True):
      u -= 1
      v -= 1
      if type == 3:
        if alice.unionByRank(u, v) | bob.unionByRank(u, v):
          requiredEdges += 1
      elif type == 2:
        if bob.unionByRank(u, v):
          requiredEdges += 1
      else:
        if alice.unionByRank(u, v):
          requiredEdges += 1

    if alice.count == 1 and bob.count == 1:
        return len(edges) - requiredEdges
    else:
        return -1
"
1574,"Given an integer array `arr`, remove a subarray (can be empty) from `arr` such
that the remaining elements in `arr` are non-decreasing.

Return the length of the shortest subarray to remove.

A subarray is a contiguous subsequence of the array.

","def findLengthOfShortestSubarray(self, arr: List[int]) -> int:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def findLengthOfShortestSubarray(self, arr: List[int]) -> int:
    n = len(arr)
    l = 0
    r = n - 1

    while l < n - 1 and arr[l + 1] >= arr[l]:
      l += 1
    while r > 0 and arr[r - 1] <= arr[r]:
      r -= 1
    ans = min(n - 1 - l, r)

    i = l
    j = n - 1
    while i >= 0 and j >= r and j > i:
      if arr[i] <= arr[j]:
        j -= 1
      else:
        i -= 1
      ans = min(ans, j - i)

    return ans
"
1573,"Given a binary string `s`, you can split `s` into 3 non-empty strings `s1`,
`s2`, and `s3` where `s1 + s2 + s3 = s`.

Return the number of ways `s` can be split such that the number of ones is the
same in `s1`, `s2`, and `s3`. Since the answer may be too large, return it
modulo `109 + 7`.

","def numWays(self, s: str) -> int:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def numWays(self, s: str) -> int:
    kMod = 1_000_000_007
    ones = s.count('1')
    if ones % 3 != 0:
      return 0
    if ones == 0:
      n = len(s)
      return (n - 1) * (n - 2) // 2 % kMod

    s1End = -1
    s2Start = -1
    s2End = -1
    s3Start = -1
    onesSoFar = 0

    for i, c in enumerate(s):
      if c == '1':
        onesSoFar += 1
      if s1End == -1 and onesSoFar == ones // 3:
        s1End = i
      elif s2Start == -1 and onesSoFar == ones // 3 + 1:
        s2Start = i
      if s2End == -1 and onesSoFar == ones // 3 * 2:
        s2End = i
      elif s3Start == -1 and onesSoFar == ones // 3 * 2 + 1:
        s3Start = i

    return (s2Start - s1End) * (s3Start - s2End) % kMod
"
1210,"In an `n*n` grid, there is a snake that spans 2 cells and starts moving from
the top left corner at `(0, 0)` and `(0, 1)`. The grid has empty cells
represented by zeros and blocked cells represented by ones. The snake wants to
reach the lower right corner at `(n-1, n-2)` and `(n-1, n-1)`.

In one move the snake can:

* Move one cell to the right if there are no blocked cells there. This move keeps the horizontal/vertical position of the snake as it is.
* Move down one cell if there are no blocked cells there. This move keeps the horizontal/vertical position of the snake as it is.
* Rotate clockwise if it's in a horizontal position and the two cells under it are both empty. In that case the snake moves from `(r, c)` and `(r, c+1)` to `(r, c)` and `(r+1, c)`.  

* Rotate counterclockwise if it's in a vertical position and the two cells to its right are both empty. In that case the snake moves from `(r, c)` and `(r+1, c)` to `(r, c)` and `(r, c+1)`.  

Return the minimum number of moves to reach the target.

If there is no way to reach the target, return `-1`.

","def minimumMoves(self, grid: List[List[int]]) -> int:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

from enum import IntEnum


class Pos(IntEnum):
  kHorizontal = 0
  kVertical = 1


class Solution:
  def minimumMoves(self, grid: List[List[int]]) -> int:
    n = len(grid)
    ans = 0

    q = collections.deque([(0, 0, Pos.kHorizontal)])
    seen = {(0, 0, Pos.kHorizontal)}

    def canMoveRight(x: int, y: int, pos: Pos) -> bool:
      if pos == Pos.kHorizontal:
        return y + 2 < n and not grid[x][y + 2]
      return y + 1 < n and not grid[x][y + 1] and not grid[x + 1][y + 1]

    def canMoveDown(x: int, y: int, pos: Pos) -> bool:
      if pos == Pos.kVertical:
        return x + 2 < n and not grid[x + 2][y]
      return x + 1 < n and not grid[x + 1][y] and not grid[x + 1][y + 1]

    def canRotateClockwise(x: int, y: int, pos: Pos) -> bool:
      return pos == Pos.kHorizontal and x + 1 < n and \
          not grid[x + 1][y + 1] and not grid[x + 1][y]

    def canRotateCounterclockwise(x: int, y: int, pos: Pos) -> bool:
      return pos == Pos.kVertical and y + 1 < n and \
          not grid[x + 1][y + 1] and not grid[x][y + 1]

    while q:
      for _ in range(len(q)):
        x, y, pos = q.popleft()
        if x == n - 1 and y == n - 2 and pos == Pos.kHorizontal:
          return ans
        if canMoveRight(x, y, pos) and (x, y + 1, pos) not in seen:
          q.append((x, y + 1, pos))
          seen.add((x, y + 1, pos))
        if canMoveDown(x, y, pos) and (x + 1, y, pos) not in seen:
          q.append((x + 1, y, pos))
          seen.add((x + 1, y, pos))
        newPos = Pos.kVertical if pos == Pos.kHorizontal else Pos.kHorizontal
        if (canRotateClockwise(x, y, pos) or canRotateCounterclockwise(x, y, pos)) and (x, y, newPos) not in seen:
          q.append((x, y, newPos))
          seen.add((x, y, newPos))
      ans += 1

    return -1
"
935,"The chess knight has a unique movement, it may move two squares vertically and
one square horizontally, or two squares horizontally and one square vertically
(with both forming the shape of an L). The possible movements of chess knight
are shown in this diagram:

A chess knight can move as indicated in the chess diagram below:

We have a chess knight and a phone pad as shown below, the knight can only
stand on a numeric cell (i.e. blue cell).

Given an integer `n`, return how many distinct phone numbers of length `n` we
can dial.

You are allowed to place the knight on any numeric cell initially and then you
should perform `n - 1` jumps to dial a number of length `n`. All jumps should
be valid knight jumps.

As the answer may be very large, return the answer modulo `109 + 7`.

","def knightDialer(self, n: int) -> int:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def knightDialer(self, n: int) -> int:
    dirs = ((1, 2), (2, 1), (2, -1), (1, -2), (-1, -2), (-2, -1), (-2, 1), (-1, 2))
    kMod = 1_000_000_007

    dp = [[1] * 3 for _ in range(4)]
    dp[3][0] = dp[3][2] = 0

    for _ in range(n - 1):
      newDp = [[0] * 3 for _ in range(4)]
      for i in range(4):
        for j in range(3):
          if (i, j) in ((3, 0), (3, 2)):
            continue
          for dx, dy in dirs:
            x = i + dx
            y = j + dy
            if x < 0 or x >= 4 or y < 0 or y >= 3:
              continue
            if (x, y) in ((3, 0), (3, 2)):
              continue
            newDp[x][y] = (newDp[x][y] + dp[i][j]) % kMod
      dp = newDp

    return sum(map(sum, dp)) % kMod
"
939,"You are given an array of points in the X-Y plane `points` where `points[i] =
[xi, yi]`.

Return the minimum area of a rectangle formed from these points, with sides
parallel to the X and Y axes. If there is not any such rectangle, return `0`.

","def minAreaRect(self, points: List[List[int]]) -> int:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def minAreaRect(self, points: List[List[int]]) -> int:
    ans = math.inf
    xToYs = collections.defaultdict(set)

    for x, y in points:
      xToYs[x].add(y)

    for i in range(len(points)):
      for j in range(i):
        x1, y1 = points[i]
        x2, y2 = points[j]
        if x1 == x2 or y1 == y2:
          continue
        if y2 in xToYs[x1] and y1 in xToYs[x2]:
          ans = min(ans, abs(x1 - x2) * abs(y1 - y2))

    return ans if ans < math.inf else 0
"
952,"You are given an integer array of unique positive integers `nums`. Consider
the following graph:

* There are `nums.length` nodes, labeled `nums[0]` to `nums[nums.length - 1]`,
* There is an undirected edge between `nums[i]` and `nums[j]` if `nums[i]` and `nums[j]` share a common factor greater than `1`.

Return the size of the largest connected component in the graph.

","def __init__(self, n: int):","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class UnionFind:
  def __init__(self, n: int):
    self.id = list(range(n))
    self.rank = [0] * n

  def unionByRank(self, u: int, v: int) -> None:
    i = self.find(u)
    j = self.find(v)
    if i == j:
      return
    if self.rank[i] < self.rank[j]:
      self.id[i] = j
    elif self.rank[i] > self.rank[j]:
      self.id[j] = i
    else:
      self.id[i] = j
      self.rank[j] += 1

  def find(self, u: int) -> int:
    if self.id[u] != u:
      self.id[u] = self.find(self.id[u])
    return self.id[u]


class Solution:
  def largestComponentSize(self, nums: List[int]) -> int:
    ans = 0
    uf = UnionFind(max(nums) + 1)
    count = collections.Counter()

    for num in nums:
      for x in range(2, int(math.sqrt(num) + 1)):
        if num % x == 0:
          uf.unionByRank(num, x)
          uf.unionByRank(num, num // x)

    for num in nums:
      numRoot = uf.find(num)
      count[numRoot] += 1
      ans = max(ans, count[numRoot])

    return ans
"
990,"You are given an array of strings `equations` that represent relationships
between variables where each string `equations[i]` is of length `4` and takes
one of two different forms: `""xi==yi""` or `""xi!=yi""`.Here, `xi` and `yi` are
lowercase letters (not necessarily different) that represent one-letter
variable names.

Return `true` if it is possible to assign integers to variable names so as to
satisfy all the given equations, or `false` otherwise.

","def __init__(self, n: int):","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class UnionFind:
  def __init__(self, n: int):
    self.id = list(range(n))

  def union(self, u: int, v: int) -> None:
    self.id[self.find(u)] = self.find(v)

  def find(self, u: int) -> int:
    if self.id[u] != u:
      self.id[u] = self.find(self.id[u])
    return self.id[u]


class Solution:
  def equationsPossible(self, equations: List[str]) -> bool:
    uf = UnionFind(26)

    for x, op, _, y in equations:
      if op == '=':
        uf.union(ord(x) - ord('a'), ord(y) - ord('a'))

    for x, op, _, y in equations:
      if op == '!':
        if uf.find(ord(x) - ord('a')) == uf.find(ord(y) - ord('a')):
          return False
    return True
"
999,"On an `8 x 8` chessboard, there is exactly one white rook `'R'` and some
number of white bishops `'B'`, black pawns `'p'`, and empty squares `'.'`.

When the rook moves, it chooses one of four cardinal directions (north, east,
south, or west), then moves in that direction until it chooses to stop,
reaches the edge of the board, captures a black pawn, or is blocked by a white
bishop. A rook is considered attacking a pawn if the rook can capture the pawn
on the rook's turn. The number of available captures for the white rook is the
number of pawns that the rook is attacking.

Return the number of available captures for the white rook.

","def numRookCaptures(self, board: List[List[str]]) -> int:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def numRookCaptures(self, board: List[List[str]]) -> int:
    ans = 0

    for i in range(8):
      for j in range(8):
        if board[i][j] == 'R':
          i0 = i
          j0 = j

    for d in [[1, 0], [0, 1], [-1, 0], [0, -1]]:
      i = i0 + d[0]
      j = j0 + d[1]
      while 0 <= i < 8 and 0 <= j < 8:
        if board[i][j] == 'p':
          ans += 1
        if board[i][j] != '.':
          break
        i += d[0]
        j += d[1]

    return ans
"
1001,"There is a 2D `grid` of size `n x n` where each cell of this grid has a lamp
that is initially turned off.

You are given a 2D array of lamp positions `lamps`, where `lamps[i] = [rowi,
coli]` indicates that the lamp at `grid[rowi][coli]` is turned on. Even if the
same lamp is listed more than once, it is turned on.

When a lamp is turned on, it illuminates its cell and all other cells in the
same row, column, or diagonal.

You are also given another 2D array `queries`, where `queries[j] = [rowj,
colj]`. For the `jth` query, determine whether `grid[rowj][colj]` is
illuminated or not. After answering the `jth` query, turn off the lamp at
`grid[rowj][colj]` and its 8 adjacent lamps if they exist. A lamp is adjacent
if its cell shares either a side or corner with `grid[rowj][colj]`.

Return an array of integers `ans`, where `ans[j]` should be `1` if the cell in
the `jth` query was illuminated, or `0` if the lamp was not.

","def gridIllumination(self, n: int, lamps: List[List[int]], queries: List[List[int]]) -> List[int]:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def gridIllumination(self, n: int, lamps: List[List[int]], queries: List[List[int]]) -> List[int]:
    ans = []
    rows = collections.Counter()
    cols = collections.Counter()
    diag1 = collections.Counter()
    diag2 = collections.Counter()
    lampsSet = set()

    for i, j in lamps:
      if (i, j) not in lampsSet:
        lampsSet.add((i, j))
        rows[i] += 1
        cols[j] += 1
        diag1[i + j] += 1
        diag2[i - j] += 1

    for i, j in queries:
      if rows[i] or cols[j] or diag1[i + j] or diag2[i - j]:
        ans.append(1)
        for y in range(max(0, i - 1), min(n, i + 2)):
          for x in range(max(0, j - 1), min(n, j + 2)):
            if (y, x) in lampsSet:
              lampsSet.remove((y, x))
              rows[y] -= 1
              cols[x] -= 1
              diag1[y + x] -= 1
              diag2[y - x] -= 1
      else:
        ans.append(0)

    return ans
"
1093,"You are given a large sample of integers in the range `[0, 255]`. Since the
sample is so large, it is represented by an array `count` where `count[k]` is
the number of times that `k` appears in the sample.

Calculate the following statistics:

* `minimum`: The minimum element in the sample.
* `maximum`: The maximum element in the sample.
* `mean`: The average of the sample, calculated as the total sum of all elements divided by the total number of elements.
* `median`: 
* If the sample has an odd number of elements, then the `median` is the middle element once the sample is sorted.
* If the sample has an even number of elements, then the `median` is the average of the two middle elements once the sample is sorted.
* `mode`: The number that appears the most in the sample. It is guaranteed to be unique.

Return the statistics of the sample as an array of floating-point numbers
`[minimum, maximum, mean, median, mode]`. Answers within `10-5` of the actual
answer will be accepted.

","def sampleStats(self, count: List[int]) -> List[float]:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def sampleStats(self, count: List[int]) -> List[float]:
    minimum = next((i for i, num in enumerate(count) if num), None)
    maximum = next((i for i, num in reversed(list(enumerate(count))) if num), None)
    n = sum(count)
    mean = sum(i * c / n for i, c in enumerate(count))
    mode = count.index(max(count))

    numCount = 0
    leftMedian = 0
    for i, c in enumerate(count):
      numCount += c
      if numCount >= n / 2:
        leftMedian = i
        break

    numCount = 0
    rightMedian = 0
    for i, c in reversed(list(enumerate(count))):
      numCount += c
      if numCount >= n / 2:
        rightMedian = i
        break

    return [minimum, maximum, mean, (leftMedian + rightMedian) / 2, mode]
"
1129,"You are given an integer `n`, the number of nodes in a directed graph where
the nodes are labeled from `0` to `n - 1`. Each edge is red or blue in this
graph, and there could be self-edges and parallel edges.

You are given two arrays `redEdges` and `blueEdges` where:

* `redEdges[i] = [ai, bi]` indicates that there is a directed red edge from node `ai` to node `bi` in the graph, and
* `blueEdges[j] = [uj, vj]` indicates that there is a directed blue edge from node `uj` to node `vj` in the graph.

Return an array `answer` of length `n`, where each `answer[x]` is the length
of the shortest path from node `0` to node `x` such that the edge colors
alternate along the path, or `-1` if such a path does not exist.

","def shortestAlternatingPaths(self, n: int, redEdges: List[List[int]], blueEdges: List[List[int]]) -> List[int]:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

from enum import Enum


class Color(Enum):
  kInit = 0
  kRed = 1
  kBlue = 2


class Solution:
  def shortestAlternatingPaths(self, n: int, redEdges: List[List[int]], blueEdges: List[List[int]]) -> List[int]:
    ans = [-1] * n
    graph = [[] for _ in range(n)]
    q = collections.deque([(0, Color.kInit)])

    for u, v in redEdges:
      graph[u].append((v, Color.kRed))

    for u, v in blueEdges:
      graph[u].append((v, Color.kBlue))

    step = 0
    while q:
      for _ in range(len(q)):
        u, prevColor = q.popleft()
        if ans[u] == -1:
          ans[u] = step
        for i, (v, edgeColor) in enumerate(graph[u]):
          if v == -1 or edgeColor == prevColor:
            continue
          q.append((v, edgeColor))
          graph[u][i] = (-1, edgeColor)
      step += 1

    return ans
"
1139,"Given a 2D `grid` of `0`s and `1`s, return the number of elements in the
largest square subgrid that has all `1`s on its border, or `0` if such a
subgrid doesn't exist in the `grid`.

","def largest1BorderedSquare(self, grid: List[List[int]]) -> int:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def largest1BorderedSquare(self, grid: List[List[int]]) -> int:
    m = len(grid)
    n = len(grid[0])

    leftOnes = [[0] * n for _ in range(m)]
    topOnes = [[0] * n for _ in range(m)]

    for i in range(m):
      for j in range(n):
        if grid[i][j] == 1:
          if j==0:
            leftOnes[i][j]=1
          else:
            leftOnes[i][j]=1+leftOnes[i][j-1]
          if i==0:
            topOnes[i][j]=1
          else:
            topOnes[i][j]=1+topOnes[i-1][j]

    for sz in range(min(m, n), 0, -1):
      for i in range(m - sz + 1):
        for j in range(n - sz + 1):
          x = i + sz - 1
          y = j + sz - 1
          if min(leftOnes[i][y], leftOnes[x][y], topOnes[x][j], topOnes[x][y]) >= sz:
            return sz * sz

    return 0
"
1254,"Given a 2D `grid` consists of `0s` (land) and `1s` (water). An island is a
maximal 4-directionally connected group of `0s` and a closed island is an
island totally (all left, top, right, bottom) surrounded by `1s.`

Return the number of closed islands.

","def closedIsland(self, grid: List[List[int]]) -> int:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def closedIsland(self, grid: List[List[int]]) -> int:
    m = len(grid)
    n = len(grid[0])

    def dfs(i: int, j: int) -> None:
      if i < 0 or i == m or j < 0 or j == n:
        return
      if grid[i][j] == 1:
        return

      grid[i][j] = 1
      dfs(i + 1, j)
      dfs(i - 1, j)
      dfs(i, j + 1)
      dfs(i, j - 1)

    for i in range(m):
      for j in range(n):
        if i * j == 0 or i == m - 1 or j == n - 1:
          if grid[i][j] == 0:
            dfs(i, j)

    ans = 0

    for i in range(m):
      for j in range(n):
        if grid[i][j] == 0:
          dfs(i, j)
          ans += 1

    return ans
"
1489,"Given a weighted undirected connected graph with `n` vertices numbered from
`0` to `n - 1`, and an array `edges` where `edges[i] = [ai, bi, weighti]`
represents a bidirectional and weighted edge between nodes `ai` and `bi`. A
minimum spanning tree (MST) is a subset of the graph's edges that connects all
vertices without cycles and with the minimum possible total edge weight.

Find all the critical and pseudo-critical edges in the given graph's minimum
spanning tree (MST). An MST edge whose deletion from the graph would cause the
MST weight to increase is called a critical edge. On the other hand, a pseudo-
critical edge is that which can appear in some MSTs but not all.

Note that you can return the indices of the edges in any order.

","def __init__(self, n: int):","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator, Union

class UnionFind:
  def __init__(self, n: int):
    self.id = list(range(n))
    self.rank = [0] * n

  def unionByRank(self, u: int, v: int) -> None:
    i = self.find(u)
    j = self.find(v)
    if i == j:
      return
    if self.rank[i] < self.rank[j]:
      self.id[i] = j
    elif self.rank[i] > self.rank[j]:
      self.id[j] = i
    else:
      self.id[i] = j
      self.rank[j] += 1

  def find(self, u: int) -> int:
    if self.id[u] != u:
      self.id[u] = self.find(self.id[u])
    return self.id[u]


class Solution:
  def findCriticalAndPseudoCriticalEdges(self, n: int, edges: List[List[int]]) -> List[List[int]]:
    criticalEdges = []
    pseudoCriticalEdges = []

    for i in range(len(edges)):
      edges[i].append(i)

    edges.sort(key=lambda x: x[2])

    def getMSTWeight(firstEdge: List[int], deletedEdgeIndex: int) -> Union[int, float]:
      mstWeight = 0
      uf = UnionFind(n)

      if firstEdge:
        uf.unionByRank(firstEdge[0], firstEdge[1])
        mstWeight += firstEdge[2]

      for u, v, weight, index in edges:
        if index == deletedEdgeIndex:
          continue
        if uf.find(u) == uf.find(v):
          continue
        uf.unionByRank(u, v)
        mstWeight += weight

      root = uf.find(0)
      if any(uf.find(i) != root for i in range(n)):
        return math.inf

      return mstWeight

    mstWeight = getMSTWeight([], -1)

    for edge in edges:
      index = edge[3]
      if getMSTWeight([], index) > mstWeight:
        criticalEdges.append(index)
      elif getMSTWeight(edge, -1) == mstWeight:
        pseudoCriticalEdges.append(index)

    return [criticalEdges, pseudoCriticalEdges]
"
1263,"A storekeeper is a game in which the player pushes boxes around in a warehouse
trying to get them to target locations.

The game is represented by an `m x n` grid of characters `grid` where each
element is a wall, floor, or box.

Your task is to move the box `'B'` to the target position `'T'` under the
following rules:

* The character `'S'` represents the player. The player can move up, down, left, right in `grid` if it is a floor (empty cell).
* The character `'.'` represents the floor which means a free cell to walk.
* The character `'#'` represents the wall which means an obstacle (impossible to walk there).
* There is only one box `'B'` and one target cell `'T'` in the `grid`.
* The box can be moved to an adjacent free cell by standing next to the box and then moving in the direction of the box. This is a push.
* The player cannot walk through the box.

Return the minimum number of pushes to move the box to the target. If there is
no way to reach the target, return `-1`.

","def minPushBox(self, grid: List[List[str]]) -> int:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator
from collections import deque

class Solution:
  def minPushBox(self, grid: List[List[str]]) -> int:
    for i in range(len(grid)):
      for j in range(len(grid[0])):
        if grid[i][j] == ""T"":
          target = (i,j)
        if grid[i][j] == ""B"":
          box = (i,j)
        if grid[i][j] == ""S"":
          person = (i,j)

    def valid(x,y):
      return 0<=x<len(grid) and 0<=y<len(grid[0]) and grid[x][y]!='#'

    def check(curr,dest,box):
      que = deque([curr])
      v = set()
      while que:
        pos = que.popleft()
        if pos == dest: 
          return True
        new_pos = [(pos[0]+1,pos[1]),(pos[0]-1,pos[1]),(pos[0],pos[1]+1),(pos[0],pos[1]-1)]
        for x,y in new_pos:
          if valid(x,y) and (x,y) not in v and (x,y)!=box:
            v.add((x,y))
            que.append((x,y))
      return False

    q = deque([(0,box,person)])
    vis = {box+person}
    while q :
      dist, box, person = q.popleft()
      if box == target:
        return dist

      b_coord = [(box[0]+1,box[1]),(box[0]-1,box[1]),(box[0],box[1]+1),(box[0],box[1]-1)]
      p_coord = [(box[0]-1,box[1]),(box[0]+1,box[1]),(box[0],box[1]-1),(box[0],box[1]+1)]

      for new_box,new_person in zip(b_coord,p_coord): 
        if valid(*new_box) and new_box+box not in vis:
          if valid(*new_person) and check(person,new_person,box):
            vis.add(new_box+box)
            q.append((dist+1,new_box,box))

    return -1
"
1267,"You are given a map of a server center, represented as a `m * n` integer
matrix `grid`, where 1 means that on that cell there is a server and 0 means
that it is no server. Two servers are said to communicate if they are on the
same row or on the same column.  

Return the number of servers that communicate with any other server.

","def countServers(self, grid: List[List[int]]) -> int:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def countServers(self, grid: List[List[int]]) -> int:
    m = len(grid)
    n = len(grid[0])
    ans = 0
    rows = [0] * m
    cols = [0] * n

    for i in range(m):
      for j in range(n):
        if grid[i][j] == 1:
          rows[i] += 1
          cols[j] += 1

    for i in range(m):
      for j in range(n):
        if grid[i][j] == 1 and (rows[i] > 1 or cols[j] > 1):
          ans += 1

    return ans
"
1284,"Given a `m x n` binary matrix `mat`. In one step, you can choose one cell and
flip it and all the four neighbors of it if they exist (Flip is changing `1`
to `0` and `0` to `1`). A pair of cells are called neighbors if they share one
edge.

Return the minimum number of steps required to convert `mat` to a zero matrix
or `-1` if you cannot.

A binary matrix is a matrix with all cells equal to `0` or `1` only.

A zero matrix is a matrix with all cells equal to `0`.

","def minFlips(self, mat: List[List[int]]) -> int:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def minFlips(self, mat: List[List[int]]) -> int:
    m = len(mat)
    n = len(mat[0])
    hash = self._getHash(mat, m, n)
    if hash == 0:
      return 0

    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))
    step = 0
    q = collections.deque([hash])
    seen = {hash}

    while q:
      step += 1
      for _ in range(len(q)):
        curr = q.popleft()
        for i in range(m):
          for j in range(n):
            next = curr ^ 1 << (i * n + j)
            for dx, dy in dirs:
              x = i + dx
              y = j + dy
              if x < 0 or x == m or y < 0 or y == n:
                continue
              next ^= 1 << (x * n + y)
            if next == 0:
              return step
            if next in seen:
              continue
            q.append(next)
            seen.add(next)

    return -1

  def _getHash(self, mat: List[List[int]], m: int, n: int) -> int:
    hash = 0
    for i in range(m):
      for j in range(n):
        if mat[i][j]:
          hash |= 1 << (i * n + j)
    return hash
"
1293,"You are given an `m x n` integer matrix `grid` where each cell is either `0`
(empty) or `1` (obstacle). You can move up, down, left, or right from and to
an empty cell in one step.

Return the minimum number of steps to walk from the upper left corner `(0, 0)`
to the lower right corner `(m - 1, n - 1)` given that you can eliminate at
most `k` obstacles. If it is not possible to find such walk return `-1`.

","def shortestPath(self, grid: List[List[int]], k: int) -> int:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def shortestPath(self, grid: List[List[int]], k: int) -> int:
    m = len(grid)
    n = len(grid[0])
    if m == 1 and n == 1:
      return 0

    dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))
    steps = 0
    q = collections.deque([(0, 0, k)])
    seen = {(0, 0, k)}

    while q:
      steps += 1
      for _ in range(len(q)):
        i, j, eliminate = q.popleft()
        for l in range(4):
          x = i + dirs[l][0]
          y = j + dirs[l][1]
          if x < 0 or x == m or y < 0 or y == n:
            continue
          if x == m - 1 and y == n - 1:
            return steps
          if grid[x][y] == 1 and eliminate == 0:
            continue
          newEliminate = eliminate - grid[x][y]
          if (x, y, newEliminate) in seen:
            continue
          q.append((x, y, newEliminate))
          seen.add((x, y, newEliminate))

    return -1
"
1301,"You are given a square `board` of characters. You can move on the board
starting at the bottom right square marked with the character `'S'`.

You need to reach the top left square marked with the character `'E'`. The
rest of the squares are labeled either with a numeric character `1, 2, ..., 9`
or with an obstacle `'X'`. In one move you can go up, left or up-left
(diagonally) only if there is no obstacle there.

Return a list of two integers: the first integer is the maximum sum of numeric
characters you can collect, and the second is the number of such paths that
you can take to get that maximum sum, taken modulo `10^9 + 7`.

In case there is no path, return `[0, 0]`.

","def pathsWithMaxScore(self, board: List[str]) -> List[int]:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def pathsWithMaxScore(self, board: List[str]) -> List[int]:
    kMod = 1_000_000_007
    n = len(board)
    dirs = ((0, 1), (1, 0), (1, 1))
    dp = [[-1] * (n + 1) for _ in range(n + 1)]
    count = [[0] * (n + 1) for _ in range(n + 1)]

    dp[0][0] = 0
    dp[n - 1][n - 1] = 0
    count[n - 1][n - 1] = 1

    for i in reversed(range(n)):
      for j in reversed(range(n)):
        if board[i][j] == 'S' or board[i][j] == 'X':
          continue
        for dx, dy in dirs:
          x = i + dx
          y = j + dy
          if dp[i][j] < dp[x][y]:
            dp[i][j] = dp[x][y]
            count[i][j] = count[x][y]
          elif dp[i][j] == dp[x][y]:
            count[i][j] += count[x][y]
            count[i][j] %= kMod

        if dp[i][j] != -1 and board[i][j] != 'E':
          dp[i][j] += int(board[i][j])
          dp[i][j] %= kMod

    return [dp[0][0], count[0][0]]
"
1334,"There are `n` cities numbered from `0` to `n-1`. Given the array `edges` where
`edges[i] = [fromi, toi, weighti]` represents a bidirectional and weighted
edge between cities `fromi` and `toi`, and given the integer
`distanceThreshold`.

Return the city with the smallest number of cities that are reachable through
some path and whose distance is at most `distanceThreshold`, If there are
multiple such cities, return the city with the greatest number.

Notice that the distance of a path connecting cities i and j is equal to the
sum of the edges' weights along that path.

","def findTheCity(self, n: int, edges: List[List[int]], distanceThreshold: int) -> int:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def findTheCity(self, n: int, edges: List[List[int]], distanceThreshold: int) -> int:
    ans = -1
    minCitiesCount = n
    dist = self._floydWarshall(n, edges, distanceThreshold)

    for i in range(n):
      citiesCount = sum(dist[i][j] <= distanceThreshold for j in range(n))
      if citiesCount <= minCitiesCount:
        ans = i
        minCitiesCount = citiesCount

    return ans

  def _floydWarshall(self, n: int, edges: List[List[int]], distanceThreshold: int) -> List[List[int]]:
    dist = [[distanceThreshold + 1] * n for _ in range(n)]

    for i in range(n):
      dist[i][i] = 0

    for u, v, w in edges:
      dist[u][v] = w
      dist[v][u] = w

    for k in range(n):
      for i in range(n):
        for j in range(n):
          dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])

    return dist
"
1340,"Given an array of integers `arr` and an integer `d`. In one step you can jump
from index `i` to index:

* `i + x` where: `i + x < arr.length` and ` 0 < x <= d`.
* `i - x` where: `i - x >= 0` and ` 0 < x <= d`.

In addition, you can only jump from index `i` to index `j` if `arr[i] >
arr[j]` and `arr[i] > arr[k]` for all indices `k` between `i` and `j` (More
formally `min(i, j) < k < max(i, j)`).

You can choose any index of the array and start jumping. Return the maximum
number of indices you can visit.

Notice that you can not jump outside of the array at any time.

","def maxJumps(self, arr: List[int], d: int) -> int:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def maxJumps(self, arr: List[int], d: int) -> int:
    n = len(arr)
    dp = [1] * n
    stack = []

    for i in range(n + 1):
      while stack and (i == n or arr[stack[-1]] < arr[i]):
        indices = [stack.pop()]
        while stack and arr[stack[-1]] == arr[indices[0]]:
          indices.append(stack.pop())
        for j in indices:
          if i < n and i - j <= d:
            dp[i] = max(dp[i], dp[j] + 1)
          if stack and j - stack[-1] <= d:
            dp[stack[-1]] = max(dp[stack[-1]], dp[j] + 1)
      stack.append(i)

    return max(dp)
"
1345,"Given an array of integers `arr`, you are initially positioned at the first
index of the array.

In one step you can jump from index `i` to index:

* `i + 1` where: `i + 1 < arr.length`.
* `i - 1` where: `i - 1 >= 0`.
* `j` where: `arr[i] == arr[j]` and `i != j`.

Return the minimum number of steps to reach the last index of the array.

Notice that you can not jump outside of the array at any time.

","def minJumps(self, arr: List[int]) -> int:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def minJumps(self, arr: List[int]) -> int:
    n = len(arr)
    graph = collections.defaultdict(list)
    step = 0
    q = collections.deque([0])
    seen = {0}

    for i, a in enumerate(arr):
      graph[a].append(i)

    while q:
      for _ in range(len(q)):
        i = q.popleft()
        if i == n - 1:
          return step
        seen.add(i)
        u = arr[i]
        if i + 1 < n:
          graph[u].append(i + 1)
        if i - 1 >= 0:
          graph[u].append(i - 1)
        for v in graph[u]:
          if v in seen:
            continue
          q.append(v)
        graph[u].clear()
      step += 1
"
1417,"You are given an alphanumeric string `s`. (Alphanumeric string is a string
consisting of lowercase English letters and digits).

You have to find a permutation of the string where no letter is followed by
another letter and no digit is followed by another digit. That is, no two
adjacent characters have the same type.

Return the reformatted string or return an empty string if it is impossible to
reformat the string.

","def reformat(self, s: str) -> str:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def reformat(self, s: str) -> str:
    A=[]
    for c in s:
      if c.isalpha():
        A.append(c)
    B=[]
    for c in s:
      if c.isdigit():
        B.append(c)

    if len(A) < len(B):
      A, B = B, A
    if len(A) - len(B) > 1:
      return ''

    ans = []

    for i in range(len(B)):
      ans.append(A[i])
      ans.append(B[i])

    if len(A) == len(B) + 1:
      ans.append(A[-1])
    return ''.join(ans)
"
3123,"You are given an undirected weighted graph of `n` nodes numbered from 0 to `n
- 1`. The graph consists of `m` edges represented by a 2D array `edges`, where
`edges[i] = [ai, bi, wi]` indicates that there is an edge between nodes `ai`
and `bi` with weight `wi`.

Consider all the shortest paths from node 0 to node `n - 1` in the graph. You
need to find a boolean array `answer` where `answer[i]` is `true` if the edge
`edges[i]` is part of at least one shortest path. Otherwise, `answer[i]` is
`false`.

Return the array `answer`.

Note that the graph may not be connected.

","def findAnswer(self, n: int, edges: List[List[int]]) -> List[bool]:","import math
import itertools
import bisect
import collections
import string
import heapq
import functools
import sortedcontainers
from typing import List, Dict, Tuple, Iterator

class Solution:
  def findAnswer(self, n: int, edges: List[List[int]]) -> List[bool]:
    graph = [[] for _ in range(n)]

    for u, v, w in edges:
      graph[u].append((v, w))
      graph[v].append((u, w))

    from0 = self._dijkstra(graph, 0)
    from1 = self._dijkstra(graph, n - 1)
    return [from0[u] + w + from1[v] == from0[-1] or from0[v] + w + from1[u] == from0[-1] for u, v, w in edges]

  def _dijkstra(self, graph: List[List[Tuple[int, int]]], src: int) -> List[int]:
    dist = [10**9] * len(graph)

    dist[src] = 0
    minHeap = [(dist[src], src)]

    while minHeap:
      d, u = heapq.heappop(minHeap)
      if d > dist[u]:
        continue
      for v, w in graph[u]:
        if d + w < dist[v]:
          dist[v] = d + w
          heapq.heappush(minHeap, (dist[v], v))

    return dist
"
